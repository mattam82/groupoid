(** printing ~1 $\sim_1$ *)
(** printing ~11 $\sim_1$ *)
(** printing ~ $\sim_2$ *)
(** printing ~~ $\sim_1$ *)
(** printing ~2 $\sim_2$ *)
(** printing ⋅⋅ $⋅$ *)
(** printing ⋅⋅⋅ $⋅$ ⋅⋅*)
(** printing Π1 $\pi_1$*)
(** printing Π2 $\pi_2$*)
(** printing Πi $\pi_i$*)
(** printing --> $\longrightarrow$*)
(** printing ---> $\longrightarrow$*)
(** printing ----> $\longrightarrow_\Univ$*)
(** printing -|-> $\longrightarrow$*)
(** printing -||-> $\longrightarrow$*)
(** printing β $\beta$*)
(** printing χ $\chi$*)
(** printing γ $\gamma$*)
(** printing γt $\gamma t$*)
(** printing [! $\llbracket$*)
(** printing !] $\rrbracket$*)
(** printing |- $\vdash$*)
(** printing === $\equiv$*)
(** printing @ $\star$*)
(** printing @@ $\star$*)
(** printing @@@ $\star_\Univ$*)
(** printing ° $\circ$*)
(** printing °° $\circ$*)
(** printing °°° $\circ$*)
(** printing °°°° $\circ$*)
(** printing |g $|_g$*)
(** printing |0g $|_0$*)
(** printing [[ % %*)
(** printing ]] $_{\upharpoonright s}$*)
(** printing [[[ % %*)
(** printing ]]] $_{\upharpoonright s}$*)
(** printing Category_1 $\mathclass{PreCategory}_1$*)
(** printing Category_2 $\mathclass{PreCategory}_2$*)
(** printing CategoryP $\mathsf{PreCategory}$*)
(** printing CatType $\mathbf{UCat}$*)
(** printing Category $\mathsf{O-Category}$*)
(** printing GroupoidP $\mathsf{PreGroupoid}$*)
(** printing Groupoid $\mathsf{IsType_1}$*)
(** printing Setoid $\mathsf{IsType_0}$*)
(** printing Propoid $\mathsf{IsType_{-1}}$*)
(** printing UGroupoidType $\mathsf{Type_{1^+}}$*)
(** printing GroupoidType $\cst{Type_1}$*)
(** printing SetoidType $\mathsf{Type_0}$*)
(** printing PropoidType $\mathsf{Type_{-1}}$*)
(** printing Type0 $\mathsf{Type}_{0}^1$*)
(** printing _Type $\mathsf{Type}_{1^+}^{1^+}$*)
(** printing Groupoid_1 $\mathsf{Groupoid}_1$*)
(** printing Groupoid_2 $\mathsf{Groupoid}_2$*)
(** printing Equivalence_2 $\mathsf{Equivalence}_2$*)
(** printing Hom1 $\mathsf{Hom}_1$*)
(** printing Hom2 $\mathsf{Hom}_2$*)
(** printing Hom3 $\mathsf{Hom}_3$*)
(** printing _adjoint $\mathsf{adjoint}$*)
(** printing _section $\mathsf{section}$*)
(** printing _retraction $\mathsf{retraction}$*)
(** printing _triangle $\mathsf{triangle}$*)
(** printing nat_comp' $\mathsf{comp}$*)
(** printing _α_map $\mathsf{α}_\mathsf{map}$*)
(** printing _α_Dmap $\mathsf{α}_{\mathsf{map}^\Pi}$*)
(** printing α_map $\mathsf{α}_\mathsf{map}$*)
(** printing α_Dmap $\mathsf{α}_{\mathsf{map}^\Pi}$*)
(** printing _eq_gsection $\mathsf{eq\_section}$*)
(** printing _eq_retraction $\mathsf{eq\_retraction}$*)
(** printing Prod_Type $\Pi_\mathsf{T}$*)
(** printing _Prod $\Pi$*)
(** printing _Sum $\Sigma$*)
(** printing _Sum0 $\Sigma$*)
(** printing sum_type $\Sigma_\mathsf{T}$*)
(** printing sum_eq $\Sigma_\mathsf{Eq}$*)
(** printing sum_eq2 $\Sigma_{\mathsf{Eq}_2}$*)
(** printing eq2 $\mathsf{eq}_2$*)
(** printing eq1 $\mathsf{eq}_1$*)
(** printing HomT $\mathsf{HomSet}$*)
(** printing HomT2 $\mathsf{HomSet}_2$*)
(** printing HomT1 $\mathsf{HomSet}_1$*)
(** printing id_R $\mathsf{id}_R$*)
(** printing id_L $\mathsf{id}_L$*)
(** printing inv_R $\mathsf{inv}_R$*)
(** printing inv_L $\mathsf{inv}_L$*)
(** printing ^-1 $\hspace{-1ex}^{-1}$*)
(** printing Trunc_2 $\mathsf{Trunc}_2$*)
(** printing map_id $\mathsf{map}_\mathsf{id}$*)
(** printing map_comp $\mathsf{map}_\mathsf{comp}$*)
(** printing map2 $\mathsf{map}_2$*)
(** printing _map $\mathsf{map}$*)
(** printing _map_id $\mathsf{map}_\mathsf{id}$*)
(** printing _map_comp $\mathsf{map}_\mathsf{comp}$*)
(** printing _map2 $\mathsf{map}_2$*)
(** printing map1 $\mathsf{map}_1$*)
(** printing Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing _Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing Dmap_id $\mathsf{map}^\Pi_\mathsf{id}$*)
(** printing Dmap_comp $\mathsf{map}^\Pi_\mathsf{comp}$*)
(** printing Dmap2 $\mathsf{map}^\Pi_2$*)
(** printing _Dmap_id $\mathsf{map}^\Pi_\mathsf{id}$*)
(** printing _Dmap_comp $\mathsf{map}^\Pi_\mathsf{comp}$*)
(** printing _Dmap2 $\mathsf{map}^\Pi_2$*)
(** printing Dmap1 $\mathsf{map}^\Pi_1$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DNaturalTransformation $\mathsf{NaturalTransformation}^\Pi$*)
(** printing Dnat_trans $\mathsf{nat\_trans}^\Pi$*)
(** printing Dmodification $\mathsf{modification}^\Pi$*)
(** printing sum_weakgroupoid $\Sigma_\mathsf{WG}$*)
(** printing prod_weakgroupoid $\Pi_\mathsf{WG}$*)
(** printing IrrRelGroupoid $\mathsf{IrrRelWG}$*)
(** printing Hom_irr $\mathsf{HomIrr}$*)
(** printing ↑ $\shortuparrow$*)
(** printing ⇑ $\shortuparrow$*)
(** printing ⇑⇑ $\shortuparrow$*)
(** printing LamT_1 $\mathsf{\Lambda_{comp}}$*)
(** printing LamT $\Lambda$*)
(** printing LamT_sigma_law $\mathsf{\Lambda_{\sigma law}}$*)
(** printing Prod_sigma_law $\mathsf{Prod_{\sigma law}}$*)
(** printing Lam_sigma_law $\mathsf{Lam_{\sigma law}}$*)
(** printing App_sigma_law $\mathsf{App_{\sigma law}}$*)
(** printing SubstT_sigma_law $\mathsf{Subst_{\sigma law}}$*)
(** printing TypFam_1 $\mathsf{TypFam_{comp}}$*)
(** printing Sub_1 $\mathsf{Sub_{comp}}$*)
(** printing SubSigma_1 $\mathsf{SubSigma_{comp}}$*)
(** printing substF_1 $\mathsf{substF_{comp}}$*)
(** printing Var_1 $\mathsf{Var_{comp}}$*)
(** printing Prod_1 $\mathsf{Prod_{comp}}$*)
(** printing Lam_2 $\mathsf{Lam_{comp}}$*)
(** printing App_1 $\mathsf{App_{comp}}$*)
(** printing Sub_1 $\mathsf{Sub_{comp}}$*)
(** printing Pair_1 $\mathsf{Pair_{comp}}$*)
(** printing Proj1_1 $\mathsf{Proj1_{comp}}$*)
(** printing Proj2_1 $\mathsf{Proj2_{comp}}$*)
(** printing BetaT_1 $\mathsf{BetaT_{comp}}$*)
(** printing Sigma_1 $\mathsf{Sigma_{comp}}$*)
(** printing transport_id $\mathsf{transport_{id}}$*)
(** printing transport_eq $\mathsf{transport_{eq}}$*)
(** printing transport_map $\mathsf{transport_{map}}$*)
(** printing transport_comp $\mathsf{transport_{comp}}$*)
(** printing transport $\mathsf{transport}$*)
(** printing _Prod $\Pi$*)
(** printing Prod0 $\Pi_0$*)
(** printing prod_comp $\mathsf{\Pi_{comp}}$*)
(** printing prod_comp' $\mathsf{\Pi_{comp}}$*)
(** printing J_1 $\mathsf{J_{comp}}$*)
(** printing Id_1 $\mathsf{Id_{comp}}$*)
(** printing Refl_1 $\mathsf{Refl_{comp}}$*)
(** printing UId_1 $\mathsf{≡_{comp}}$*)
(** printing Equiv_Intro_1 $\mathsf{Equiv\_Intro_{comp}}$*)
(** printing Equiv_Elim_1 $\mathsf{Equiv\_Elim_{comp}}$*)
(** printing UId $≡$*)
(** printing UType $\Univ$*)
(** printing Elt $\mathsf{Tm}$*)
(** printing FunExt_comp $\mathsf{FunExt}_\mathsf{comp}$*)
(** printing SubSigma $\mathsf{Sub_\Sigma}$*)
(** printing with $\coqdockw{with}$*)

(* begin hide *)

Require Export Unicode.Utf8_core.
Require Import Coq.Program.Tactics.
Require Import HoTT_light groupoid fun_eq.
Require Import groupoid_interpretation_def Equiv_adjoint fun_depfun.
Require Import sum_id prod_eq sum_eq groupoid_interpretation fun_ext.

Set Implicit Arguments.
Set Universe Polymorphism.
(* Set Program Mode. *)
(* end hide *)

(** * Connection to internal categories with families 
   %\label{section:cwf}%

  We now turn to show that we actually have a model in the sense of
  internal categories with families%~\cite{dybjer:internaltt}%. More
  precisely, our work can be seen as a formalization of proof-relevant
  setoid-indexed families of setoids, where the notion of rewriting
  using notation [t with e] corresponds to the %\emph{reindexing map}%
  of families of setoids (see %\cite{PalmgrenAML}% for a detailed
  discussion of the proof-irrelevant variant).
  *)



(* begin hide *)

Definition _Prod_sigma_law {Δ Γ} (σ:[Δ -|-> Γ]) (A:Typ Γ) (F:TypFam A) :
  @NaturalTransformation Δ _ (Prod F ⋅⋅ σ) (Prod (F °°° σ))
                         (λ t : [Δ], identity ((Prod F ⋅⋅ σ) @ t)).
  intros t t' e. refine (Build_sigma _ _ _).
  simpl_id_bi. refine (Build_sigma _ _ _). intro X. exact (identity _).
  intros X X' E. apply Trunc_1.
  apply equiv_eq_nat_trans.
Defined.
                      
(* end hide *)


(**
  %\paragraph{\lrule{Substitution Laws}.}%

  In internal CwFs, substitution laws hold, but not definitionally. This
  means that substitution laws for terms need explicit rewriting using
  reindexing maps in their statements.  The situation is similar in our
  setting: a law that does not hold definitionally can only hold with
  respect to the notion of equality of the setoid/groupoid. Every
  substitution law holds using [identity] once a context has been applied, 
  which means that the only non-definitional coherences come from proofs of 
  naturality with respect to two equal contexts.

  We only present the substitution laws for products; at the level of types:
 *)

Definition Prod_sigma_law {Δ Γ} {σ : [Δ -|-> Γ]} {A : Typ Γ} {F : TypFam A}:
  Prod F ⋅⋅ σ ~1 Prod (F °°° σ) := (λ t, identity _; _Prod_sigma_law σ F).
(* begin hide *)


Program Instance SubSigma_1 {Δ Γ: Context} (σ:[Δ -|-> Γ]) (T : Typ Γ)
         : Functor (T:=[[_Sum0 (T ⋅⋅ σ)]]) (U := [[_Sum0 T]]) (λ γt , (σ @ [γt]; γt.2)).
Next Obligation. exact (map σ [X]; X.2). Defined.
Next Obligation. refine (Build_sigma _ _ _). apply (map_id σ).
                 apply Trunc_1. Defined.
Next Obligation. refine (Build_sigma _ _ _). apply (map_comp σ).
                 apply Trunc_1. Defined.
Next Obligation. refine (Build_sigma _ _ _). apply (map2 σ [X]).
                 apply Trunc_1. Defined.

Definition SubSigma {Δ Γ: Context} (σ:[Δ -|-> Γ]) {T : Typ Γ} :
  [_Sum0 (T ⋅⋅ σ) -|-> _Sum0 T] :=  (_;  SubSigma_1 _ _).


(* end hide *)

(** For the other substitution laws, we omit their definitions as they
  follow the very same pattern; the witness is always the identity plus
  a proof of naturality w.r.t. context change. To express the
  substitution law of dependent functions, we first need to exhibit the
  law for type-level abstraction [LamT]--- [SubSigma σ] is weakening [σ].  *)

Definition LamT_sigma_law {Δ Γ} {A : Typ Γ} {B : TypDep A} {σ : [Δ -|-> Γ]}:
  LamT B °°° σ ~1 LamT (B ⋅⋅ SubSigma σ).
refine (Build_sigma _ _ _). intro t. simpl.
refine (Build_sigma _ _ _). intro X. apply identity.
intros x y z. simpl_id_bi. apply equiv_eq_nat_trans. simpl. 
unfold SubSigma_1_obligation_1. apply (map2 B).
refine (Build_sigma _ _ _). simpl. apply (map_id σ).
simpl. apply Trunc_1.
intros t t' e. simpl. intro H. simpl. apply equiv_eq_nat_trans. simpl.
refine (Build_sigma _ _ _). intro b. apply identity.
intros x y z. apply Trunc_1.
(* begin hide *)
Defined.

Definition Prod_eq {Γ} (A:Typ Γ) (F F':TypFam A) : F ~1 F' -> Prod F ~1 Prod F'.
  intro H. refine (Build_sigma _ _ _).
  intro γ. simpl. exact (prod_eqT (H @ γ)).
  intros t t' e. 
  refine (Build_sigma _ _ _).
  refine (Build_sigma _ _ _).
  intros X. refine (Build_sigma _ _ _).
  intro a. simpl. exact ([α_Dmap H e a] @ _).
  intros a a' Ha. apply Trunc_1.
  intros a a' Ha. apply Trunc_1.
  apply equiv_eq_nat_trans. 
Defined.

Notation "↑ t" := (useless_coercion (t °° Sub) with Prod_sigma_law)
                    (at level 9, t at level 9).

(* end hide *)

(**
  Finally, the law for term-level abstraction can be stated, using rewriting 
  provided by the [t with e] notation.
 *)

Definition Lam_sigma_law {Δ Γ} (σ:[Δ -|-> Γ]) {A:Typ Γ} {B:TypDep A} (b:Elt B):
  (Lam b) °°°° σ with Prod_sigma_law with Prod_eq LamT_sigma_law ~1 Lam (b °°°° (SubSigma σ)).
  red. red.
  match goal with | [ |- sigma (λ α : ?H, _)]
                  => assert H end.
  (* refine (Build_sigma _ _ _). *)
  intro γ. 
  (* match goal with | [ |- sigma (λ α : ?H', _)] *)
                  (* => assert H' end. *)
  refine (Build_sigma _ _ _).
  intro a. exact (identity _).
  intros  t t' e. apply Trunc_1.
  exists X. intros t t' e H. apply Trunc_1.
(* begin hide *)
Defined.


Definition SubstT_sigma_law {Δ Γ} {A:Typ Γ} {F:TypFam A} {σ:[Δ -|-> Γ]} {a:Elt A}:
 (F {{a}}) ⋅⋅ σ ~1 (F °°° σ) {{a °°°° σ}}. 
  refine (Build_sigma _ _ _). 
  intro t. exact (identity _).
  intros t t' e. simpl_id_bi.
Defined.
(* end hide *)

(** In the same way, to state the law for function application, we need
   a law [SubstT_sigma_law] for application at the level of type families. 
*)

Definition App_sigma_law Δ Γ (A:Typ Γ) (F:TypFam A) (σ:[Δ -|-> Γ]) (c:Elt (Prod F))
  (a:Elt A): c @@ a °°°° σ with SubstT_sigma_law ~1 (c °°°° σ with Prod_sigma_law) @@ (a °°°° σ).
  refine (Build_sigma _ _ _). 
  intro t. simpl. exact (identity _). 
  intros t t' e. apply Trunc_1. 
(* begin hide *)
Defined.
Definition foo := @SubExt. (* for documentation interpolation... *)
(* end hide *)

(** %\paragraph{\lrule{Conv}.}% The %$\beta$% conversion rule for term-level
  abstractions is valid as a definitional equality (which is made explicit
  by the use of [eq_refl]), where [SubExtId] is a specialization of
  [SubExt] with the identity substitution.  *)

Definition Beta {Γ} {A:Typ Γ} {F:TypDep A} (b:Elt F) (a:Elt A):
  [Lam b @@ a] = [b °° SubExtId a] := eq_refl.

(**
 %\noindent% 
  However, %$\eta$% conversion does not hold definitionally, and we need 
  %$\eta$%-conversion at the level of type abstractions (rule [EtaT]) 
  to state it.
*)

(* begin hide *)

Definition _EtaT Γ (A:Typ Γ) (F:TypFam A) γ
: LamT ((F °°° Sub) {{Var A}}) @ γ ~1 F @ γ.
refine (Build_sigma _ _ _). intro a. apply identity.
intros t t' e. simpl_id_bi. apply equiv_eq_nat_trans.
refine (Build_sigma _ _ _).
intro X. apply inverse. eapply composition. refine ([Dmap_id F t'] @ _).
eapply composition. eapply inverse. refine ([map_comp (F @ γ) _ _] @ X).
refine ([map2 (F @ γ) _] @ X). apply Trunc_1.
intros a a' X. simpl. apply Trunc_1.
Defined.


Definition EtaT Γ (A:Typ Γ) (F:TypFam A): LamT ((F °°° Sub) {{Var A}}) ~1 F.
  exists (_EtaT _).
  intros t t' e X. simpl. unfold id, groupoid_interpretation.substF_1_obligation_1.
  simpl. apply equiv_eq_nat_trans. simpl.
  refine (Build_sigma _ _ _).
  intro f. simpl. refine (@_map _ _ _ _ _ _ _).
  assert ((map (F @ t)) (equiv_adjoint (Var A) (sum_id_right e X)) ~1 identity _).
  unfold equiv_adjoint. simpl.
  eapply composition; try exact (map_id (F @ t)). 
  refine (map2 (F @ t) _). refine (triangle_inv' _ _ ).
  refine ([X0] @ f). 
  intros a a' H. apply Trunc_1.
Defined.
(* end hide *)

Definition Eta {Γ} {A:Typ Γ} {F:TypFam A} (c:Elt (Prod F)):
  Lam (↑ c @@ Var A) with Prod_eq (EtaT F) ~1 c.
  refine (Build_sigma _ _ _).
  intro γ. refine (Build_sigma _ _ _). intro a. exact (identity _).
  intros  t t' e. apply Trunc_1.
  intros t t' e. intro X. simpl. apply Trunc_1.
  (* begin hide *)
Defined.
(* end hide *)

(** %\paragraph{\lrule{Coherence of the interpretation}.}%
  In%~\cite{dybjer:internaltt}%, the coherence of the interpretation is
  not entirely shown, and relies on Uniqueness of Identity Proofs through
  Alf's pattern-matching. In our setting the first level coherence can
  be directly expressed and proved by naturality of the interpretation,
  because we embed the setoid model inside groupoids (higher notions of coherence
  require to move to higher groupoids).  *)

Theorem coherence_of_interpretation {Γ} {A B:Typ Γ} (e e' : A ~1 B) (a:Elt A):
  e ~2 e' -> a with e ~1 a with e'.
(* begin hide *)
  intro P. exists (fun γ => ((P γ).1 @ (a @ γ))).
  intros γ γ' eγ. apply Trunc_1.
Defined. 
(* end hide *)


(** Thus, the coherence of our interpretation only requires to prove 
  that the interpretation of type equalities from the source type theory 
  only targets _identity_ isomorphisms (as then the [e ~2 e'] hypothesis would be given by 
  the identity modification). This proof is not difficult metatheoretically as every 
  conversion rule is interpreted by the identity isomorphism, but it can not be 
  internalized because it is not possible to reason on definitional equality inside 
  the theory.
 *)
