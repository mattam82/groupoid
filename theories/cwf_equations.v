(** printing ~1 $\sim_1$ *)
(** printing ~11 $\sim_1$ *)
(** printing ~ $\sim_2$ *)
(** printing ~~ $\sim_1$ *)
(** printing ~2 $\sim_2$ *)
(** printing ⋅⋅ $⋅$ *)
(** printing ⋅⋅⋅ $⋅$ ⋅⋅*)
(** printing Π1 $\pi_1$*)
(** printing Π2 $\pi_2$*)
(** printing Πi $\pi_i$*)
(** printing --> $\longrightarrow$*)
(** printing ---> $\longrightarrow$*)
(** printing ----> $\longrightarrow_\Univ$*)
(** printing -|-> $\longrightarrow$*)
(** printing -||-> $\longrightarrow$*)
(** printing β $\beta$*)
(** printing χ $\chi$*)
(** printing γ $\gamma$*)
(** printing γt $\gamma t$*)
(** printing [! $\llbracket$*)
(** printing !] $\rrbracket$*)
(** printing |- $\vdash$*)
(** printing === $\equiv$*)
(** printing @ $\star$*)
(** printing @@ $\star$*)
(** printing @@@ $\star_\Univ$*)
(** printing ° $\circ$*)
(** printing °° $\circ$*)
(** printing °°° $\circ$*)
(** printing °°°° $\circ$*)
(** printing |g $|_g$*)
(** printing |0g $|_0$*)
(** printing [[ % %*)
(** printing ]] $_{\upharpoonright s}$*)
(** printing [[[ % %*)
(** printing ]]] $_{\upharpoonright s}$*)
(** printing Category_1 $\mathclass{PreCategory}_1$*)
(** printing Category_2 $\mathclass{PreCategory}_2$*)
(** printing CategoryP $\mathsf{PreCategory}$*)
(** printing CatType $\mathbf{UCat}$*)
(** printing Category $\mathsf{O-Category}$*)
(** printing GroupoidP $\mathsf{PreGroupoid}$*)
(** printing Groupoid $\mathsf{IsType_1}$*)
(** printing Setoid $\mathsf{IsType_0}$*)
(** printing Propoid $\mathsf{IsType_{-1}}$*)
(** printing UGroupoidType $\mathsf{Type_{1^+}}$*)
(** printing GroupoidType $\cst{Type_1}$*)
(** printing SetoidType $\mathsf{Type_0}$*)
(** printing PropoidType $\mathsf{Type_{-1}}$*)
(** printing Type0 $\mathsf{Type}_{0}^1$*)
(** printing _Type $\mathsf{Type}_{1^+}^{1^+}$*)
(** printing Groupoid_1 $\mathsf{Groupoid}_1$*)
(** printing Groupoid_2 $\mathsf{Groupoid}_2$*)
(** printing Equivalence_2 $\mathsf{Equivalence}_2$*)
(** printing Hom1 $\mathsf{Hom}_1$*)
(** printing Hom2 $\mathsf{Hom}_2$*)
(** printing Hom3 $\mathsf{Hom}_3$*)
(** printing _adjoint $\mathsf{adjoint}$*)
(** printing _section $\mathsf{section}$*)
(** printing _retraction $\mathsf{retraction}$*)
(** printing _triangle $\mathsf{triangle}$*)
(** printing nat_comp' $\mathsf{comp}$*)
(** printing _α_map $\mathsf{α}_\mathsf{map}$*)
(** printing _α_Dmap $\mathsf{α}_{\mathsf{map}^\Pi}$*)
(** printing α_map $\mathsf{α}_\mathsf{map}$*)
(** printing α_Dmap $\mathsf{α}_{\mathsf{map}^\Pi}$*)
(** printing _eq_gsection $\mathsf{eq\_section}$*)
(** printing _eq_retraction $\mathsf{eq\_retraction}$*)
(** printing Prod_Type $\Pi_\mathsf{T}$*)
(** printing _Prod $\Pi$*)
(** printing _Sum $\Sigma$*)
(** printing _Sum0 $\Sigma$*)
(** printing sum_type $\Sigma_\mathsf{T}$*)
(** printing sum_eq $\Sigma_\mathsf{Eq}$*)
(** printing sum_eq2 $\Sigma_{\mathsf{Eq}_2}$*)
(** printing eq2 $\mathsf{eq}_2$*)
(** printing eq1 $\mathsf{eq}_1$*)
(** printing HomT $\mathsf{HomSet}$*)
(** printing HomT2 $\mathsf{HomSet}_2$*)
(** printing HomT1 $\mathsf{HomSet}_1$*)
(** printing id_R $\mathsf{id}_R$*)
(** printing id_L $\mathsf{id}_L$*)
(** printing inv_R $\mathsf{inv}_R$*)
(** printing inv_L $\mathsf{inv}_L$*)
(** printing ^-1 $\hspace{-1ex}^{-1}$*)
(** printing Trunc_2 $\mathsf{Trunc}_2$*)
(** printing map_id $\mathsf{map}_\mathsf{id}$*)
(** printing map_comp $\mathsf{map}_\mathsf{comp}$*)
(** printing map2 $\mathsf{map}_2$*)
(** printing _map $\mathsf{map}$*)
(** printing _map_id $\mathsf{map}_\mathsf{id}$*)
(** printing _map_comp $\mathsf{map}_\mathsf{comp}$*)
(** printing _map2 $\mathsf{map}_2$*)
(** printing map1 $\mathsf{map}_1$*)
(** printing Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing _Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing Dmap_id $\mathsf{map}^\Pi_\mathsf{id}$*)
(** printing Dmap_comp $\mathsf{map}^\Pi_\mathsf{comp}$*)
(** printing Dmap2 $\mathsf{map}^\Pi_2$*)
(** printing _Dmap_id $\mathsf{map}^\Pi_\mathsf{id}$*)
(** printing _Dmap_comp $\mathsf{map}^\Pi_\mathsf{comp}$*)
(** printing _Dmap2 $\mathsf{map}^\Pi_2$*)
(** printing Dmap1 $\mathsf{map}^\Pi_1$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DNaturalTransformation $\mathsf{NaturalTransformation}^\Pi$*)
(** printing Dnat_trans $\mathsf{nat\_trans}^\Pi$*)
(** printing Dmodification $\mathsf{modification}^\Pi$*)
(** printing sum_weakgroupoid $\Sigma_\mathsf{WG}$*)
(** printing prod_weakgroupoid $\Pi_\mathsf{WG}$*)
(** printing IrrRelGroupoid $\mathsf{IrrRelWG}$*)
(** printing Hom_irr $\mathsf{HomIrr}$*)
(** printing ↑ $\shortuparrow$*)
(** printing ⇑ $\shortuparrow$*)
(** printing ⇑⇑ $\shortuparrow$*)
(** printing LamT_1 $\mathsf{\Lambda_{comp}}$*)
(** printing LamT $\Lambda$*)
(** printing TypFam_1 $\mathsf{TypFam_{comp}}$*)
(** printing Sub_1 $\mathsf{Sub_{comp}}$*)
(** printing SubExt_1 $\mathsf{SubExt_{comp}}$*)
(** printing substF_1 $\mathsf{substF_{comp}}$*)
(** printing Var_1 $\mathsf{Var_{comp}}$*)
(** printing Prod_1 $\mathsf{Prod_{comp}}$*)
(** printing Lam_2 $\mathsf{Lam_{comp}}$*)
(** printing App_1 $\mathsf{App_{comp}}$*)
(** printing Sub_1 $\mathsf{Sub_{comp}}$*)
(** printing Pair_1 $\mathsf{Pair_{comp}}$*)
(** printing Proj1_1 $\mathsf{Proj1_{comp}}$*)
(** printing Proj2_1 $\mathsf{Proj2_{comp}}$*)
(** printing BetaT_1 $\mathsf{BetaT_{comp}}$*)
(** printing Sigma_1 $\mathsf{Sigma_{comp}}$*)
(** printing transport_id $\mathsf{transport_{id}}$*)
(** printing transport_eq $\mathsf{transport_{eq}}$*)
(** printing transport_map $\mathsf{transport_{map}}$*)
(** printing transport_comp $\mathsf{transport_{comp}}$*)
(** printing transport $\mathsf{transport}$*)
(** printing _Prod $\Pi$*)
(** printing Prod0 $\Pi_0$*)
(** printing prod_comp $\mathsf{\Pi_{comp}}$*)
(** printing prod_comp' $\mathsf{\Pi_{comp}}$*)
(** printing J_1 $\mathsf{J_{comp}}$*)
(** printing Id_1 $\mathsf{Id_{comp}}$*)
(** printing Refl_1 $\mathsf{Refl_{comp}}$*)
(** printing UId_1 $\mathsf{≡_{comp}}$*)
(** printing Equiv_Intro_1 $\mathsf{Equiv\_Intro_{comp}}$*)
(** printing Equiv_Elim_1 $\mathsf{Equiv\_Elim_{comp}}$*)
(** printing UId $≡$*)
(** printing UType $\Univ$*)
(** printing Elt $\mathsf{Tm}$*)
(** printing FunExt_comp $\mathsf{FunExt}_\mathsf{comp}$*)

(* begin hide *)

Require Export Unicode.Utf8_core.
Require Import Coq.Program.Tactics.
Add LoadPath "." as Groupoid.
Require Import HoTT_light groupoid fun_eq.
Require Import groupoid_interpretation_def Equiv_adjoint fun_depfun.
Require Import sum_id prod_eq sum_eq groupoid_interpretation.

Set Implicit Arguments.
Set Universe Polymorphism.
(* Set Program Mode. *)

Definition Prod_subst_law {Δ Γ} (σ:[Δ -|-> Γ]) (A:Typ Γ) (F:TypFam A)
  : Prod F ⋅⋅ σ ~1 Prod (F °°° σ).
  exists (fun t => identity _).
  intros t t' e. refine (Build_sigma _ _ _).
  simpl_id_bi. refine (Build_sigma _ _ _). intro X. exact (identity _).
  intros X X' E. trunc1_eq.
  apply equiv_eq_nat_trans.
Defined.

Definition useless_coercion A B (f : [A-->B]) (g : [B --> Type0]) :
  Prod_Type (fun x => [[[g]]] @ (f @ x) ; arrow_comp _ _ _ f ([[[g]]])) ->
  Prod_Type ([[[(fun x => g @ (f @ x) ; arrow_comp _ _ _ f g)]]]) := @id _.

Notation "↑ t" := (useless_coercion (t °° Sub) with Prod_subst_law _ _) (at level 9, t at level 9).

Program Instance Subm_1 {Δ Γ: Context} (σ:[Δ -|-> Γ]) (T : Typ Γ)
         : Functor (T:=[[_Sum0 (T ⋅⋅ σ)]]) (U := [[_Sum0 T]]) (λ γt , (σ @ [γt]; γt.2)).
Next Obligation. exact (map σ [X]; X.2). Defined.
Next Obligation. refine (Build_sigma _ _ _). apply (map_id σ).
                 trunc1_eq. Defined.
Next Obligation. refine (Build_sigma _ _ _). apply (map_comp σ).
                 trunc1_eq. Defined.
Next Obligation. refine (Build_sigma _ _ _). apply (map2 σ [X]).
                 trunc1_eq. Defined.

Definition Subm {Δ Γ: Context} (σ:[Δ -|-> Γ]) {T : Typ Γ} : [_Sum0 (T ⋅⋅ σ) -|-> _Sum0 T] 
    :=  (_ ; Subm_1 _ _).

Program Definition BetaT2 Δ Γ (A:Typ Γ) (B:TypDep A) (σ:[Δ -|-> Γ]) 
: LamT B °°° σ ~1 LamT (B ⋅⋅ (Subm σ)).
refine (Build_sigma _ _ _). intro t. simpl.
refine (Build_sigma _ _ _). intro X. apply identity.
intros x y z. simpl_id_bi. apply equiv_eq_nat_trans. simpl. 
unfold Subm_1_obligation_1. apply (map2 B).
refine (Build_sigma _ _ _). simpl. apply (map_id σ).
simpl. trunc1_eq.
intros t t' e. simpl. intro H. simpl. apply equiv_eq_nat_trans. simpl.
refine (Build_sigma _ _ _). intro b. apply identity.
intros x y z. trunc1_eq.
Defined.

Notation α_Dmap f := (@_α_Dmap _ _ _ _ _ (proj2 f) _ _).

Definition Prod_eq {Γ} (A:Typ Γ) (F F':TypFam A) : F ~1 F' -> Prod F ~1 Prod F'.
  intro H. refine (Build_sigma _ _ _).
  intro γ. simpl. exact (prod_eqT (H @ γ)).
  intros t t' e. 
  refine (Build_sigma _ _ _).
  refine (Build_sigma _ _ _).
  intros X. refine (Build_sigma _ _ _).
  intro a. simpl. exact ([α_Dmap H e a] @ _).
  intros a a' Ha. trunc1_eq.
  intros a a' Ha. trunc1_eq.
  apply equiv_eq_nat_trans. 
Defined.

Definition Lam_subst_law {Δ Γ} (σ:[Δ -|-> Γ]) {A:Typ Γ} {B:TypDep A} (b:Elt B) :
  (Lam b) °°°° σ with Prod_subst_law _ _ with Prod_eq (BetaT2 _ _) ~1 Lam (b °°°° (Subm σ)).
  refine (Build_sigma _ _ _).
  intro γ. refine (Build_sigma _ _ _). intro a. exact (identity _).
  intros  t t' e. trunc1_eq.
  intros t t' e. intro X. simpl. trunc1_eq.
Defined.

Definition SubstT_subst_law Δ Γ (A:Typ Γ) (F:TypFam A) (σ:[Δ -|-> Γ]) (c:Elt (Prod F)) (a:Elt A):
 (F {{a}}) ⋅⋅ σ ~1 (F °°° σ) {{a °°°° σ}}.
  refine (Build_sigma _ _ _). 
  intro t. exact (identity _).
  intros t t' e. simpl_id_bi.
Defined.

Definition appProd_eq3 Δ Γ (A:Typ Γ) (F:TypFam A) (σ:[Δ -|-> Γ]) (c:Elt (Prod F)) (a:Elt A):
  [c @@ a °°°° σ] = [(c °°°° σ with Prod_subst_law _ _) @@ (a °°°° σ)] :=
  eq_refl [((c °°°° σ) with Prod_subst_law _ _) @@ (a °°°° σ)].

(* c @@ a °°°° σ with SubstT_subst_law _ c _ ~1 (c °°°° σ with Prod_subst_law _ _) @@ (a °°°° σ). *)
(*   refine (Build_sigma _ _ _). *)
(*   intro t. simpl. exact (identity _). *)
(*   intros t t' e. trunc1_eq. *)
(* Defined. *)

Definition _EtaT Γ (A:Typ Γ) (F:TypFam A) γ
: LamT ((F °°° Sub) {{Var A}}) @ γ ~1 F @ γ.
refine (Build_sigma _ _ _). intro a. apply identity.
intros t t' e. simpl_id_bi. apply equiv_eq_nat_trans.
refine (Build_sigma _ _ _).
intro X. apply inverse. eapply composition. refine ([Dmap_id F t'] @ _).
eapply composition. eapply inverse. refine ([map_comp (F @ γ) _ _] @ X).
refine ([map2 (F @ γ) _] @ X). trunc1_eq.
intros a a' X. simpl. trunc1_eq.
Defined.

Definition EtaT Γ (A:Typ Γ) (F:TypFam A)
: LamT ((F °°° Sub) {{Var A}}) ~1 F.
  exists (_EtaT _).
  intros t t' e X. simpl. unfold id, groupoid_interpretation.substF_1_obligation_1.
  simpl. apply equiv_eq_nat_trans. simpl.
  refine (Build_sigma _ _ _).
  intro f. simpl. refine (map _ _).
  assert ((map (F @ t)) (equiv_adjoint (Var A) (sum_id_right e X)) ~1 identity _).
  unfold equiv_adjoint. simpl.
  eapply composition; try exact (map_id (F @ t)). 
  refine (map2 (F @ t) _). refine (triangle_inv' _ _ ).
  refine ([X0] @ f). 
  intros a a' H. trunc1_eq.
Defined.

Definition Eta {Γ} {A:Typ Γ} {F:TypFam A} (c:Elt (Prod F))
: Lam (↑ c @@ Var _) with Prod_eq (EtaT F) ~1 c.
  refine (Build_sigma _ _ _).
  intro γ. refine (Build_sigma _ _ _). intro a. exact (identity _).
  intros  t t' e. trunc1_eq.
  intros t t' e. intro X. simpl. trunc1_eq.
Defined.

