(** printing ~1 $\sim_1$ *)
(** printing ~11 $\sim_1$ *)
(** printing ~ $\sim_2$ *)
(** printing ~~ $\sim_1$ *)
(** printing ~2 $\sim_2$ *)
(** printing ⋅⋅ $⋅$ *)
(** printing ⋅⋅⋅ $⋅$ ⋅⋅*)
(** printing Π1 $\pi_1$*)
(** printing Π2 $\pi_2$*)
(** printing Πi $\pi_i$*)
(** printing --> $\longrightarrow$*)
(** printing ---> $\longrightarrow$*)
(** printing ----> $\longrightarrow_\Univ$*)
(** printing -|-> $\longrightarrow$*)
(** printing -||-> $\longrightarrow$*)
(** printing β $\beta$*)
(** printing χ $\chi$*)
(** printing γ $\gamma$*)
(** printing γt $\gamma t$*)
(** printing [! $\llbracket$*)
(** printing !] $\rrbracket$*)
(** printing |- $\vdash$*)
(** printing === $\equiv$*)
(** printing @ $\star$*)
(** printing @@ $\star$*)
(** printing @@@ $\star_\Univ$*)
(** printing ° $\circ$*)
(** printing °° $\circ$*)
(** printing °°° $\circ$*)
(** printing °°°° $\circ$*)
(** printing |g $|_g$*)
(** printing |0g $|_0$*)
(** printing [[ % %*)
(** printing ]] $_{\upharpoonright s}$*)
(** printing [[[ % %*)
(** printing ]]] $_{\upharpoonright s}$*)
(** printing Category_1 $\mathclass{PreCategory}_1$*)
(** printing Category_2 $\mathclass{PreCategory}_2$*)
(** printing CategoryP $\mathsf{PreCategory}$*)
(** printing CatType $\mathbf{UCat}$*)
(** printing Category $\mathsf{O-Category}$*)
(** printing GroupoidP $\mathsf{PreGroupoid}$*)
(** printing Groupoid $\mathsf{IsType_1}$*)
(** printing Setoid $\mathsf{IsType_0}$*)
(** printing Propoid $\mathsf{IsType_{-1}}$*)
(** printing UGroupoidType $\mathsf{Type_{1^+}}$*)
(** printing GroupoidType $\cst{Type_1}$*)
(** printing SetoidType $\mathsf{Type_0}$*)
(** printing PropoidType $\mathsf{Type_{-1}}$*)
(** printing Type0 $\mathsf{Type}_{0}^1$*)
(** printing _Type $\mathsf{Type}_{1^+}^{1^+}$*)
(** printing Groupoid_1 $\mathsf{Groupoid}_1$*)
(** printing Groupoid_2 $\mathsf{Groupoid}_2$*)
(** printing Equivalence_2 $\mathsf{Equivalence}_2$*)
(** printing Hom1 $\mathsf{Hom}_1$*)
(** printing Hom2 $\mathsf{Hom}_2$*)
(** printing Hom3 $\mathsf{Hom}_3$*)
(** printing _adjoint $\mathsf{adjoint}$*)
(** printing _section $\mathsf{section}$*)
(** printing _retraction $\mathsf{retraction}$*)
(** printing _triangle $\mathsf{triangle}$*)
(** printing nat_comp' $\mathsf{comp}$*)
(** printing _α_map $\mathsf{α}_\mathsf{map}$*)
(** printing _α_Dmap $\mathsf{α}_{\mathsf{map}^\Pi}$*)
(** printing α_map $\mathsf{α}_\mathsf{map}$*)
(** printing α_Dmap $\mathsf{α}_{\mathsf{map}^\Pi}$*)
(** printing _eq_gsection $\mathsf{eq\_section}$*)
(** printing _eq_retraction $\mathsf{eq\_retraction}$*)
(** printing Prod_Type $\Pi_\mathsf{T}$*)
(** printing _Prod $\Pi$*)
(** printing _Sum $\Sigma$*)
(** printing _Sum0 $\Sigma$*)
(** printing sum_type $\Sigma_\mathsf{T}$*)
(** printing sum_eq $\Sigma_\mathsf{Eq}$*)
(** printing sum_eq2 $\Sigma_{\mathsf{Eq}_2}$*)
(** printing eq2 $\mathsf{eq}_2$*)
(** printing eq1 $\mathsf{eq}_1$*)
(** printing HomT $\mathsf{HomSet}$*)
(** printing HomT2 $\mathsf{HomSet}_2$*)
(** printing HomT1 $\mathsf{HomSet}_1$*)
(** printing id_R $\mathsf{id}_R$*)
(** printing id_L $\mathsf{id}_L$*)
(** printing inv_R $\mathsf{inv}_R$*)
(** printing inv_L $\mathsf{inv}_L$*)
(** printing ^-1 $\hspace{-1ex}^{-1}$*)
(** printing Trunc_2 $\mathsf{Trunc}_2$*)
(** printing map_id $\mathsf{map}_\mathsf{id}$*)
(** printing map_comp $\mathsf{map}_\mathsf{comp}$*)
(** printing map2 $\mathsf{map}_2$*)
(** printing _map $\mathsf{map}$*)
(** printing _map_id $\mathsf{map}_\mathsf{id}$*)
(** printing _map_comp $\mathsf{map}_\mathsf{comp}$*)
(** printing _map2 $\mathsf{map}_2$*)
(** printing map1 $\mathsf{map}_1$*)
(** printing Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing _Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing Dmap_id $\mathsf{map}^\Pi_\mathsf{id}$*)
(** printing Dmap_comp $\mathsf{map}^\Pi_\mathsf{comp}$*)
(** printing Dmap2 $\mathsf{map}^\Pi_2$*)
(** printing _Dmap_id $\mathsf{map}^\Pi_\mathsf{id}$*)
(** printing _Dmap_comp $\mathsf{map}^\Pi_\mathsf{comp}$*)
(** printing _Dmap2 $\mathsf{map}^\Pi_2$*)
(** printing Dmap1 $\mathsf{map}^\Pi_1$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DNaturalTransformation $\mathsf{NaturalTransformation}^\Pi$*)
(** printing Dnat_trans $\mathsf{nat\_trans}^\Pi$*)
(** printing Dmodification $\mathsf{modification}^\Pi$*)
(** printing sum_weakgroupoid $\Sigma_\mathsf{WG}$*)
(** printing prod_weakgroupoid $\Pi_\mathsf{WG}$*)
(** printing IrrRelGroupoid $\mathsf{IrrRelWG}$*)
(** printing Hom_irr $\mathsf{HomIrr}$*)
(** printing ↑ $\shortuparrow$*)
(** printing ⇑ $\shortuparrow$*)
(** printing ⇑⇑ $\shortuparrow$*)
(** printing LamT_1 $\mathsf{\Lambda_{comp}}$*)
(** printing LamT $\Lambda$*)
(** printing TypFam_1 $\mathsf{TypFam_{comp}}$*)
(** printing Sub_1 $\mathsf{Sub_{comp}}$*)
(** printing SubExt_1 $\mathsf{SubExt_{comp}}$*)
(** printing substF_1 $\mathsf{substF_{comp}}$*)
(** printing Var_1 $\mathsf{Var_{comp}}$*)
(** printing Prod_1 $\mathsf{Prod_{comp}}$*)
(** printing Lam_2 $\mathsf{Lam_{comp}}$*)
(** printing App_1 $\mathsf{App_{comp}}$*)
(** printing Sub_1 $\mathsf{Sub_{comp}}$*)
(** printing Pair_1 $\mathsf{Pair_{comp}}$*)
(** printing Proj1_1 $\mathsf{Proj1_{comp}}$*)
(** printing Proj2_1 $\mathsf{Proj2_{comp}}$*)
(** printing BetaT_1 $\mathsf{BetaT_{comp}}$*)
(** printing Sigma_1 $\mathsf{Sigma_{comp}}$*)
(** printing transport_id $\mathsf{transport_{id}}$*)
(** printing transport_eq $\mathsf{transport_{eq}}$*)
(** printing transport_map $\mathsf{transport_{map}}$*)
(** printing transport_comp $\mathsf{transport_{comp}}$*)
(** printing transport $\mathsf{transport}$*)
(** printing _Prod $\Pi$*)
(** printing Prod0 $\Pi_0$*)
(** printing prod_comp $\mathsf{\Pi_{comp}}$*)
(** printing prod_comp' $\mathsf{\Pi_{comp}}$*)
(** printing J_1 $\mathsf{J_{comp}}$*)
(** printing Id_1 $\mathsf{Id_{comp}}$*)
(** printing Refl_1 $\mathsf{Refl_{comp}}$*)
(** printing UId_1 $\mathsf{≡_{comp}}$*)
(** printing Equiv_Intro_1 $\mathsf{Equiv\_Intro_{comp}}$*)
(** printing Equiv_Elim_1 $\mathsf{Equiv\_Elim_{comp}}$*)
(** printing UId $≡$*)
(** printing UType $\Univ$*)
(** printing Elt $\mathsf{Tm}$*)
(** printing FunExt_comp $\mathsf{FunExt}_\mathsf{comp}$*)

(* begin hide *)

Require Export Unicode.Utf8_core.
Require Import Coq.Program.Tactics.
Add LoadPath "." as Groupoid.
Require Import Groupoid.HoTT_light.
Require Import Groupoid.groupoid.
Require Import Groupoid.fun_eq.
Require Import Groupoid.groupoid_interpretation_def.
Require Import Groupoid.Equiv_adjoint.
Require Import Groupoid.fun_depfun.
Require Import Groupoid.sum_id.
Require Import Groupoid.prod_eq.
Require Import Groupoid.sum_eq.
Require Import Groupoid.groupoid_interpretation.

Set Implicit Arguments.
Set Universe Polymorphism.
(* Set Program Mode. *)

Lemma eq_Prod_ctxt {T Γ} (A:Typ Γ) (F:TypFam A) (f: [T -|-> Γ]) :
  Prod F ⋅⋅ f ~1 Prod (F °°° f).
  simpl.
  exists (fun t => identity (Prod0 ([F] ([f] t)))). 
  intros x y e. apply equiv_eq_nat_trans. simpl. red. simpl.
  refine (Build_sigma _ _ _). intro. apply identity. 
  intros t t' X a. trunc1_eq.
Defined.

(* end hide *)

(** 
  Propositional functional extensionality is a direct consequence of the definition
  of equality at product types. It is simply witnessed by a natural transformation
  between the (dependent) functions, that is a pointwise equality. This corresponds 
  to the introduction of equality on dependent functions in%~\cite{DBLP:conf/popl/LicataH12}%.
*)

(* begin hide *)

Definition useless_coercion A B (f : [A-->B]) (g : [B --> Type0]) :
  Prod_Type (fun x => [[[g]]] @ (f @ x) ; arrow_comp _ _ _ f ([[[g]]])) ->
  Prod_Type ([[[(fun x => g @ (f @ x) ; arrow_comp _ _ _ f g)]]]) := @id _.

Notation "↑ t" := (useless_coercion (t °° Sub) with eq_Prod_ctxt _ _) (at level 9, t at level 9).

Definition FunExt_1 (Γ: Context) (A : Typ Γ)
           (F : TypDep A) (M N : Elt (Prod (LamT F)))
           (α : Elt (Prod (LamT (Id (↑ M @@ Var A) (↑ N @@ Var A))))):
  ∀ t : [Γ], [([[[Id M N]]]) @ t] :=
  fun t => ((α @ t).1; fun a a' e =>
                         eq_is_eq2 _ (@HoTT_light.center _ (Trunc_1 _ _ _ _ _))).

(*end hide*)

Definition FunExt (Γ: Context) (A : Typ Γ)
           (F : TypDep A) (M N : Elt (Prod (LamT F)))
           (α : Elt (Prod (LamT (Id (↑ M @@ Var A) (↑ N @@ Var A)))))
: Elt (Id M N).
(*begin hide*)
  exists (FunExt_1 α).
  refine (Build_DependentFunctor _ _ _ _ _ _).
  intros x y e t. trunc1_eq.
  intros; exact tt.
  intros; exact tt.
  intros; exact tt.
Defined.
(*end hide *)

(**  %\noindent% where [↑M] is the weakening for terms. 
*)
