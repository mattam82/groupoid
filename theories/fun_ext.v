(** printing ~1 $\sim_1$ *)
(** printing ~11 $\sim_1$ *)
(** printing ~ $\sim_2$ *)
(** printing ~~ $\sim_1$ *)
(** printing ~2 $\sim_2$ *)
(** printing ⋅⋅ $⋅$ *)
(** printing ⋅⋅⋅ $⋅$ ⋅⋅*)
(** printing Π1 $\pi_1$*)
(** printing Π2 $\pi_2$*)
(** printing Πi $\pi_i$*)
(** printing --> $\longrightarrow$*)
(** printing ---> $\longrightarrow$*)
(** printing ----> $\longrightarrow_\Univ$*)
(** printing -|-> $\longrightarrow$*)
(** printing -||-> $\longrightarrow$*)
(** printing β $\beta$*)
(** printing χ $\chi$*)
(** printing γ $\gamma$*)
(** printing γt $\gamma t$*)
(** printing [! $\llbracket$*)
(** printing !] $\rrbracket$*)
(** printing |- $\vdash$*)
(** printing === $\equiv$*)
(** printing @ $\star$*)
(** printing @@ $\star$*)
(** printing @@@ $\star_\Univ$*)
(** printing ° $\circ$*)
(** printing °° $\circ$*)
(** printing °°° $\circ$*)
(** printing °°°° $\circ$*)
(** printing |g $|_g$*)
(** printing |0g $|_0$*)
(** printing [[ % %*)
(** printing ]] $_{\upharpoonright s}$*)
(** printing [[[ % %*)
(** printing ]]] $_{\upharpoonright s}$*)
(** printing Category_1 $\mathclass{PreCategory}_1$*)
(** printing Category_2 $\mathclass{PreCategory}_2$*)
(** printing CategoryP $\mathsf{PreCategory}$*)
(** printing CatType $\mathbf{UCat}$*)
(** printing Category $\mathsf{O-Category}$*)
(** printing GroupoidP $\mathsf{PreGroupoid}$*)
(** printing Groupoid $\mathsf{IsType_1}$*)
(** printing Setoid $\mathsf{IsType_0}$*)
(** printing Propoid $\mathsf{IsType_{-1}}$*)
(** printing UGroupoidType $\mathsf{Type_{1^+}}$*)
(** printing GroupoidType $\cst{Type_1}$*)
(** printing SetoidType $\mathsf{Type_0}$*)
(** printing PropoidType $\mathsf{Type_{-1}}$*)
(** printing Type0 $\mathsf{Type}_{0}^1$*)
(** printing _Type $\mathsf{Type}_{1^+}^{1^+}$*)
(** printing Groupoid_1 $\mathsf{Groupoid}_1$*)
(** printing Groupoid_2 $\mathsf{Groupoid}_2$*)
(** printing Equivalence_2 $\mathsf{Equivalence}_2$*)
(** printing Hom1 $\mathsf{Hom}_1$*)
(** printing Hom2 $\mathsf{Hom}_2$*)
(** printing Hom3 $\mathsf{Hom}_3$*)
(** printing _adjoint $\mathsf{adjoint}$*)
(** printing _section $\mathsf{section}$*)
(** printing _retraction $\mathsf{retraction}$*)
(** printing _triangle $\mathsf{triangle}$*)
(** printing nat_comp' $\mathsf{comp}$*)
(** printing _α_map $\mathsf{α}_\mathsf{map}$*)
(** printing _α_Dmap $\mathsf{α}_{\mathsf{map}^\Pi}$*)
(** printing α_map $\mathsf{α}_\mathsf{map}$*)
(** printing α_Dmap $\mathsf{α}_{\mathsf{map}^\Pi}$*)
(** printing _eq_gsection $\mathsf{eq\_section}$*)
(** printing _eq_retraction $\mathsf{eq\_retraction}$*)
(** printing Prod_Type $\Pi_\mathsf{T}$*)
(** printing _Prod $\Pi$*)
(** printing _Sum $\Sigma$*)
(** printing _Sum0 $\Sigma$*)
(** printing sum_type $\Sigma_\mathsf{T}$*)
(** printing sum_eq $\Sigma_\mathsf{Eq}$*)
(** printing sum_eq2 $\Sigma_{\mathsf{Eq}_2}$*)
(** printing eq2 $\mathsf{eq}_2$*)
(** printing eq1 $\mathsf{eq}_1$*)
(** printing HomT $\mathsf{HomSet}$*)
(** printing HomT2 $\mathsf{HomSet}_2$*)
(** printing HomT1 $\mathsf{HomSet}_1$*)
(** printing id_R $\mathsf{id}_R$*)
(** printing id_L $\mathsf{id}_L$*)
(** printing inv_R $\mathsf{inv}_R$*)
(** printing inv_L $\mathsf{inv}_L$*)
(** printing ^-1 $\hspace{-1ex}^{-1}$*)
(** printing Trunc_2 $\mathsf{Trunc}_2$*)
(** printing map_id $\mathsf{map}_\mathsf{id}$*)
(** printing map_comp $\mathsf{map}_\mathsf{comp}$*)
(** printing map2 $\mathsf{map}_2$*)
(** printing _map $\mathsf{map}$*)
(** printing _map_id $\mathsf{map}_\mathsf{id}$*)
(** printing _map_comp $\mathsf{map}_\mathsf{comp}$*)
(** printing _map2 $\mathsf{map}_2$*)
(** printing map1 $\mathsf{map}_1$*)
(** printing Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing _Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing Dmap_id $\mathsf{map}^\Pi_\mathsf{id}$*)
(** printing Dmap_comp $\mathsf{map}^\Pi_\mathsf{comp}$*)
(** printing Dmap2 $\mathsf{map}^\Pi_2$*)
(** printing _Dmap_id $\mathsf{map}^\Pi_\mathsf{id}$*)
(** printing _Dmap_comp $\mathsf{map}^\Pi_\mathsf{comp}$*)
(** printing _Dmap2 $\mathsf{map}^\Pi_2$*)
(** printing Dmap1 $\mathsf{map}^\Pi_1$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DNaturalTransformation $\mathsf{NaturalTransformation}^\Pi$*)
(** printing Dnat_trans $\mathsf{nat\_trans}^\Pi$*)
(** printing Dmodification $\mathsf{modification}^\Pi$*)
(** printing sum_weakgroupoid $\Sigma_\mathsf{WG}$*)
(** printing prod_weakgroupoid $\Pi_\mathsf{WG}$*)
(** printing IrrRelGroupoid $\mathsf{IrrRelWG}$*)
(** printing Hom_irr $\mathsf{HomIrr}$*)
(** printing ↑ $\shortuparrow$*)
(** printing ⇑ $\shortuparrow$*)
(** printing ⇑⇑ $\shortuparrow$*)
(** printing LamT_1 $\mathsf{\Lambda_{comp}}$*)
(** printing LamT $\Lambda$*)
(** printing TypFam_1 $\mathsf{TypFam_{comp}}$*)
(** printing Sub_1 $\mathsf{Sub_{comp}}$*)
(** printing SubExt_1 $\mathsf{SubExt_{comp}}$*)
(** printing substF_1 $\mathsf{substF_{comp}}$*)
(** printing Var_1 $\mathsf{Var_{comp}}$*)
(** printing Prod_1 $\mathsf{Prod_{comp}}$*)
(** printing Lam_2 $\mathsf{Lam_{comp}}$*)
(** printing App_1 $\mathsf{App_{comp}}$*)
(** printing Sub_1 $\mathsf{Sub_{comp}}$*)
(** printing Pair_1 $\mathsf{Pair_{comp}}$*)
(** printing Proj1_1 $\mathsf{Proj1_{comp}}$*)
(** printing Proj2_1 $\mathsf{Proj2_{comp}}$*)
(** printing BetaT_1 $\mathsf{BetaT_{comp}}$*)
(** printing Sigma_1 $\mathsf{Sigma_{comp}}$*)
(** printing transport_id $\mathsf{transport_{id}}$*)
(** printing transport_eq $\mathsf{transport_{eq}}$*)
(** printing transport_map $\mathsf{transport_{map}}$*)
(** printing transport_comp $\mathsf{transport_{comp}}$*)
(** printing transport $\mathsf{transport}$*)
(** printing _Prod $\Pi$*)
(** printing Prod0 $\Pi_0$*)
(** printing prod_comp $\mathsf{\Pi_{comp}}$*)
(** printing prod_comp' $\mathsf{\Pi_{comp}}$*)
(** printing J_1 $\mathsf{J_{comp}}$*)
(** printing Id_1 $\mathsf{Id_{comp}}$*)
(** printing Refl_1 $\mathsf{Refl_{comp}}$*)
(** printing UId_1 $\mathsf{≡_{comp}}$*)
(** printing Equiv_Intro_1 $\mathsf{Equiv\_Intro_{comp}}$*)
(** printing Equiv_Elim_1 $\mathsf{Equiv\_Elim_{comp}}$*)
(** printing UId $≡$*)
(** printing UType $\Univ$*)
(** printing Elt $\mathsf{Tm}$*)
(* begin hide *)

Require Export Unicode.Utf8_core.
Require Import Coq.Program.Tactics.
Add LoadPath "." as Groupoid.
Require Import Groupoid.HoTT_light.
Require Import Groupoid.groupoid.
Require Import Groupoid.fun_eq.
Require Import Groupoid.groupoid_interpretation_def.
Require Import Groupoid.Equiv_adjoint.
Require Import Groupoid.fun_depfun.
Require Import Groupoid.sum_id.
Require Import Groupoid.prod_eq.
Require Import Groupoid.sum_eq.
Require Import Groupoid.groupoid_interpretation.

Set Implicit Arguments.
Set Universe Polymorphism.
(* Set Program Mode. *)

Lemma eq_Prod_ctxt {T Γ} (A:Typ Γ) (F:TypFam A) (f: [T -|-> Γ]) :
  Prod F ⋅⋅ f ~1 Prod (F °°° f).
  exists (fun t => identity (Prod0 ([F] ([f] t)))). 
  intros x y e. simpl. simpl_id_bi. apply equiv_eq_nat_trans. simpl. red. simpl.
  match goal with | [ |- sigma (λ α : ?H, _)]
                  => assert H end.
  intro ; red. simpl.
  match goal with | [ |- sigma (λ α : ?H, _)]
                  => assert H end.
  intro. simpl. unfold substF.  
  admit. exists X. red. intros. trunc1_eq.
  exists X. red. intros. simpl. red. intro. trunc1_eq.
Defined.

Notation "↑ t" := (t °° Sub with eq_Prod_ctxt _ _) (at level 9, t at level 9).
 
(* Definition Dmap_id_adjoint {Γ} {A:Typ Γ} (F:TypFam A) {γ : [Γ]} *)
(*   {x y : [A @ γ]} (e : x ~1 y) : [Dmap F (identity γ)] y ° *)
(*           (map ([F] γ) (equiv_adjoint (Var A) (sum_id_left e))) *)
(*  ~ map ([F] γ) e. *)
(* admit. *)
(* Defined. *)

Definition apType (Γ: Context) (A : Typ Γ)
  (F : TypDep A) (M N : Elt (Prod (LamT F))) :=
  ∀ t : sum_type A,
    (M @ [t]) @ eq_section t ~1 (N @ [t]) @ eq_section t.

(* Definition FunExt (Γ: Context) (A : Typ Γ) *)
(*   (F : TypDep A) (M N : Elt (Prod (LamT F))) *)
(*   (* (α : ↑M @@ Var A ~1 ↑N @@ Var A) : *) *)
(*   (α : apType M N) : *)
(*   M ~1 N. *)
  
Definition FunExt_1 (Γ: Context) (A : Typ Γ) 
        (F : TypDep A) (M N : Elt (Prod (LamT F))) 
        (* (α : ↑M @@ Var A ~1 ↑N @@ Var A) : *)
        (α : apType M N) : 
  ∀ γ : [Γ], M @ γ ~1 N @ γ. 
intro γ. exists (fun t => α (γ ; t)). 
intros t t' e. trunc1_eq.
Defined.

(* end hide *)

(** 
  ** Functional Extensionality 

  As the whole interpretation is functorial with respect to a context,
  the naturality condition required on equality between dependent
  functors can be deduced from the existence of a transformation. 
  This allows to state dependent functional extensionality. 

[Definition FunExt Γ (A : Typ Γ)
        (F : TypDep A) (M N : Elt (Prod (LamT F)))
        (α : ↑M @@ Var A ~1 ↑N @@ Var A): M ~1 N.]

  %\noindent% where [↑M] is the weakening for terms. This rule corresponds 
  to the introduction of equality on dependent functions in %\cite{DBLP:conf/popl/LicataH12}%.
*)

(* begin hide *)
Definition FunExt (Γ: Context) (A : Typ Γ)
           (F : TypDep A) (M N : Elt (Prod (LamT F)))
        (* (α' : ↑M @@ Var A ~1 ↑N @@ Var A)  *)
        (α : apType M N) : 
  M ~1 N.
Proof.
  exists (FunExt_1 α). intros t t' e a. trunc1_eq. 
Defined.

Definition FunExt_Elim (Γ: Context) (A : Typ Γ)
        (F :  TypDep A) (M N : Elt (Prod (LamT F))) (a : Elt A) (α : M ~1 N)
        : M @@ a ~1 N @@ a.
exists (fun γ => ((α @ γ) @ (a @ γ))). 
intros t t' e. trunc1_eq. 
Defined.

Definition Conversion_Eq (Γ: Context) (A B: Typ Γ) 
        (t : Elt A) (e : A = B) : Elt B.
Proof. destruct e. exact t. Defined.

(** We can finally interpret a homotopical version of rewriting at the
  level of types. *)

Definition Heq_rect Γ (A B: Typ Γ) (e : A ~1 B) : 
  Elt A -> Elt B.
Proof. exact (fun t => prod_eq e @ t). Defined.

(* end hide *)


(*
(* begin hide *)

Program Instance set_fun_1 (Γ: Context) (A B : Typ Γ) : Functor (T := [[Γ]]) (U:=Type0) (fun γ => A @ γ -|-> B @ γ).
Next Obligation. intros. simpl. apply (fun_eqT (map A X) (map B X)). Defined.
Next Obligation. intros. unfold set_fun_1_obligation_1. 
                 exists (fun_eq_id2 ([[[A]]]) ([[[B]]]) x). 
                 red. red. intro. intro. trunc1_eq. Defined.

Next Obligation. intros. unfold set_fun_1_obligation_1. 
                 exists (fun_eq_eq' _ _ _ _ ° fun_eq_eq (map_comp A e e') (map_comp B e e')).
                 red. red. intro. intro. trunc1_eq. Defined.
Next Obligation. intros. unfold set_fun_1_obligation_1. 
                 exists (fun_eq_eq (map2 A X) (map2 B X)).
                 intros f t. 
                 trunc1_eq.
Defined.

Definition set_fun (Γ: Context) (A B : Typ Γ) : Typ Γ :=
  (fun γ : [Γ] => A @ γ -|-> B @ γ; set_fun_1 Γ A B).

(* Definition set_fun (Γ: Context) (A B : Typ Γ) : Typ Γ := Prod (cst_fibration A B).  *)

Infix "---->" := set_fun (at level 55). 

Program Instance AppF_1 {Γ} {A B:Typ Γ} (f:Elt (A ----> B)) (a:Elt A) :
  DependentFunctor ([[[B]]]) (λ s : [Γ], (f @ s) @ (a @ s)).
Next Obligation. eapply composition.  simpl in *.
                 assert (f @ x @ (a @ x) ~1 f @ x @ (adjoint (map A e) @ (a @ y))).
                 apply (map (f @ x)). apply (Equiv_injective (map A e)). 
                 eapply composition. apply (Dmap a). apply inverse.
                 apply (section (map A e)). 
                 apply (map [map B e] X).
                 apply (Dmap f e @ (a @ y)).
Defined.
Next Obligation. trunc1_eq. Defined.
Next Obligation. trunc1_eq. Defined.
Next Obligation. trunc1_eq. Defined.

Definition AppF {Γ} {A B:Typ Γ} (f:Elt (A ----> B)) (a:Elt A)
: Elt B := (λ s, (f @ s) @ (a @ s); AppF_1 _ _).

Program Instance ndep_ {Γ} (T:Context) : Functor (T := [[Γ]]) (U:=Type0) (λ γ, T).
Next Obligation. apply identity. Defined.
Next Obligation. apply identity. Defined.
Next Obligation. apply equiv_eq_nat_trans. simpl. exists (fun _ => identity _). 
                 red. intros. simpl. simpl_id_bi.
Defined.
Next Obligation. apply identity. Defined.
  
Definition ndep {Γ} (T:Context) : Typ Γ := (λ γ, T; ndep_ _).

Definition eq_fun_ctxt {T Γ} (A B: Typ Γ) (f: [T -|-> Γ]) :
  nat_trans ((A ----> B) ⋅⋅ f)  (A ⋅⋅ f  ----> B ⋅⋅ f).
  red; simpl. exists (fun t => identity _). red. intros.
  eapply composition. apply equiv_id_L.
  apply inverse. apply equiv_id_R. 
Defined.

Notation "e 'with' t" := (prod_eq' t @ e) (at level 50).

Notation "↑ t" := (t °° Sub with eq_fun_ctxt _ _ _) (at level 9, t at level 9). 

Notation "'Forall' X" := (Prod (LamT X)) (at level 55).
 
Program Instance UId__ {Γ} (A B: Typ Γ) (γ : [Γ]) : Setoid (Equiv' (A @ γ) (B @ γ)).
Next Obligation. econstructor. intros. 
                 apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ E E'))).
                 apply contr_forall. intros z.
                 apply (@is_Trunc_2 _ _ _ _ _ _ (E z) (E' z)).
Defined.
Next Obligation.
  apply (@contr_equiv _ _ _ (path_sigma_equiv e e')).
  apply (@contr_sigma _ (fun p => p # e.2 = e'.2)).
  apply (@contr_equiv _ _ _ (path_sigma_equiv e.1 e'.1)).
  apply (@contr_sigma _ (fun p => p # e.1.2 = e'.1.2)).
  apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ [e.1] [e'.1]))).
  apply contr_forall. intros z.
  apply (@is_Trunc_1 _ _ _ _ (e.1 @ z) (e'.1 @ z)).
  intros. destruct e, e'. destruct proj1, proj0. simpl in *. destruct a. simpl. 
  apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ _ _))).
  apply contr_forall. intros t. 
  apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ _ _))).
  apply contr_forall. intros t'. 
  apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ _ _))).
  apply contr_forall. intros e. 
  apply (@is_Trunc_2 _ _ _ _ _ _ _ _).
  intros. destruct e, e'. destruct proj1, proj0. simpl in *. destruct a. simpl. 
  apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ _ _))).
  apply contr_forall. intros t. 
  apply (@is_Trunc_2 _ _ _ _ _ _ _ _).
Defined.

Definition UId_ {Γ} (A B: Typ Γ) (γ : [Γ]) : [Type0] :=
  (Equiv' (A @ γ) (B @ γ);  UId__ _ _ _).

Program Instance UId_1_fun_ {Γ} (A B: Typ Γ) (x y : [Γ]) (e: x ~1 y): 
  Functor (T:=[[ UId_ A B x]]) (U:=[[UId_ A B y]]) (λ X, (map B e ° X) ° (map A e) ^-1).
Next Obligation. apply equiv_eq_nat_trans. apply nat_comp'. apply identity.
                 apply nat_comp'. apply [X]. apply identity. Defined.
Next Obligation. simpl. red. simpl. intro. simpl. simpl_id_bi. Defined.
Next Obligation. simpl. red. simpl. intro. simpl. simpl_id_bi. 
                 apply inverse. apply (map_comp [map B e]). Defined.
Next Obligation. simpl. red. simpl. intro. simpl. simpl_id_bi. 
                 apply (map2 [map B e]). apply (X^-1 (adjoint (map A e) @ t)).
Defined.

Definition UId_1_fun {Γ} (A B: Typ Γ) (x y : [Γ]) (e: x ~1 y): UId_ A B x -S-> UId_ A B y :=
  (λ X, (map B e ° X) ° (map A e) ^-1; UId_1_fun_ A B x y e).

Program Instance UId_1_equiv_struct {Γ} (A B: Typ Γ) (x y : [Γ]) (e: x ~1 y): Iso_struct (UId_1_fun A B x y e).
Next Obligation. exact (UId_1_fun A B y x e^-1). Defined.
Next Obligation. simpl. red. 
                 match goal with | [ |- sigma (λ α : ?H, _)]
                                   => assert H end.
                 intro. apply equiv_eq_nat_trans. simpl. red. 
                 match goal with | [ |- sigma (λ α : ?H, _)]
                                   => assert H end.
                 intro. simpl.  
                 eapply composition. eapply (map [map B e]). apply (map_inv B).
                 eapply composition. apply (section (map B e)).
                 apply (map [t]). eapply composition. 
                 assert (adjoint (map A e ^-1) ~ [map A e]).
                 eapply composition. eapply Equiv_adjoint.
                 apply (map_inv A). apply (inv_inv _ _ _ (map A e)).
                 apply (X @ (adjoint (map A e) @ t0)). apply (section (map A e)).
                 exists X. red. intros. trunc1_eq.
                 exists X. red. intros. simpl. red. simpl. intro. simpl. trunc1_eq.
Defined.
Next Obligation. eapply composition. Focus 2. 
                 apply (UId_1_equiv_struct_obligation_2 A B y x e^-1).
                 apply nat_comp'. simpl. red. 
                 match goal with | [ |- sigma (λ α : ?H, _)]
                                   => assert H end.
                 intro. apply equiv_eq_nat_trans. simpl. red. 
                 match goal with | [ |- sigma (λ α : ?H, _)]
                                   => assert H end.
                 intro. simpl.  
                 assert (forall B: Typ Γ, map B e ~ map B (e ^-1) ^-1).
                 clear; intro. apply (map2 B). apply inverse. apply inv_inv.
                 eapply composition. apply X. apply (map [map B (e ^-1) ^-1]).
                 apply (map [t]). apply Equiv_adjoint. apply X.
                 exists X. red. intros. trunc1_eq.
                 exists X. red. intros. simpl. red. simpl. intro. simpl. trunc1_eq.
                 apply identity.
Defined.

Definition UId_1_equiv {Γ} (A B: Typ Γ) (x y : [Γ]) (e: x ~1 y): Equiv' (UId_ A B x) (UId_ A B y)
  := IsoToEquiv (_; UId_1_equiv_struct A B x y e).

Program Instance UId_1 {Γ} (A B: Typ Γ) : Functor (T := [[Γ]]) (U := Type0) (UId_ A B) 
  := {| _map := UId_1_equiv A B |}.
Next Obligation. apply equiv_eq_nat_trans.  
                 red. simpl. red.  
                 match goal with | [ |- sigma (λ α : ?H, _)]
                                   => assert H end.
                 intro. simpl. apply equiv_eq_nat_trans. red. red. 
                 match goal with | [ |- sigma (λ α : ?H, _)]
                                   => assert H end.
                 intro.  simpl. eapply composition. apply (map_id B).
                 apply (map [t]). eapply composition. eapply Equiv_adjoint. 
                 apply (map_id A). apply identity. 
                 exists X. red. intros. trunc1_eq.
                 exists X. red. intros. simpl. red. simpl. intro. simpl. trunc1_eq.
Defined. 
Next Obligation. apply equiv_eq_nat_trans.  
                 red. simpl. red.  
                 match goal with | [ |- sigma (λ α : ?H, _)]
                                   => assert H end.
                 intro. simpl. apply equiv_eq_nat_trans. red. red. 
                 match goal with | [ |- sigma (λ α : ?H, _)]
                                   => assert H end.
                 intro.  simpl. eapply composition. apply (map_comp B). simpl.
                 apply (map [map B e']). apply (map [map B e]). apply (map [t]).
                 eapply composition. eapply Equiv_adjoint. apply (map_comp A).
                 apply identity.
                 exists X. red. intros. trunc1_eq.
                 exists X. red. intros. simpl. red. simpl. intro. simpl. trunc1_eq.
Defined. 
Next Obligation. apply equiv_eq_nat_trans.  
                 red. simpl. red.  
                 match goal with | [ |- sigma (λ α : ?H, _)]
                                   => assert H end.
                 intro. simpl. apply equiv_eq_nat_trans. red. red. 
                 match goal with | [ |- sigma (λ α : ?H, _)]
                                   => assert H end.
                 intro. simpl. eapply composition. apply (map2 B X).
                 apply (map [map B e']). apply (map [t]). apply Equiv_adjoint. 
                 apply (map2 A X).
                 exists X0. red. intros. trunc1_eq.
                 exists X0. red. intros. simpl. red. simpl. intro. simpl. trunc1_eq.
Defined. 

Notation "P '@@@' A" := (AppF ↑P A) (at level 50).

Infix "~11" := (Equiv') (at level 50).

(* end hide *)
(** 
  ** Univalence
  %\label{sec:universe}% 
  To interpret the universe $\Univ$, we need to define its syntax and interpretation of syntax as setoids altogether. That is, $\Univ$ requires inductive-recursive definitions to be interpreted.
  As such definition are not available in %\Coq%, we cannot completely interpret $\Univ$%\footnote{The folklore coding trick to encode inductive-recursive definition using an indexed family as done in~\cite{altenkirch-mcbride-wierstra:ott-now} does not work here because it transforms an inductive-recursive Agda Set into a larger universe which is no longer a setoid.}%. Nevertheless, we present a way to interpret the identity type on $\Univ$ and Rule %\textsc{Id-Equiv-Intro}% which corresponds to the univalence axiom for $\Univ$.

   We interpret the identity type on $\Univ$ in the same way as [Id], except that it 
relates two dependent types [A] and [B] instead of terms of a dependent type.
*)

Definition UId {Γ} (A B: Typ Γ) : Typ Γ := (λ γ, (A @ γ ~11 B @ γ ; _); UId_1 A B). 

(**
 To define the notion of isomorphism, we need to define a proper notion of function (noted [A ----> B]) that does not use the restriction of [Prod] to constant type families. This is because the definition of an isomorphism involves two functions that have to be composed in both ways, which lead to universe inconsistency if we use dependent products to encode functions. We define the notion of application (noted [g @@@ f]) for this kind of functions. 
*)

Definition  _iso_section (Γ: Context) (A B : Typ Γ) (f : Elt (A ----> B)) (iso_adjoint : Elt (B ----> A)) := Elt (Prod (LamT (Id (iso_adjoint @@@ (f @@@ Var A)) (Var A)))).

Definition  _iso_retraction (Γ: Context) (A B : Typ Γ) (f : Elt (A ----> B)) (iso_adjoint : Elt (B ----> A)) := Elt (Prod (LamT (Id (f @@@ (iso_adjoint @@@ Var B)) (Var B)))).

Class iso_struct (Γ: Context) (A B : Typ Γ) (f : Elt (A ----> B)) := 
{ iso_adjoint : Elt (B ----> A)  ;
  iso_section : _iso_section f iso_adjoint;
  iso_retract : _iso_retraction f iso_adjoint}.

(* this one does not work ?? *) 

(* Class iso_struct (Γ: Context) (A B : Typ Γ) (f : Elt (A ----> B)) :=  *)
(* { iso_adjoint : Elt (B ----> A)  ; *)
(*   iso_section : Elt (Prod (LamT (Id (iso_adjoint @@@ (f @@@ Var A)) (Var A)))) ; *)
(*   iso_retract : Elt (Prod (LamT (Id (f @@@ (iso_adjoint @@@ Var B)) (Var B))))}. *)

Definition iso (Γ: Context) (A B : Typ Γ) := {f : Elt (A ----> B) & iso_struct f}.
(* begin hide *)

Infix "≡" := UId (at level 55).

Definition Equiv_Intro_ (Γ: Context) (A B : Typ Γ) (e : iso A B) 
           : ∀ γ : [Γ], A @ γ ~11 B @ γ.
Proof.
  intro. apply IsoToEquiv. exists ([e] @ γ). 
  apply (@Build_Iso_struct _ _ _ (@iso_adjoint _ _ _ _ e.2 @ γ)). 
  pose ([@iso_retract _ _ _ _ e.2 @ γ]). 
  simpl in *. exists p. red. intros. simpl.
  trunc1_eq.
  pose ([@iso_section _ _ _ _ e.2 @ γ]). 
  simpl in *. exists p. red. intros. 
  trunc1_eq.
Defined.

Program Instance Equiv_Intro_1 (Γ: Context) (A B : Typ Γ) (e : iso A B) : 
  DependentFunctor ([[[A ≡ B]]]) (Equiv_Intro_ e).
Next Obligation. apply equiv_eq_nat_trans. simpl. red. 
                 match goal with | [ |- sigma (λ α : ?H, _)]
                                   => assert H end.
                 intro. apply (Dmap [e]).
                 exists X. red. intros. trunc1_eq.
Defined.
Next Obligation. intro. simpl. trunc1_eq. Defined.
Next Obligation. intro. simpl. trunc1_eq. Defined.
Next Obligation. intro. simpl. trunc1_eq. Defined.

(* end hide *)

(**
  Then, we can show that this definition of isomorphism corresponds to equivalence of setoids.
  Again, the only extra work is with the management of context lifting. This provides a computational 
  content to the univalence axiom restricted to setoids.
*)

Definition Equiv_Intro (Γ: Context) (A B : Typ Γ) (e : iso A B) : Elt (A ≡ B).
Proof. exact (Equiv_Intro_ e; Equiv_Intro_1 _ _ _ e). Defined.

*)