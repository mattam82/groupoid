(** printing ~1 $\sim_1$ *)
(** printing ~11 $\sim_1$ *)
(** printing ~ $\sim_2$ *)
(** printing ~~ $\sim_1$ *)
(** printing ~2 $\sim_2$ *)
(** printing ⋅⋅ $⋅$ *)
(** printing ⋅⋅⋅ $⋅$ ⋅⋅*)
(** printing Π1 $\pi_1$*)
(** printing Π2 $\pi_2$*)
(** printing Πi $\pi_i$*)
(** printing --> $\longrightarrow$*)
(** printing ---> $\longrightarrow$*)
(** printing ----> $\longrightarrow_\Univ$*)
(** printing -|-> $\longrightarrow$*)
(** printing -||-> $\longrightarrow$*)
(** printing β $\beta$*)
(** printing χ $\chi$*)
(** printing γ $\gamma$*)
(** printing γt $\gamma t$*)
(** printing [! $\llbracket$*)
(** printing !] $\rrbracket$*)
(** printing |- $\vdash$*)
(** printing === $\equiv$*)
(** printing @ $\star$*)
(** printing @@ $\star$*)
(** printing @@@ $\star_\Univ$*)
(** printing ° $\circ$*)
(** printing °° $\circ$*)
(** printing °°° $\circ$*)
(** printing °°°° $\circ$*)
(** printing |g $|_g$*)
(** printing |0g $|_0$*)
(** printing [[ % %*)
(** printing ]] $_{\upharpoonright s}$*)
(** printing [[[ % %*)
(** printing ]]] $_{\upharpoonright s}$*)
(** printing Category_1 $\mathclass{PreCategory}_1$*)
(** printing Category_2 $\mathclass{PreCategory}_2$*)
(** printing CategoryP $\mathsf{PreCategory}$*)
(** printing CatType $\mathbf{UCat}$*)
(** printing Category $\mathsf{O-Category}$*)
(** printing GroupoidP $\mathsf{PreGroupoid}$*)
(** printing Groupoid $\mathsf{IsType_1}$*)
(** printing Setoid $\mathsf{IsType_0}$*)
(** printing Propoid $\mathsf{IsType_{-1}}$*)
(** printing UGroupoidType $\mathsf{Type_{1^+}}$*)
(** printing GroupoidType $\cst{Type_1}$*)
(** printing SetoidType $\mathsf{Type_0}$*)
(** printing PropoidType $\mathsf{Type_{-1}}$*)
(** printing Type0 $\mathsf{Type}_{0}^1$*)
(** printing _Type $\mathsf{Type}_{1^+}^{1^+}$*)
(** printing Groupoid_1 $\mathsf{Groupoid}_1$*)
(** printing Groupoid_2 $\mathsf{Groupoid}_2$*)
(** printing Equivalence_2 $\mathsf{Equivalence}_2$*)
(** printing Hom1 $\mathsf{Hom}_1$*)
(** printing Hom2 $\mathsf{Hom}_2$*)
(** printing Hom3 $\mathsf{Hom}_3$*)
(** printing _adjoint $\mathsf{adjoint}$*)
(** printing _section $\mathsf{section}$*)
(** printing _retraction $\mathsf{retraction}$*)
(** printing _triangle $\mathsf{triangle}$*)
(** printing nat_comp' $\mathsf{comp}$*)
(** printing _α_map $\mathsf{α}_\mathsf{map}$*)
(** printing _α_Dmap $\mathsf{α}_{\mathsf{map}^\Pi}$*)
(** printing α_map $\mathsf{α}_\mathsf{map}$*)
(** printing α_Dmap $\mathsf{α}_{\mathsf{map}^\Pi}$*)
(** printing _eq_gsection $\mathsf{eq\_section}$*)
(** printing _eq_retraction $\mathsf{eq\_retraction}$*)
(** printing Prod_Type $\Pi_\mathsf{T}$*)
(** printing _Prod $\Pi$*)
(** printing _Sum $\Sigma$*)
(** printing _Sum0 $\Sigma$*)
(** printing sum_type $\Sigma_\mathsf{T}$*)
(** printing sum_eq $\Sigma_\mathsf{Eq}$*)
(** printing sum_eq2 $\Sigma_{\mathsf{Eq}_2}$*)
(** printing eq2 $\mathsf{eq}_2$*)
(** printing eq1 $\mathsf{eq}_1$*)
(** printing HomT $\mathsf{HomSet}$*)
(** printing HomT2 $\mathsf{HomSet}_2$*)
(** printing HomT1 $\mathsf{HomSet}_1$*)
(** printing id_R $\mathsf{id}_R$*)
(** printing id_L $\mathsf{id}_L$*)
(** printing inv_R $\mathsf{inv}_R$*)
(** printing inv_L $\mathsf{inv}_L$*)
(** printing ^-1 $\hspace{-1ex}^{-1}$*)
(** printing Trunc_2 $\mathsf{Trunc}_2$*)
(** printing map_id $\mathsf{map}_\mathsf{id}$*)
(** printing map_comp $\mathsf{map}_\mathsf{comp}$*)
(** printing map2 $\mathsf{map}_2$*)
(** printing _map $\mathsf{map}$*)
(** printing _map_id $\mathsf{map}_\mathsf{id}$*)
(** printing _map_comp $\mathsf{map}_\mathsf{comp}$*)
(** printing _map2 $\mathsf{map}_2$*)
(** printing map1 $\mathsf{map}_1$*)
(** printing Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing _Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing Dmap_id $\mathsf{map}^\Pi_\mathsf{id}$*)
(** printing Dmap_comp $\mathsf{map}^\Pi_\mathsf{comp}$*)
(** printing Dmap2 $\mathsf{map}^\Pi_2$*)
(** printing _Dmap_id $\mathsf{map}^\Pi_\mathsf{id}$*)
(** printing _Dmap_comp $\mathsf{map}^\Pi_\mathsf{comp}$*)
(** printing _Dmap2 $\mathsf{map}^\Pi_2$*)
(** printing Dmap1 $\mathsf{map}^\Pi_1$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DNaturalTransformation $\mathsf{NaturalTransformation}^\Pi$*)
(** printing Dnat_trans $\mathsf{nat\_trans}^\Pi$*)
(** printing Dmodification $\mathsf{modification}^\Pi$*)
(** printing sum_weakgroupoid $\Sigma_\mathsf{WG}$*)
(** printing prod_weakgroupoid $\Pi_\mathsf{WG}$*)
(** printing IrrRelGroupoid $\mathsf{IrrRelWG}$*)
(** printing Hom_irr $\mathsf{HomIrr}$*)
(** printing ↑ $\shortuparrow$*)
(** printing ⇑ $\shortuparrow$*)
(** printing ⇑⇑ $\shortuparrow$*)
(** printing LamT_1 $\mathsf{\Lambda_{comp}}$*)
(** printing LamT $\Lambda$*)
(** printing TypFam_1 $\mathsf{TypFam_{comp}}$*)
(** printing Sub_1 $\mathsf{Sub_{comp}}$*)
(** printing SubExt_1 $\mathsf{SubExt_{comp}}$*)
(** printing substF_1 $\mathsf{substF_{comp}}$*)
(** printing Var_1 $\mathsf{Var_{comp}}$*)
(** printing Prod_1 $\mathsf{Prod_{comp}}$*)
(** printing Lam_2 $\mathsf{Lam_{comp}}$*)
(** printing App_1 $\mathsf{App_{comp}}$*)
(** printing Sub_1 $\mathsf{Sub_{comp}}$*)
(** printing Pair_1 $\mathsf{Pair_{comp}}$*)
(** printing Proj1_1 $\mathsf{Proj1_{comp}}$*)
(** printing Proj2_1 $\mathsf{Proj2_{comp}}$*)
(** printing BetaT_1 $\mathsf{BetaT_{comp}}$*)
(** printing Sigma_1 $\mathsf{Sigma_{comp}}$*)
(** printing transport_id $\mathsf{transport_{id}}$*)
(** printing transport_eq $\mathsf{transport_{eq}}$*)
(** printing transport_map $\mathsf{transport_{map}}$*)
(** printing transport_comp $\mathsf{transport_{comp}}$*)
(** printing transport $\mathsf{transport}$*)
(** printing _Prod $\Pi$*)
(** printing Prod0 $\Pi_0$*)
(** printing prod_comp $\mathsf{\Pi_{comp}}$*)
(** printing prod_comp' $\mathsf{\Pi_{comp}}$*)
(** printing J_1 $\mathsf{J_{comp}}$*)
(** printing Id_1 $\mathsf{Id_{comp}}$*)
(** printing Refl_1 $\mathsf{Refl_{comp}}$*)
(** printing UId_1 $\mathsf{≡_{comp}}$*)
(** printing Equiv_Intro_1 $\mathsf{Equiv\_Intro_{comp}}$*)
(** printing Equiv_Elim_1 $\mathsf{Equiv\_Elim_{comp}}$*)
(** printing UId $≡$*)
(** printing UType $\Univ$*)
(** printing Elt $\mathsf{Tm}$*)
(* begin hide *)

Require Export Unicode.Utf8_core.
Require Import Coq.Program.Tactics.

Add LoadPath "." as Groupoid.

Require Import HoTT_light.
Require Import groupoid.
Require Import fun_eq.

Set Implicit Arguments.
Set Universe Polymorphism.
(* Set Program Mode. *)
 
Opaque Equiv_adjoint.
Opaque map_inv.

(* end hide *)
(** 

  We now organize our formalization of groupoids into a model of the dependent 
  type theory with univalence introduced in Section%\ref{sec:definitions}%.
  The interpretation is based on the notion of categories with families 
  introduced by Dybjer%~\cite{dybjer:internaltt}% later used in %\cite{groupoid-interp}%.
  This interpretation can also be seen as an extension of the Takeuti-Gandy interpretation of simple type theory, recently generalized to dependent type theory by Coquand et al. using Kan semisimplicial sets or cubical sets%~\cite{barras:_gener_takeut_gandy_inter}%. 

  There are two main novelties in our interpretation. First, we
  take advantage of universe polymorphism to interpret dependent types
  directly as functors into [Type0]. Second, we provide an
  interpretation in a model where structures that are definitionally
  equal for Kan semisimplicial sets are only homotopically equal, which
  requires more care in the definitions (see for instance the definition
  of [Lam] in Section %\ref{sec:interp}% which mixes two points of view
  on fibrations).

  We only present the computational part of the interpretation, the
  proofs of functoriality and naturality are not detailled but most of
  them are available in the %\Coq% development. We have admitted some of
  these administrative compatibility lemmas.


  ** Dependent types

  The judgment context $\Gamma \vdash$ of Section
  %\ref{sec:definitions}% is represented in %\Coq% as a groupoid, noted
  [Context := GroupoidType]. The empty context (Rule %\textsc{Empty}%)
  is interpreted as the groupoid with exactly one element at each
  dimension.  Types in a context [Γ], noted [Typ Γ], are (context)
  functors from [Γ] to the groupoid of setoids [Type0].  Thus, a
  judgment $\Gamma \vdash A : \Type{}$ is represented as a term [A] of
  type [Typ Γ]. Context extension (Rule %\textsc{Decl}%) is given by
  dependent sums, i.e., the judgment $\Gamma, x:A \vdash$ is represented
  as [_Sum A].

*)
(* begin hide *)

(* Infix "--->" := Fun_Type_Groupoid (at level 55).  *)

Infix "--->" := Fun_Type (at level 55). 

Unset Implicit Arguments.

Definition Hom_irr (T : Type) : HomT T := λ _ _, unit.

Set Implicit Arguments.

Definition _Hom_irr T (Hom : HomT1 T) : HomT2 eq1 := {| eq2 := fun x y => Hom_irr _ |}.

Obligation Tactic := intros; try (constructor; intros; exact tt).

Definition IrrRelEquiv T : Equivalence (Hom_irr T).
  econstructor; econstructor; firstorder. Defined.

Program Definition IrrRelCat {T} {Hom : HomT1 T} (id : Identity eq1) (comp : Composition eq1): 
  CategoryP T := {| Hom2 := @_Hom_irr T Hom |}.
Next Obligation. simpl. apply IrrRelEquiv. Defined.
  
Program Definition IrrRelGrp {T} {Hom : HomT1 T} (id : Identity eq1) (comp : Composition eq1) (inv : Inverse eq1): GroupoidP T := {| C := IrrRelCat id comp|}.

Definition IrrRelId T (Hom : HomT1 T) (x y : T) : Identity (Hom_irr (x ~1 y)).
  econstructor; econstructor; firstorder. Defined.

Definition IrrRelComp T (Hom : HomT1 T) (x y : T) : Composition (Hom_irr (x ~1 y)).
  econstructor; econstructor; firstorder. Defined.

Definition IrrRelInverse T (Hom : HomT T) (x y : T) : Inverse (Hom_irr (Hom x y)).
  econstructor; econstructor; firstorder. Defined.

Definition IrrRelEq T (Hom : HomT T) (x y : T) : Equivalence (Hom_irr (Hom x y)). 
  econstructor; econstructor; firstorder. Defined.

Program Definition IrrRelGroupoid T (Hom : HomT1 T) (id : Identity eq1) (comp : Composition eq1) (inv : Inverse eq1) : Groupoid T := 
  {| G := IrrRelGrp id comp inv|}.
Next Obligation.
  unfold IrrRelGrp in E, E'. simpl in E, E'. red in E, E'. 
  destruct E, E'. apply contr_paths_contr. apply contr_unit.
Defined.

Arguments IrrRelGroupoid {T} Hom {id comp inv}.

Program Instance prop_WG (T : PropoidType) : Groupoid [T] := 
  @IrrRelGroupoid T.1 {| eq1 := Hom_irr T.1|} _ _ _.

Program Instance prop_setoid (T : PropoidType) : Setoid [T].

Definition eq_Prop (P Q : PropoidType) := prod (P.1 -> Q.1) (Q.1 -> P.1).

Infix "<->" := eq_Prop.

(** Equality between propositions of type [Propoids] is given by
logical equivalence on the underlying propositions, i.e., propositional
extensionality. This is a degenerate case of univalence, where the
proofs that the two maps form an isomorphism is trivial due to
the above definition of equality of witnesses: they are all equal.  *)
  
Program Instance Prop_id : Identity eq_Prop. 
Next Obligation. firstorder. Defined.

Program Instance Prop_inv : Inverse eq_Prop.
Next Obligation. firstorder. Defined.

Program Instance Prop_comp : Composition eq_Prop.
Next Obligation. firstorder. Defined.

Program Instance Prop_equiv : Equivalence eq_Prop. 

Program Definition _Prop : SetoidType := 
  (PropoidType; {| S := IrrRelGroupoid {| eq1 := (λ P Q, P <-> Q) |} |}).
Next Obligation. apply (@contr_equiv _ _ _ isequiv_path_prod).
                 apply contr_prod.
                 apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ _ _))).
                 apply contr_forall. intros t. apply is_Trunc_0.
                 apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ _ _))).
                 apply contr_forall. intros t. apply is_Trunc_0.
Defined.

Next Obligation. exact (@contr_paths_contr _ contr_unit e e'). Defined.

Obligation Tactic := simpl; intros.


Definition Context := [Type0].

Program Definition setoid_unit : Setoid unit :=
 {| S := @IrrRelGroupoid unit {| eq1 := Hom_irr unit |} _ _ _|}.
Next Obligation. econstructor. firstorder. Defined.
Next Obligation. econstructor. firstorder. Defined.
Next Obligation. econstructor. firstorder. Defined.
Next Obligation. exact (@contr_paths_contr _ contr_unit e e'). Defined.

Definition Empty : SetoidType := Build_sigma (fun T : Type => Setoid T) unit setoid_unit.

(* Definition UTyp (Γ:Context) := [ |Γ|g --> Type1]. *)

Definition Typ (Γ:Context) := [ [[Γ]] --> Type0].

(* Definition UElt (Γ: Context) (A:UTyp Γ) := [Prod1 A]. *)

Definition Elt (Γ:Context) (A:Typ Γ) := [Prod0 A].

Definition TypDep {Γ : Context} (A: Typ Γ) := Typ (_Sum0 A).

(* end hide *)
(** Terms of [A] introduced by a sequent $\Gamma \vdash x:A$ are
  dependent (context) functors from [Γ] to [A] that return for each
  context valuation [γ], an object of [A @ γ] respecting equality of
  contexts.  The type of terms of [A] is noted [Elt A := [_Prod A]]
  (context is implicit).  *)
(**
  A dependent type $\Gamma, x:A \vdash B$ is interpreted in two
  equivalent ways: simply as a type [TypDep A := Typ (_Sum A)] over the
  dependent sum of [Γ] and [A] or as a type family [TypFam A] over [A]
  (corresponding to a family of sets in constructive mathematics). A
  type family can be seen as a fibration (or bundle) from [B] to [A].
  In what follows, the indice $\mathsf{_{comp}}$ is given to proofs of 
  (dependent) functoriality.
*)
(* begin hide *)

(* Program Instance _Fun_Groupoid T U : Groupoid (T -S-> U). *)
(* Next Obligation. apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ _ _))). *)
(*                  apply contr_forall. intros z. *)
(*                  apply is_Trunc_2. *)
(* Defined. *)

(* Definition Fun_GroupoidS T U := (T -S-> U; _Fun_Groupoid T U) : GroupoidType. *)

Instance FunTypeHomS : HomT1 [Type0] := {eq1 := Fun_Type_Setoid}.

Instance nat_transHomS' : HomT2 Fun_Type_Setoid := {eq2 := nat_trans}.

Program Instance category_funS : CategoryP [Type0].
Next Obligation. econstructor. intro. apply id_fun. Defined.
Next Obligation. econstructor. intros. eapply comp_fun; eauto. Defined.
Next Obligation.
Proof.
  exists (λ t , identity (f @ t)). intros t t' e. simpl.
  eapply composition. apply id_L. eapply inverse. apply id_R.
Defined.
Next Obligation.
Proof.
  exists (λ t , identity _). intros t t' e.
  eapply composition. apply id_L. eapply inverse. apply id_R.
Defined.
Next Obligation.
Proof.
  exists (λ t , identity _).  intros t t' e.
  eapply composition. apply id_L. eapply inverse. apply id_R.
Defined.
Next Obligation.
Proof.
  exists (λ t , map g' (X @ t) ° (X0 @ (f @ t))). intros t t' e.
  eapply composition. apply assoc.
  eapply composition. apply comp. apply (α_map X0). apply identity.
  eapply composition. eapply inverse. apply assoc. eapply inverse.
  eapply composition. eapply inverse. apply assoc.
  apply comp. apply identity. eapply composition.
  Focus 2. eapply composition. Focus 2. apply (map_comp g').
  eapply (map2 g'). eapply inverse. apply (α_map X).
  eapply inverse. simpl. apply (map_comp g').
Defined.

Notation "[[ x ']]'" := (SetoidTypeToGroupoidType x) (at level 50).

(* Instance TypFam_1 {Γ : Context} (A: Typ Γ) : Functor (T := [[Γ]]) (U:=_Type) (λ s : [Γ], [[A @ s]] -||-> Type0) *)
(* := *)
(*   {| _map := λ (x y : [Γ]) (X : x ~1 y), fun_eqT (map A X) (identity (|Type0|g)) ;  *)
(*      _map_id := fun X => (fun_eq_id' A X ; AllEquivEq _) ; *)
(*      _map_comp := fun x y z e e' => (fun_eq_map' A x y z e e'; *)
(*                                      AllEquivEq _); *)
(*      _map2 := fun _ _ _ _ X => (fun_eq_eq (map2 A X) (identity (identity (|Type0|g))); *)
(*          AllEquivEq _) *)
(*   |}. *)

(* (* why do we need to the lemma heren the one in fun_eq does not apply ...*) *)
Instance TypFam_1 {Γ : Context} (A: Typ Γ) : Functor (T := [[Γ]]) (U:=_Type) (λ s : [Γ], [[A @ s]] -||-> Type0)
:= @Build_Functor ([[Γ]]) (_Type) (λ s : [Γ], [[A @ s]] -||-> Type0)
  (fun H H0 X => (fun_eqT (map A X) (identity Type0) : ([[A @ H]] -||-> Type0) ~1
                                                                               ([[A @ H0]] -||-> Type0)))
  (fun X => (@fun_eq_id' Γ A X ; AllEquivEq _ _ _))
  (fun x y z e e' => (fun_eq_map' A x y z e e';
                      AllEquivEq _ _ _))
  (fun x y e e' X => (fun_eq_eq (map2 A X) (identity (identity  (|Type0|g)));
         AllEquivEq _ _ _)).
(* >>>>>>> FETCH_HEAD *)

Class Action {T} (homAc : T -> Type) :=
{  AC :> CategoryP T;
   eqAc : ∀ {x}, HomT (homAc x);
   action : ∀ {x y : T}, (x ~1 y) -> (homAc y) -> (homAc x) ;
   idAc : ∀ {x} (f : homAc x), eqAc (action (identity x) f) f ;
   assocAc : ∀ {x y z} (σ: x ~1 y) (τ: y ~1 z) (f: homAc z),
            eqAc (action (τ ° σ) f) (action σ (action τ f))
}.

Notation  "f '⋅' σ" := (action σ f) (at level 50).

Program Instance ActionType : Action (T:=Context) (fun Γ => Typ Γ) :=
  {| AC := category_funS ; eqAc := λ T, nat_trans (U:=Type0) ;
     action := λ T U (σ: [T -|-> U]) (f : [ [[U]] --> Type0]), (λ x, f @ (σ @ x) ; arrow_comp _ _ _ _ _) |}.

Next Obligation.
Proof. 
  exists (λ t , identity _). intros t t' e.
  eapply composition. apply equiv_id_L. eapply inverse. refine (equiv_id_R _ _ _). Defined.

Next Obligation. 
  exists (λ t , identity _).  intros t t' e.
  eapply composition. refine (equiv_id_L _ _ _). 
  eapply inverse. refine (equiv_id_R _ _ _).
Defined.

Program Instance ActionType2 : Action (T:=Context) (fun T => [ [[T]] --> _Type]) :=
  {| AC := category_funS ; eqAc := λ T, nat_trans (U:=_Type) ;
     action := λ T U (σ: [T -|-> U]) (f : [ [[U]] --> _Type]), 
               (λ x, f @ (σ @ x) ; arrow_comp _ _ _ _ _) |}.

Next Obligation. 
Proof.
  exists (λ t , identity _). intros t t' e.
  eapply composition. apply equiv_id_L. eapply inverse. refine (equiv_id_R _ _ _).
Defined.

Next Obligation. 
Proof.
  exists (λ t , identity _).  intros t t' e.
  eapply composition. refine (equiv_id_L _ _ _). eapply inverse. 
  refine (equiv_id_R _ _ _).
Defined.

(* end hide *)

Definition TypFam {Γ : Context} (A: Typ Γ) := 
  [_Prod (λ γ, [[ (A @ γ) ]] -||-> Type0; TypFam_1 _)]. 
