(** printing ~1 $\sim_1$ *)
(** printing ~ $\sim_2$ *)
(** printing ~2 $\sim_2$ *)
(** printing Π1 $\pi_1$*)
(** printing Π2 $\pi_2$*)
(** printing Πi $\pi_i$*)
(** printing --> $\longrightarrow$*)
(** printing ---> $\longrightarrow$*)
(** printing -|-> $\longrightarrow$*)
(** printing -||-> $\longrightarrow$*)
(** printing β $\beta$*)
(** printing χ $\chi$*)
(** printing γ $\gamma$*)
(** printing γt $\gamma t$*)
(** printing [! $\llbracket$*)
(** printing !] $\rrbracket$*)
(** printing |- $\vdash$*)
(** printing === $\equiv$*)
(** printing @ $\star$*)
(** printing ° $\circ$*)
(** printing °' $\circ$*)
(** printing |g $|_g$*)
(** printing |0g $|_0$*)
(** printing [[ % %*)
(** printing ]] $_{\upharpoonright s}$*)
(** printing [[[ % %*)
(** printing ]]] $_{\upharpoonright s}$*)
(** printing Category_1 $\mathclass{PreCategory}_1$*)
(** printing Category_2 $\mathclass{PreCategory}_2$*)
(** printing CategoryP $\mathsf{PreCategory}$*)
(** printing CatType $\mathbf{UCat}$*)
(** printing Category $\mathsf{O-Category}$*)
(** printing GroupoidP $\mathsf{PreGroupoid}$*)
(** printing Groupoid $\mathsf{IsType_1}$*)
(** printing Setoid $\mathsf{IsType_0}$*)
(** printing Propoid $\mathsf{IsType_{-1}}$*)
(** printing UGroupoidType $\mathsf{Type_{1}}$*)
(** printing GroupoidType $\mathsf{Type_1}$*)
(** printing SetoidType $\mathsf{Type_0}$*)
(** printing PropoidType $\mathsf{Type_{-1}}$*)
(** printing Type0 $\mathsf{Type}_{0}^1$*)
(** printing _Type $\mathsf{Type}_{1}^{1}$*)
(** printing Groupoid_1 $\mathsf{Groupoid}_1$*)
(** printing Groupoid_2 $\mathsf{Groupoid}_2$*)
(** printing Equivalence_2 $\mathsf{Equivalence}_2$*)
(** printing Hom1 $\mathsf{Hom}_1$*)
(** printing Hom2 $\mathsf{Hom}_2$*)
(** printing Hom3 $\mathsf{Hom}_3$*)
(** printing _adjoint $\coqdoccst{adjoint}$*)
(** printing _section $\coqdoccst{section}$*)
(** printing _retraction $\coqdoccst{retraction}$*)
(** printing _triangle $\coqdoccst{triangle}$*)
(** printing nat_comp' $\coqdoccst{comp}$*)
(** printing _α_map $\coqdoccst{α}_\mathsf{map}$*)
(** printing _α_Dmap $\coqdoccst{α}_{\mathsf{map}^\Pi}$*)
(** printing α_map $\coqdoccst{α}_\mathsf{map}$*)
(** printing α_Dmap $\coqdoccst{α}_{\mathsf{map}^\Pi}$*)
(** printing _eq_gsection $\coqdoccst{eq\_section}$*)
(** printing _eq_retraction $\coqdoccst{eq\_retraction}$*)
(** printing Prod_Type $\Pi_\coqdoccst{T}$*)
(** printing _Prod $\Pi$*)
(** printing Prod0 $\Pi_0$*)
(** printing _Sum $\Sigma$*)
(** printing _Sum0 $\Sigma$*)
(** printing Sum0 $\Sigma_0$*)
(** printing sum_type $\Sigma_\coqdoccst{T}$*)
(** printing sum_eq $\Sigma_\coqdoccst{Eq}$*)
(** printing sum_eq2 $\Sigma_{\coqdoccst{Eq}_2}$*)
(** printing eq2 $\coqdoccst{eq}_2$*)
(** printing eq1 $\coqdoccst{eq}_1$*)
(** printing HomT $\mathsf{HomSet}$*)
(** printing HomT2 $\mathsf{HomSet}_2$*)
(** printing HomT1 $\mathsf{HomSet}_1$*)
(** printing id_R $\coqdoccst{id}_R$*)
(** printing id_L $\coqdoccst{id}_L$*)
(** printing inv_R $\coqdoccst{inv}_R$*)
(** printing inv_L $\coqdoccst{inv}_L$*)
(** printing ^-1 $\hspace{-1ex}^{-1}$*)
(** printing Trunc_2 $\coqdoccst{Trunc}_2$*)
(** printing map_id $\coqdoccst{map}_\coqdoccst{id}$*)
(** printing map_comp $\coqdoccst{map}_\coqdoccst{comp}$*)
(** printing map2 $\coqdoccst{map}_2$*)
(** printing _map $\coqdoccst{map}$*)
(** printing _map_id $\coqdoccst{map}_\coqdoccst{id}$*)
(** printing _map_comp $\coqdoccst{map}_\coqdoccst{comp}$*)
(** printing _map2 $\coqdoccst{map}_2$*)
(** printing map1 $\coqdoccst{map}_1$*)
(** printing Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing _Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing Dmap_id $\coqdoccst{map}^\Pi_\mathsf{id}$*)
(** printing Dmap_comp $\coqdoccst{map}^\Pi_\mathsf{comp}$*)
(** printing Dmap2 $\coqdoccst{map}^\Pi_2$*)
(** printing _Dmap_id $\coqdoccst{map}^\Pi_\mathsf{id}$*)
(** printing _Dmap_comp $\coqdoccst{map}^\Pi_\mathsf{comp}$*)
(** printing _Dmap2 $\coqdoccst{map}^\Pi_2$*)
(** printing Dmap1 $\coqdoccst{map}^\Pi_1$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DNaturalTransformation $\mathsf{NaturalTrans}^\Pi$*)
(** printing NaturalTransformation $\mathsf{NaturalTrans}$*)
(** printing Dnat_trans $\mathsf{nat\_trans}^\Pi$*)
(** printing Dmodification $\mathsf{modification}^\Pi$*)
(** printing sum_weakgroupoid $\Sigma_\mathsf{WG}$*)
(** printing prod_weakgroupoid $\Pi_\mathsf{WG}$*)
(** printing IrrRelGroupoid $\coqdoccst{IrrRelWG}$*)
(** printing Hom_irr $\coqdoccst{HomIrr}$*)
(** printing ↑ $\shortuparrow$*)
(** printing Equiv_Groupoid $\mathsf{Equiv_{Type_0}}$*)
(** printing Prod_Groupoid $\mathsf{Prod_{Type_0}}$*)
(** printing transport_id $\mathsf{transport_{id}}$*)
(** printing transport_eq $\mathsf{transport_{eq}}$*)
(** printing transport_map $\mathsf{transport_{map}}$*)
(** printing transport_comp $\mathsf{transport_{comp}}$*)
(** printing nat_trans_grp $\mathsf{fun_{grp}}$*)
(* begin hide *)

Require Export Unicode.Utf8_core.
Require Import Coq.Program.Tactics.
Require Import Groupoid.HoTT_light.

Set Universe Polymorphism.
Set Program Mode.
Set Primitive Projections.
Set Standard Proposition Elimination Names.

Set Implicit Arguments.

Notation " { x : T & P } " := (sigma (fun x : T => P)).

Notation "x .1" := (proj1 x) (at level 3).
Notation "x .2" := (proj2 x) (at level 3).

Notation " ( x ; p ) " := (@Build_sigma _ _ x p).

Notation Π1 := proj1.
Notation Π2 := proj2.
Notation "[ T ]" := T.1.

Definition id {A} (a : A) := a.

(* end hide *)
(**
  This section presents our formalization of groupoids in %\Coq% with
  universe polymorphism. 
  We first explain our overloaded management of
  equalities and introduce type classes for groupoids and their
  associated structures, i.e., functors, natural transformations and
  homotopy equivalences
  (%\S\ref{sec:w2gpds}-\ref{sec:homequiv}%).
  Natural transformations give access to a homotopic form of
  functional extensionality, while homotopy equivalences provide
  extensionality at the level of 0-types.  Polymorphic universes are
  needed to state that setoids and homotopy equivalences form a
  groupoid.  Homotopic equivalences directly provide access to a
  rewriting mechanism on types (%\S\ref{sec:rew}%). This rewriting is
  used to extend functors and products to dependent functors and
  dependent sums (%\S\ref{sec:depprod}-\ref{sec:sigma}%).
 %\subsection{Notations} \input{../theories/notations}%
*)


(** ** Definition of groupoids %\label{sec:w2gpds}% 

We formalize groupoids using type classes.  Contrarily to what is done
in the setoid translation, the basic notion of a morphism is an
inhabitant of a relation in [Type] (i.e., a proof-relevant relation): *)

Definition HomT (T : Type) := T -> T -> Type.

(**
  %\noindent%
  Given [x] and [y] in [T], [HomT T x y] is the type of morphism from [x] to [y]. 
  To manipulate different [HomT]'s at dimension 1 and 2 more abstractly, we use ad-hoc 
  polymorphism and introduce type classes [HomT1] and [HomT2] with according notations. 
*)

Class HomT1 T := {eq1 : HomT T}.
Infix "~1" := eq1 (at level 80).

Class HomT2 {T} (Hom : HomT T) := {eq2 : ∀ {x y : T}, HomT (Hom x y)}.
Infix "~2" := eq2 (at level 80).

(* begin hide *)
Infix "~" := eq2 (at level 80). 
(* end hide *)

(** Given a [HomT], we define type classes: [Identity] that gives the
  identity morphism, [Inverse] which corresponds to the existence of an
  inverse morphism for every morphism (noted [f ^-1]) and [Composition]
  which corresponds to morphism composition (noted [g ° f]). Those three
  properties are gathered by the type class [Equivalence].*)
(* begin hide *)

Class Identity {A} (Hom : HomT A) :=
  { identity : ∀ x, Hom x x }.

Class Inverse {A} (Hom : HomT A) :=
  { inverse : ∀ {x y:A}, Hom x y -> Hom y x }.

Class Composition {A} (Hom : HomT A) :=
  { composition : ∀ {x y z:A}, Hom x y -> Hom y z -> Hom x z }.

Notation  "g ° f" := (composition f g) (at level 50). 
Notation  "f ^-1" := (inverse f) (at level 3). 

(* end hide *)
(* begin hide *)
Class Equivalence {T} (Eq : HomT T):= {
  Equivalence_Identity :> Identity Eq ;
  Equivalence_Inverse :> Inverse Eq ;
  Equivalence_Composition :> Composition Eq 
}.
(* end hide *)
(**
  A [CategoryP] is defined as a category
  where coherences are given up-to an equivalence relation denoted by
  [~2].  Ordinary categories are derived with the additional requirement
  that higher equalities are trivial, which can be expressed using
  identity types (see the definition of [Groupoid]).  

  We do not put this condition into the basic definition because
categories and functors form a pre-category but not a 1-category. Thus,
working with pre-categories and pre-groupoids allows to share more
structure and is closer to the ω-groupoid model which is itself enriched.
*)

Class Category T := { Hom1 :> HomT1 T; Hom2 :> HomT2 eq1;
     Id :> Identity eq1; Comp :> Composition eq1;
     Equivalence_2 :> ∀ x y, (Equivalence (eq2 (x:=x) (y:=y)));
     id_R : ∀ x y (f : x ~1 y), f ° identity x ~ f ;
     id_L : ∀ x y (f : x ~1 y), identity y ° f ~ f ;
     assoc : ∀ x y z w (f: x ~1 y) (g: y ~1 z) (h: z ~1 w),
              (h ° g) ° f ~ h ° (g ° f);
     comp : ∀ x y z (f f': x ~1 y) (g g': y ~1 z), 
              f ~ f' -> g ~ g' -> g ° f ~ g' ° f' }.

(**
  In homotopy type theory, coherences are expressed using identity types, with a further requirement that the internal notion of equality induced by the category (isomorphism between two objects) coincides with its identity type.  
  We do not share this point of view because our goal is to restrict the use of identity types to the treatment of contractedness for higher cells. 
  Note that the [comp] law is not present in traditional definition of categories 
  because it is automatically satisfied for the identity type.
*)
(* begin hide *)

Definition CatType := {T:Type & Category T}.

Hint Extern 1 (@Equivalence (@eq1 (@Hom1 ?T) ?x ?y) eq2) => 
  apply (@Equivalence_2 T x y) : typeclass_instances.
(* Hint Extern 1 (@CategoryP (proj1 ?T) (@Hom1 ?T) _) => apply (@Category_1 (proj2 T)) : typeclass_instances. *)
Hint Extern 1 (@HomT2 _ (@eq1 (@Hom1 ?T))) => apply (@Hom2 T) : typeclass_instances.
(* Hint Extern 1 (Category [?T]) => apply (proj2 T) : typeclass_instances. *)

(* end hide *)
(** 
 A [GroupoidP] is a [CategoryP] where all 1-Homs are invertible
 and subject to additional compatibility laws for inverses.
*)

Class Groupoid T := { C :> Category T ;  Inv :> Inverse eq1 ;
     inv_R : ∀ x y (f: x ~1 y), f ° f ^-1 ~ identity y ;
     inv_L : ∀ x y (f: x ~1 y), f ^-1 ° f ~ identity x ;
     inv :   ∀ x y (f f': x ~1 y), f ~ f' -> f ^-1 ~ f' ^-1}.

(* begin hide *)

(* Hint Extern 1 (@Equivalence (@eq1 (@Hom1 ?T) ?x ?y) eq2) =>  *)
(*   apply (@Equivalence_2 T x y) : typeclass_instances. *)
(* Hint Extern 1 (@HomT2 _ (@eq1 (@Hom1 ?T))) => apply (@Hom2 T) : typeclass_instances. *)

Hint Extern 1 (Groupoid [?T]) => apply (proj2 T) : typeclass_instances.

Definition assoc' {T} {Hom1: HomT1 T} {Hom2: HomT2 eq1} {Category} {x y z w: T} :=
  assoc (Category := Category) x y z w.

Definition id_L' {T} {Hom1: HomT1 T} {Hom2: HomT2 eq1} {Category} {x y: T} := 
  id_L (Category := Category) x y .

Definition id_R' {T} {Hom1: HomT1 T} {Hom2: HomT2 eq1} {Category} {x y: T} := 
  id_R (Category := Category) x y .

Definition HorComp {T} 
           {Category_1 : Category T} {x y z}
           {f f' : x ~1 y} {g g' : y ~1 z} :
  f ~2 f' -> g ~2 g' -> g ° f ~2 g' ° f' :=
  comp _ _ _ f f' g g'.

Infix "**" := HorComp (at level 50).

(* We note [UGroupoidType] for the types that form a [GroupoidP].  *)
(* The subscript $1^+$ comes from the homotopical notion of truncated types.  *)
(* A pre-groupoid is at a truncated level of at least $1$. *)

(* end hide*)
(**
   Groupoids are then pre-groupoids where equality at
   dimension 2 is irrelevant. This irrelevance is defined using the usual
   notion of contractibility expressed with (relevant) identity types 
   (see %\cite{hottbook}% for details).  *)

(* begin hide *)
(* Require Import HoTT_light. *)
(* end hide *)
(** This is a way to require that all higher-cells are trivial. In our setting, we do not have the possibility to say that all 2-cells are related by a 3-cell, and so on. The price to pay will be explicit reasoning on identity types when proving for instance contractedness for the function space. In that case, we need the axiom of functional extensionality.
By analogy to homotopy type theory, we note [Groupoid] the property of being a groupoid. 
*)

(* Class Groupoid T := { G :> GroupoidP T ; *)
(*   is_Trunc_2 : ∀ (x y : T) (e e' : x ~1 y) (E E' : e ~2 e'), Contr (E = E')}. *)

(** %\noindent% 
    In the same way, we define [Setoid] when equality is irrelevant at dimension 1.
*)

Class Setoid T := { S :> Groupoid T ; 
  is_Trunc_1 : ∀ (x y : T) (e e' : x ~1 y) , e ~2 e'}.

(* begin hide *)


(* end hide *)
(**    We note [GroupoidType] for the types that form a [Groupoid].
       The subscript $1$ comes from the fact that groupoids are 1-truncated types
       in homotopy type theory. In the same way,  
       we note [SetoidType] 
       for the types that form a [Setoid].
       We define [ [[T]] ] the lifting of setoids (inhabitants of [SetoidType]) to groupoids.
*)
(* begin hide *)

Definition GroupoidType := {T: Type & Groupoid T}.

(* Definition UGroupoidType := {T: Type & GroupoidP T}. *)

Definition SetoidType := sigma Setoid.


Hint Extern 0 (Setoid [?T]) => apply T.2 : typeclass_instances.
Hint Extern 0 (Groupoid [?T]) => apply T.2 : typeclass_instances.
Hint Extern 0 (Category [?T]) => apply T.2 : typeclass_instances.
(* Hint Extern 0 (GroupoidP [?T]) => apply T.2 : typeclass_instances. *)
(* Hint Extern 0 (Propoid [?T]) => apply T.2 : typeclass_instances. *)
Hint Extern 1 (Groupoid [?T]) => apply T.(proj2).(S) : typeclass_instances.
(* Hint Extern 1 (Setoid [?T]) => apply T.(proj2).(P) : typeclass_instances. *)

(* Instance eq_pi1 (T : SetoidType) : Setoid [T] := T.2. *)
(* Instance eq_pi1' (T : GroupoidType) : Groupoid [T] := T.2. *)
(* Instance eq_pi1'' (T : CatType) : CategoryP [T] := T.2. *)
(* Instance eq_pi1''' (T : UGroupoidType) : GroupoidP [T] := T.2. *)

(* Instance eq_pi_prop (T : PropoidType) : Propoid [T] := T.2. *)

(* Instance eq_SWG (T : SetoidType) : Groupoid [T] := T.2.(S). *)

(* Instance eq_PWG (T : PropoidType) : Setoid [T] := P. *)

Definition GroupoidTypeToCatType (T : GroupoidType) : CatType := 
  (T.1 ; C).

Coercion GroupoidTypeToCatType : GroupoidType >-> CatType. 

(* Definition GroupoidTypeToUGroupoidType (T : GroupoidType) : UGroupoidType :=  *)
(*   (T.1 ; G). *)

(* Coercion GroupoidTypeToUGroupoidType : GroupoidType >-> UGroupoidType.  *)

Definition SetoidTypeToGroupoidType (T : SetoidType) : GroupoidType := 
  (T.1 ; S).

Coercion SetoidTypeToGroupoidType :SetoidType >-> GroupoidType. 

(* Definition SetoidTypeToUGroupoidType (T : SetoidType) : UGroupoidType :=  *)
(*   GroupoidTypeToUGroupoidType (SetoidTypeToGroupoidType T). *)

(* Coercion SetoidTypeToUGroupoidType : SetoidType >-> UGroupoidType.  *)

(* Notation "| x '|s'" := (SetoidTypeToGroupoidType x) (at level 50). *)
 
(* Notation "| x '|g'" := (GroupoidTypeToUGroupoidType x) (at level 50). *)

Notation "[[ x ']]'" := (SetoidTypeToGroupoidType x) (at level 50).

Definition setoid_irr2 (S :SetoidType) (x y : [S]) (e e' : x ~1 y) : e ~2 e'.
  apply (is_Trunc_1 x y e e'). 
Defined.

(* Definition proposition_irr1 (P :PropoidType) (x y : [P]) : x ~1 y. *)
(*   apply (is_Trunc_0 x y). *)
(* Defined. *)

Lemma left_simplify_gen {T}
      (cat:Category T)
      (equiv : forall x y, Equivalence (eq2 (x:=x) (y:=y)))
      (x y z: T) (f f': x ~1 y) (g : y ~1 z) 
      (inv_g : z ~1 y) (inv_L : inv_g ° g ~2 identity y) : 
  g ° f ~ g ° f' -> f ~ f'.
Proof.
  intros Heq. assert ((inv_g ° g) ° f ~ (inv_g ° g) ° f').
  eapply composition. apply assoc.
  apply inverse; eapply composition. apply assoc. 
  apply inverse. apply comp. auto. apply identity. 
  eapply composition in X.  
  Focus 2.
  apply comp. apply identity. eapply inverse. apply inv_L.
  eapply inverse in X.
  eapply composition in X.
  Focus 2.
  apply comp. apply identity. eapply inverse. apply inv_L. 
  eapply composition in X.
  Focus 2.
  eapply inverse;  apply id_L. apply inverse in X. eapply composition in X.
  Focus 2.
  eapply inverse;  apply id_L. auto.   
Qed.

Lemma right_simplify_gen {T}
      (cat:Category T)
      (equiv : forall x y, Equivalence (eq2 (x:=x) (y:=y)))
      (x y z: T) (f: x ~1 y) (g g' : y ~1 z) 
      (inv_f : y ~1 x) (inv_R : f ° inv_f ~2 identity y) : 
  g ° f ~ g' ° f -> g ~ g'.
Proof.
  intros Heq. assert (g ° (f ° inv_f) ~ g' ° (f ° inv_f)).
  eapply composition. eapply inverse. apply assoc.
  apply inverse; eapply composition. eapply inverse. apply assoc. 
  apply inverse. apply comp; auto. apply identity.
  eapply composition in X.
  Focus 2.
  apply comp; [idtac | apply identity]. eapply inverse. apply inv_R.
  eapply inverse in X.
  eapply composition in X.
  Focus 2.
  apply comp; [idtac | apply identity]. eapply inverse. apply inv_R. 
  eapply composition in X.
  Focus 2.
  eapply inverse;  apply id_R. apply inverse in X. eapply composition in X.
  Focus 2.
  eapply inverse;  apply id_R. auto.   
Defined.


Definition left_simplify (T:CatType) (x y z: [T])
           (f f': x ~1 y) (g : y ~1 z) (inv_g : z ~1 y) 
           (inv_L : inv_g °g ~ identity y) :
  g ° f ~ g ° f' -> f ~ f' 
  := left_simplify_gen _ _ x y z f f' g inv_g inv_L.

Definition right_simplify (T:CatType) (x y z: [T]) 
           (f: x ~1 y) (g g' : y ~1 z) (inv_f : y ~1 x) 
           (inv_R : f ° inv_f ~ identity y) : 
  g ° f ~ g' ° f -> g ~ g' 
  := right_simplify_gen _ _ x y z f g g' inv_f inv_R.

Lemma right_compose (T:CatType) (x y z:[T]) (f: x ~1 y) (g g': y ~1 z) 
      (inv_f : y ~1 x) (inv_R : f ° inv_f ~2 identity y) 
      (inv_L : inv_f ° f ~2 identity x) :
  g ~2 g' -> g ° f ~2 g' ° f.
Proof.
  intro Heq. apply (right_simplify _ _ _ _ (inv_f) _ _ f inv_L).
  eapply composition. apply assoc.
  eapply inverse. eapply composition. apply assoc.
  eapply composition. apply comp; [idtac | apply identity].
  apply inv_R. eapply inverse. eapply composition. 
  apply comp; [idtac | apply identity]. apply inv_R. 
  eapply composition. apply id_R.
  eapply inverse. eapply composition. apply id_R.
  eapply inverse; auto.
Qed.

Lemma left_compose (T:CatType) (x y z:[T]) (f f': x ~1 y) (g: y ~1 z) 
      (inv_g : z ~1 y) (inv_R : g ° inv_g ~ identity z) 
      (inv_L : inv_g ° g ~ identity y) : f ~ f' -> g ° f ~ g ° f'.
Proof.
  intro Heq. apply (left_simplify _ _ _ _ _ _ (inv_g) g inv_R).
  eapply composition. eapply inverse; apply assoc.
  eapply inverse. eapply composition. eapply inverse; apply assoc.
  eapply composition. apply comp. apply identity.
  apply inv_L. eapply inverse. eapply composition. apply comp.
  apply identity. apply inv_L. eapply composition. apply id_L.
  eapply inverse. eapply composition. apply id_L.
  eapply inverse; auto.
Qed.

Definition left_simplify' (T:GroupoidType) (x y z: [T]) (f f': x ~1 y) 
           (g : y ~1 z) : g ° f ~ g ° f' -> f ~ f' := 
  left_simplify T x y z f f' g (inverse g) (inv_L _ _ _).

Definition right_simplify' (T:GroupoidType) (x y z: [T]) (f : x ~1 y)
           (g g' : y ~1 z)
  := right_simplify T x y z f g g' (inverse f) (inv_R _ _ _).

Definition left_compose' (T:GroupoidType) (x y z:[T]) (f f': x ~1 y) 
           (g: y ~1 z) 
  := left_compose T x y z f f' g (inverse g) (inv_R _ _ _ ) (inv_L _ _ _ ). 

Definition right_compose' (T:GroupoidType) (x y z:[T]) (f : x ~1 y) 
           (g g': y ~1 z)
  := right_compose T x y z f g g' (inverse f) (inv_R _ _ _) (inv_L _ _ _).

Lemma comp_inv (T:GroupoidType) (x y z:[T]) (f : x ~1 y) (g : y ~1 z) : 
  inverse f ° inverse g ~ inverse (g ° f).
Proof.
  apply (left_simplify' _ _ _ _ _ _ (g°f)).
  eapply inverse. eapply composition; try apply inv_R.
  eapply inverse. eapply composition. 
  Focus 2.
  apply inv_R.
  eapply composition. apply assoc.
  apply left_compose'. 
  eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity.
  apply inv_R.
  eapply composition. apply id_L.
  apply identity.
 Qed.

Lemma inv_inv (T:GroupoidType) (x y:[T]) (e : x ~1 y) : 
  inverse (inverse e) ~ e.
Proof.
  apply (left_simplify' _ _ _ _ _ _ (inverse e)).
  eapply composition. apply inv_R. eapply inverse. apply inv_L. 
Defined.

Lemma inv_id (T:GroupoidType) (x:[T]) : 
  inverse (identity x) ~ identity x.
Proof.
  eapply inverse. eapply composition; [idtac | apply id_L]. 
  eapply inverse. apply inv_R. 
Qed.

Lemma comp_id (T:GroupoidType) (x:[T]) : 
  identity x ° identity x ~ identity x.
Proof.
  eapply composition; try apply id_L. apply identity.
Qed.

(* end hide *)
(** **  Functors and natural transformations
%\label{sec:funextnat}%
A morphism between two groupoids is a functor, i.e., a function
between objects of the groupoids that transports homs and
subject to compatibility laws. 
*)

Class Functor {T U : GroupoidType} (f : [T] -> [U]) : Type :=
{ _map : ∀ {x y}, x ~1 y -> f x ~1 f y ;
  _map_id : ∀ {x}, _map (identity x) ~ identity (f x) ;
  _map_comp : ∀ {x y z} (e:x ~1 y) (e':y ~1 z), _map (e' ° e) ~2 _map e' ° _map e ;
  _map2 : ∀ {x y:[T]} {e e' : x ~1 y}, (e ~2 e') -> _map  e ~2 _map e' }.

Definition Fun_Type (T U : GroupoidType) := {f : [T] -> [U] & Functor f}.

(* begin hide *)

Infix "--->" := Fun_Type (at level 55). 

Notation map f := (@_map _ _ _ f.2 _ _).
Notation map_id f := (@_map_id _ _ _ f.2 _).
Notation map_comp f := (@_map_comp _ _ _ f.2 _ _ _ ).
Notation map2 f := (@_map2 _ _ _ f.2 _ _ _ _).

Hint Extern 0 (Functor [?f]) => exact (proj2 f) : typeclass_instances.

(* end hide *)
(** %\noindent% We note [T ---> U] the type of functors from [T] to [U].
Note that we only impose compatibility with the composition as
compatibilities with identities and inverse Homs can be deduced from
it. We note [M @ N] the application of a function [M] in the first
component of a dependent pair. *)
(* begin hide *)
Notation " M @ N " := ([M] N) (at level 20). 

(* Lemma map_id {T U} (f : T ---> U) {x} : map f (identity x) ~ identity (f @ x). *)
(* Proof. *)
(*   apply (right_simplify' _ _ _ (map f (identity x))). *)
(*   eapply composition. eapply inverse, (map_comp f). *)
(*   eapply composition. eapply (map2 f). apply id_L. eapply inverse. apply id_L.  *)
(* Defined. *)

Lemma map_inv {T U} (f : T ---> U) :
  ∀ x y (e : x ~1 y) , map f (inverse e) ~ inverse (map f e).
Proof.
  intros. eapply right_simplify'.
  eapply composition. eapply inverse, (map_comp f).
  eapply composition. eapply (map2 f). apply inv_L.
  eapply composition. apply (map_id f). eapply inverse. apply inv_L.
Defined.

Opaque map_inv.

Hint Extern 1 (@Identity (@eq1 (@Hom1 ?T) ?x ?y) eq2) => 
  apply (@Equivalence_Identity _ _ (@Equivalence_2 T _ x y)) : typeclass_instances.

Instance arrow_id (T:GroupoidType) : Functor (id (A := [T])) :=
  { _map x y e := e;
    _map_id x := identity (identity (id x)) }.
Next Obligation. apply identity. Defined.
    (* _map_comp x y z e e' := identity (e' ° e) }. *)
  
Instance id_fun : Identity Fun_Type :=
  { identity x := (id (A:=[x]) ; arrow_id _) }.

Instance arrow_comp A B C (f : A ---> B) (g : B ---> C) : 
  Functor (λ x : [A], g @ (f @ x)) :=
  { _map x y e := map g (map f e) }.
Next Obligation. 
  eapply composition.
  eapply (map2 g). apply (map_id f). apply (map_id g).
Defined.
Next Obligation. 
  eapply composition.
  eapply (map2 g). apply (map_comp f e e'). eapply (map_comp g). 
Defined.
Next Obligation. apply (map2 g). apply (map2 f). auto. Defined.
 
Program Instance comp_fun : Composition Fun_Type :=
  { composition x y z X X0 := (λ x, X0 @ (X @ x) ; arrow_comp _ _ _ _ _) }.

(* end hide *)
(** Equivalence between functors is given by natural transformations.
  We insist here that this naturality condition in the definition of
  functor equality is crucial in a higher setting.  It is usually
  derivable in formalizations of homotopy theory in Coq because there they
  only consider the 1-groupoid case where the naturality comes for
  free from functional extensionality, see for instance%~\cite{coq_unival_axiom}%.  *)

Class NaturalTransformation T U {f g : T ---> U} (α : ∀ t : [T], f @ t ~1 g @ t) := 
  _α_map : ∀ {t t'} (e : t ~1 t'), α t' ° map f e ~ map g e ° α t.

Definition nat_trans T U : HomT (T ---> U) 
 := λ f g, {α : ∀ t : [T], f @ t ~1 g @ t & NaturalTransformation α}.

(* begin hide *)
Hint Extern 0 (NaturalTransformation [?f]) => exact (proj2 f) : typeclass_instances.

Notation α_map f := ((proj2 f)).
 
Instance nat_transHom T U : HomT1 (T ---> U) := {eq1 := nat_trans (T:=T) (U:=U)}.
(* end hide *)
(** In our setting, equality between natural transformations is not expressed using identity types, but using the higher categorical notion of modification.
*)

Definition modification T U (f g : T ---> U) : HomT (f ~1 g) 
  := λ α β, ∀ t : [T], α @ t ~ β @ t.

(* begin hide *)

Instance modificationHom T U : HomT2 eq1 := {eq2 := modification (T:=T) (U:=U)}.

Program Instance _nat_id T U (f : T ---> U) : 
  NaturalTransformation (λ t : [T], identity (f @ t)).
Next Obligation. 
Proof.
  intros. eapply composition. apply id_L.
  eapply inverse. apply id_R. 
Defined.

Program Instance nat_id T U : Identity (nat_trans (T:=T) (U := U)).
Next Obligation. 
  rename x into f. 
  exact (λ t, identity (f @ t); _nat_id _ _ f). 
Defined.

Program Instance _nat_inv T U (f g : T ---> U) (H : nat_trans f g) :
  NaturalTransformation (λ t : [T], inverse  (H @ t)).
Next Obligation. intros. simpl in *. 
  eapply (left_simplify U).
  apply inv_L.
  eapply composition. eapply inverse; apply assoc.
  eapply composition. apply comp. apply identity.
  apply inv_R. eapply inverse.
  eapply composition. eapply inverse; apply assoc. 
  eapply composition. apply comp. apply identity.
  apply (α_map H). eapply composition. apply assoc.
  eapply composition. apply comp. apply inv_R.
  apply identity.
  eapply composition. apply id_R.
  eapply composition. apply identity. eapply inverse. apply id_L.
Defined.

Program Instance nat_inv T U : Inverse (nat_trans (T:=T) (U := U)).
Next Obligation. rename x into f, y into g, X into H. 
       exact (λ t , inverse (H @ t); _nat_inv T U f g H). Defined.
  
Program Instance _nat_comp T U (f g h : T ---> U) (H : nat_trans f g) 
        (H' : nat_trans g h) : 
  NaturalTransformation (λ t : [T], (H' @ t) ° (H @ t)).

Next Obligation. 
Proof.
  intros. eapply composition. apply assoc.
  eapply composition. apply comp. apply (α_map H). apply identity.
  eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity. apply (α_map H').
  eapply composition. apply assoc. apply identity. 
Defined.

Program Instance nat_comp T U : Composition (nat_trans (T:=T) (U := U)).

Next Obligation. 
Proof.
  rename x into f, y into g, z into h,X into H, X0 into H'. 
  exact (λ t , composition (H @ t) (H' @ t); _nat_comp T U f g h H H').
Defined.

Program Instance nat_equiv T U : Equivalence (nat_trans (T:=T) (U := U)).

Program Instance nat2_id T U (f g : T ---> U) : 
  Identity (modification (f:=f) (g:=g)).
Next Obligation. exact (λ t, identity _). Defined.

Program Instance nat2_inv T U (f g : T ---> U) : 
  Inverse (modification (f:=f) (g:=g)).
Next Obligation. rename X into E. exact (λ t, inverse (E t)). Defined.

Program Instance nat2_comp T U (f g : T ---> U) :
  Composition (modification (f:=f) (g:=g)).
Next Obligation. rename X into E, X0 into  F. exact (λ t, (F t) ° (E t)). Defined.

Program Instance nat2_equiv T U (f g : T ---> U) :
  Equivalence (modification (f:=f) (g:=g)).

Program Instance nat_trans_cat T U : Category (T ---> U).
Next Obligation. intro t. apply id_R. Defined.
Next Obligation. intro t. apply id_L. Defined.
Next Obligation. intro t. apply assoc. Defined.
Next Obligation. intro t. apply comp. apply X. apply X0 . Defined.

Program Instance nat_trans_grp T U : Groupoid (T ---> U).
Next Obligation. intro t. apply inv_R. Defined.
Next Obligation. intro t. apply inv_L. Defined.
Next Obligation. intro t. apply inv, X. Defined.

Program Instance modification_eq T U (f g : T ---> U) : 
  Equivalence (modification (f:=f) (g:=g)).

(*Instance nat_groupoid (T U : GroupoidType) : Groupoid (T ---> U).
Next Obligation.
  apply (@contr_equiv _ _ _ (isequiv_inverse (isequiv_apD10 _ E E'))).
  apply contr_forall. intros z.
  apply (@is_Trunc_2 _ _ _ _ _ _ (E z) (E' z)).
Defined.
*)
(* end hide *)
(** %\noindent%
    We can now equip the functor space with a groupoid structure. Note
    here that we (abusively) use the same notation for the functor type and 
    its corresponding groupoid. *)

Definition _fun T U : GroupoidType := (T ---> U ; nat_trans_grp T U).

(* begin hide *)

Infix "-->" := _fun (at level 90). 

(* end hide *)
(**
 In the definition above, [nat_trans_grp] is a proof that [nat_trans] and [modification] form a groupoid on [T ---> U]. In particular, it makes use of functional extensionality, which says that the canonical proof of [f = g -> ∀ x, f x = g x] is an equivalence (in the sense of homotopy type theory).   
 *)

(* begin hide *)

Instance FunTypeHom : HomT1 GroupoidType := {eq1 := Fun_Type}.

Instance nat_transHom' : HomT2 Fun_Type := {eq2 := nat_trans}.

Program Instance category_fun : Category GroupoidType. 

Next Obligation. 
Proof. 
  exists (λ t , identity _). intros t t' e. simpl.
  eapply composition. apply id_L. eapply inverse. apply id_R.
Defined.
Next Obligation. 
Proof.
  exists (λ t , identity _). intros t t' e. 
  eapply composition. apply id_L. eapply inverse. apply id_R. 
Defined.

Next Obligation.
Proof.
  exists (λ t , identity _).  intros t t' e. 
  eapply composition. apply id_L. eapply inverse. apply id_R. 
Defined.
Next Obligation. 
Proof.
  exists (λ t , map g' (X @ t) ° (X0 @ (f @ t))). intros t t' e. 
  eapply composition. apply assoc.
  eapply composition. apply comp. apply (α_map X0). apply identity.
  eapply composition. eapply inverse. apply assoc. eapply inverse.
  eapply composition. eapply inverse. apply assoc. 
  apply comp. apply identity. eapply composition.
  Focus 2. eapply composition. Focus 2. apply (map_comp g').  
  eapply (map2 g'). eapply inverse. apply (α_map X).
  eapply inverse. simpl. apply (map_comp g'). 
Defined.

Program Instance _eq : ∀ (T U : GroupoidType), 
                         Equivalence (nat_trans (T:=T) (U:=U)).
 
Definition nat_id_R  := (@id_R _ category_fun).
Definition nat_id_L  := (@id_L _ category_fun).
Definition nat_assoc := (@assoc _ category_fun).
Definition nat_comp'  := (@comp _ category_fun).

Lemma nat_comp2 A B C (f f': A ~1 B) (g g' : B ~1 C) 
      (H H': f ~1 f') (G G' : g ~1 g') (e: H ~2 H') (e':G ~2 G') :
    nat_comp' H G ~ nat_comp' H' G'.
Proof.
  intro a. simpl. apply comp. apply e'. apply (map2 g' (e a)).
Defined.

Lemma nat_comp_id A B C (f : A ---> B) (g : B ---> C) :
    nat_comp' (identity f) (identity g) ~ identity _.
Proof.
  intro a. simpl in *. eapply composition. apply id_R. apply (map_id g).
Defined.

(*Definition NaturalTransformationEq2 (T U : SetoidType)
  (f g : T ---> U) (α : ∀ t : [T], [f] t ~1 [g] t)
  (H H' : NaturalTransformation (T:=[[T]]) (U:=[[U]]) α):
  H = H'.
  apply path_forall. intros t. apply path_forall. intros t'.
  apply path_forall. intros E.
  apply is_Trunc_2.
Defined.
*)
(* end hide *)
(**  ** Homotopic equivalences
 %\label{sec:homequiv}%   
    The standard notion of equivalence between groupoids is given by
    adjoint equivalences, that is a map with an [adjoint] and two proofs
    that they form a [section] (or counit of the adjunction) and a
    [retraction] (or unit of the adjunction). *)
(* begin hide *)
Definition Fun_Type_Setoid (T U : SetoidType) := [[T]] ---> [[U]].

Infix "-S->" := Fun_Type_Setoid (at level 55). 


Definition _Fun_Setoid_ T U (f g : T -S-> U) (e e' : nat_trans f g) : e ~2 e'.
  intro z. apply is_Trunc_1.
Defined.

Instance _Fun_Setoid (T U : SetoidType) : Setoid (T -S-> U).
Next Obligation. 
  exact (_Fun_Setoid_ e e').
Defined.

Definition Fun_Setoid (T U : SetoidType) := (T -S-> U; _Fun_Setoid T U) : SetoidType.

Infix "-|->" := Fun_Setoid (at level 55). 


(* end hide *)

Class Iso_struct T U (f : [T --> U]) := 
{ _adjoint :    [U --> T] ;
  _section :    f ° _adjoint ~ identity U ;
  _retraction : _adjoint ° f ~ identity T}.

(* begin hide *)

Definition Iso A B := {f : A ---> B & Iso_struct f}.

(* Notations for [Iso] projections. *)

Notation adjoint' f := (@_adjoint _ _ _ f.2).
Notation section' f := (@_section _ _ _ f.2).
Notation retraction' f := (@_retraction _ _ _ f.2).

(* end hide *)
(** This type class defines usual equivalences. To get an adjoint
    equivalence, an additional triangle identity between sections and
    retractions is required. This allows to eliminate a section against
    a retraction in proofs. A corresponding triangle identity involving
    [adjoint f] can also be expressed, but it can be shown that each
    condition implies the other.  *)

Class Equiv_struct T U (f : T ---> U) := 
{ iso :> Iso_struct f;
  _triangle : ∀ t, _section @ (f @ t) ~ map f (_retraction @ t)}.

Definition Equiv A B := {f : A ---> B & Equiv_struct f}.

(* begin hide *)

Infix "<~>" := Equiv (at level 55). 

Hint Extern 0 (Equiv_struct [?f]) => exact (proj2 f) : typeclass_instances.
Hint Extern 0 (Iso_struct [?f]) => exact (@iso (proj2 f)) : typeclass_instances.

(* Notations for [Equiv] projections. *)
Notation adjoint f := (@_adjoint _ _ _ (@iso _ _ _ f.2)).
Notation section f := (@_section _ _ _ (@iso _ _ _ f.2)).
Notation retraction f := (@_retraction _ _ _ (@iso _ _ _ f.2)).
Notation triangle f := (@_triangle _ _ _ f.2).

Program Definition map_trans A B (f : [A --> B]) : f ~1 f :=
  ((fun t => map f (identity t)); _).

Next Obligation.
Proof.
  intros t t' e. simpl.
  eapply composition. eapply composition. apply comp. apply identity.
  apply (map_id f). apply id_L. apply inverse.
  eapply composition. apply comp. apply (map_id f). apply identity. apply id_R.
Defined.

Program Instance EquivToIso_ A B (f : A <~> B) : Iso_struct [f].
Next Obligation. exact (adjoint f). Defined.
Next Obligation. exact (section f). Defined.
Next Obligation. exact (retraction f). Defined.

Definition EquivToIso A B (f : A <~> B) := ([f]; EquivToIso_ _ _ f).

Lemma Equiv_map_injective {A B} (f: Iso A B) {x y : [A]} (e e': x ~1 y) :
  map [f] e ~ map [f] e' -> e ~ e'.
Proof.
  intros H. apply (map2 (adjoint' f)) in H.
  eapply (left_compose' A) in H.
  eapply composition in  H. Focus 2. eapply inverse. apply (α_map (retraction' f)).
  apply inverse in H.
  eapply composition in  H. Focus 2. eapply inverse. apply (α_map (retraction' f)).
  apply right_simplify' in H. exact (inverse H).
Defined.

Program Instance _Iso_inv {A B} (f : Iso A B) : Iso_struct (adjoint' f).
Next Obligation. exact [f]. Defined.
Next Obligation. exact (retraction' f). Defined.
Next Obligation. exact (section' f). Defined.

Instance _Type_iso_inv : Inverse Iso := 
  { inverse T U f := (adjoint' f ; _Iso_inv f) }.

Lemma nat_on_id A (f : [A --> A]) (α : f ~ identity A) (a:[A]) : 
  α @ (f @ a) ~ map f (α @ a).
Proof.
  eapply left_simplify'. apply inverse. apply (α_map α).
Defined.

Definition triangle' A B (f : A <~> B) : 
  forall u, map (adjoint f) (section f @ u) ~ (retraction f @ _).
Proof.
  intros.
  assert (triangle := triangle f (adjoint f @ u)).
  assert (foo := α_map (section f) _ _ (section f @ u)). simpl in foo.
  apply (map2 (adjoint f)) in foo. 
  eapply composition in foo. Focus 2.
  eapply inverse. apply (map_comp (adjoint f)). 
  eapply inverse in foo. eapply composition in foo. Focus 2.
  eapply inverse. apply (map_comp (adjoint f)). 
  eapply composition in foo. Focus 2. apply comp. 
  eapply inverse. apply (map2 (adjoint f) triangle). apply identity.
  eapply composition in foo. Focus 2. apply comp. 
  apply (nat_on_id (retraction f)). apply identity.
  eapply composition in foo. Focus 2. 
  apply (α_map (retraction f) _ _ (map (adjoint f) (section f @ u))). 
  eapply right_simplify'. eapply inverse. apply foo.
Defined.

Program Instance IsoToEquiv'' A B (f : Iso A B) : Iso_struct [f].
Next Obligation. exact (adjoint' f). Defined.

Next Obligation. 
  pose (F := (map_trans (adjoint' f)) ** retraction' f ** map_trans [f]).
  pose (idL := id_L _ _ (adjoint' f)).
  pose (idLf := idL ** map_trans [f]).
  pose (G := map_trans (adjoint' f) ** map_trans [f] ** section' f).
  pose (ass := assoc _ _ _ _ (adjoint' f) [f] (adjoint' f) ** map_trans [f]).
  pose (idR := id_L _ _ ([f] °adjoint' f)).
  pose (idRf := inverse idR).
  pose (ass' := assoc _ _ _ _ ([f] ° adjoint' f) (adjoint' f) [f]).
  exact (section' f ° idLf ° F ° inverse ass ° ass' ° inverse G ° idRf).
Defined.

Next Obligation. exact (retraction' f). Defined. 

Definition IsoToEquiv' A B (f : Iso A B) := ([f] ; IsoToEquiv'' _ _ f).


(* Tactics for simplification of goals containing [identity] applications. *)

Ltac simpl_id_end' := eapply composition ; [match goal with
                   | [ |- eq2 (?P ^-1 ° ?P) _] => 
                     apply inv_L
                   | [ |- eq2 (?P ° ?P ^-1) _] => 
                     apply inv_R
                   | [ |- eq2 (?P ° identity ?x) _] => 
                     apply id_R
                   | [ |- eq2 (identity ?x ° ?P) _] => 
                     apply id_L
                   | [ |- eq2 ((?P ^-1)^-1) _] => 
                     apply inv_inv
                   | [ |- eq2 ((identity ?T)^-1) _] => 
                     apply (inv_id _ T)
                 end | idtac].

Ltac simpl_id_end_extended' := first [ simpl_id_end' |
                                      match goal with
                   | [ |- eq2 ?e _ ] => apply identity
                   | [ |- _ ] => idtac
                 end].

Ltac simpl_id' := first [simpl_id_end' ; simpl_id' |
                        match goal with
                   | [ |- eq2 (?P ^-1) _] => eapply composition;
                              [apply inv ; simpl_id' | idtac]; 
                              try apply identity
                   | [ |- eq2 (map ?F (identity _)) _] => eapply composition;
                              [eapply (map_id F); simpl_id' | idtac]; 
                              simpl_id'
                   | [ |- eq2 (map ?F ?P) _] => first [
                          eapply composition;
                              [eapply (map2 F); simpl_id' | idtac]; 
                              [apply identity | idtac] | 
                          (progress_evars (eapply composition;
                              [eapply (@_map2 _); simpl_id' | idtac]; instantiate)) ; simpl_id' |
                          idtac]
                   | [ |- eq2 (?Q ° ?P) _] => eapply composition;
                                             [apply comp; simpl_id' | idtac];
                                            simpl_id_end_extended'
                   | [ |- eq2 ?e _ ] => first [has_evar e; idtac | apply identity]
                   | [ |- _ ] => idtac
                 end].

Tactic Notation "comp" open_constr(c) :=
  eapply composition; [eapply c|idtac].

(* Ltac simpl_id_end' ::=  *)
(*      match goal with *)
(*        | [ |- eq2 (?P ^-1 ° ?P) _] => comp inv_L *)
(*        | [ |- eq2 (?P ° ?P ^-1) _] => comp inv_R *)
(*        | [ |- eq2 (?P ° identity ?x) _] => comp id_R *)
(*        | [ |- eq2 (identity ?x ° ?P) _] => comp id_L *)
(*        | [ |- eq2 ((?P ^-1)^-1) _] => comp inv_inv *)
(*        | [ |- eq2 ((identity ?T)^-1) _] => comp (inv_id _ T) *)
(*      end. *)

Ltac simpl_id_bi' := simpl_id'; eapply inverse; simpl_id'.

Ltac simpl_id' ::= 
  first [simpl_id_end' ; (match goal with |- _ => simpl_id' end) |
         match goal with
           | [ |- eq2 (?P ^-1) _] => 
             eapply composition;
               [apply inv; simpl_id' | idtac]; 
               try apply identity
           | [ |- eq2 (map ?F (identity _)) _] =>
             eapply composition;
               [eapply (map_id F); simpl_id' | idtac]
           | [ |- eq2 (map ?F ?P) _] => 
             first [
                 progress_evars (comp (map2 F); [simpl_id'; apply identity|idtac]) |
                 (progress_evars (eapply composition;
                                  [eapply (@_map2 _); simpl_id' | idtac]; instantiate)) ; simpl_id' |
                 idtac]
           | [ |- eq2 (?Q ° ?P) _] => 
             eapply composition;
               [apply comp; simpl_id' | idtac];
               simpl_id_end_extended'
           | [ |- eq2 ?e _ ] => first [has_evar e; idtac | apply identity]
           | [ |- _ ] => idtac
         end].

Program Instance IsoToEquiv_ A B (f : Iso A B) : Equiv_struct [f].
Next Obligation. simpl_id'. simpl_id' .
  unfold IsoToEquiv''_obligation_3.
  eapply (right_simplify' B). eapply composition. apply assoc.
  eapply composition. apply comp. apply inv_L. apply identity.
  simpl_id'. eapply composition. apply comp.
  apply (map2 [f] (nat_on_id (retraction' f) t)). apply identity.
  simpl in *. apply (α_map (section' f)).
Defined.

(* end hide *)
(** 
   It is well known that any equivalence can be turned into an adjoint
   equivalence by slightly modifying the section. While available in
   our formalization, this result should be used with care as it
   opacifies the underlying notion of homotopy and can harden proofs.
*)

(* begin hide *)

Definition IsoToEquiv A B (f : Iso A B) : Equiv A B.
Proof. exact ([f]; IsoToEquiv_ _ _ f). Defined.

(** Definition of identity homotopy equivalence *)

Program Instance __Equiv_Id {T} : Iso_struct (identity T).
Next Obligation. exact (identity T). Defined.
Next Obligation. 
Proof.
  exact (λ t , identity t; _nat_id T T (identity T)). 
Defined.
Next Obligation. 
Proof. 
  exact (λ t , identity t; _nat_id T T (identity T)). 
Defined.

Program Instance _Equiv_Id {T} : Equiv_struct (identity T).
Next Obligation. apply identity. Defined.

Instance _Type_id : Identity Equiv := { identity T := (identity T ; _Equiv_Id) }.

(** Definition of inverse of homotopy equivalence **)

Program Instance __Equiv_inv {A B} (f : A <~> B) : Iso_struct (adjoint f).
Next Obligation. exact [f]. Defined.
Next Obligation. exact (retraction f). Defined.
Next Obligation. exact (section f). Defined.

Program Instance _Equiv_inv {A B} (f : A <~> B) : Equiv_struct (adjoint f).
Next Obligation. apply inverse. apply (triangle' f _). Defined.

Instance _Type_inv : Inverse Equiv := 
  { inverse T U f := (adjoint f ; _Equiv_inv f) }.

Instance Adjoint_Functor T U (f : T <~> U) : Functor [adjoint f] :=
  Π2 (adjoint f).
  
Obligation Tactic := intros.

Program Instance __Equiv_comp {A B C} (f : A <~> B) (g : B <~> C) : 
  Iso_struct ([g] ° [f]).
Next Obligation. exact (adjoint f ° adjoint g). Defined.


Next Obligation. 
Proof. eapply composition. apply nat_assoc. 
  eapply composition. apply nat_comp'. eapply composition. 
  eapply inverse, nat_assoc.
  eapply composition. apply nat_comp'. apply identity. apply (section f).
  apply nat_id_L. apply identity. apply (section g).
Defined.
Next Obligation. 
  eapply composition. apply nat_assoc.
  eapply composition. apply nat_comp'. eapply composition. 
  eapply inverse, nat_assoc.
  eapply composition. apply nat_comp'. apply identity. eapply (retraction g).
  apply nat_id_L. apply identity. eapply (retraction f). 
Defined.

Program Instance _Equiv_comp {A B C} (f : A <~> B) (g : B <~> C) : 
  Equiv_struct ([g] ° [f]).

Next Obligation. 
Proof.
  simpl. simpl_id_bi'.
  apply inverse. eapply composition.
  apply comp. apply identity. apply (triangle g).
  eapply composition. eapply inverse. apply (map_comp [g]). apply (map2 [g]).
  eapply composition. eapply inverse. apply (α_map (section f)).
  eapply composition. apply comp. apply identity. apply (triangle f). 
  eapply inverse. apply (map_comp [f]). 
Defined.

Instance _Type_comp : Composition Equiv := 
  { composition T U V f g := ([g] ° [f] ; _Equiv_comp f g) }.

(* end hide *)
(** Equality of homotopy equivalences is given by equivalence of
  adjunctions. Two adjunctions are equivalent if their left adjoints are
  equivalent and they agree on their sections (up-to the isomorphism).
  Note that equivalence of the right adjoints and agreement on their
  retractions can be deduced so they are not part of the definition.  *)
(* begin hide *)

Definition Equiv_adjoint {A B} {f f': Equiv A B} : 
  [f] ~1 [f'] -> adjoint f ~1 adjoint f'.
Proof.
  intro.
  eapply composition. eapply inverse. apply nat_id_L.
  eapply composition. apply nat_comp'. apply identity. 
  apply (inverse (retraction f')). eapply composition. apply nat_assoc. 
  eapply composition. apply nat_comp'. 
  eapply composition. apply nat_comp'. apply identity. apply (inverse X).
  apply (section f). apply identity. apply nat_id_R.
Defined.

Lemma Equiv_injective A B (f: A <~> B) x y : [f] @ x ~1 [f] @ y -> x ~1 y.
Proof.
  intros e. 
  eapply composition. pose (inverse (retraction f)). apply [n].
  eapply inverse. eapply composition; pose (inverse (retraction f)). apply [n].
  apply (map (adjoint f) (inverse e)).
Defined.

Definition Equiv_adjoint_simpl A B (f f': A <~> B) (H: [f] ~1 [f']) a :
  [Equiv_adjoint H] a ~ 
     map (adjoint f') ([section f] a ° inverse ([H] ([adjoint f] a)))
   ° [inverse (retraction f')] ([adjoint f] a).
Proof.
  unfold Equiv_adjoint. simpl. simpl_id'. simpl_id'. 
Defined.

Opaque Equiv_adjoint.

Lemma triangle_inv' A B (f : A <~> B) : forall u, 
  map (adjoint f) (section f @ u) ° inverse (retraction f @ _) ~ identity _.
Proof.
  intro. eapply composition. apply comp. apply identity. 
  apply (triangle' f). apply inv_R.
Defined.

Lemma triangle_inv A B (f : A <~> B) : ∀ t, 
  (section f @ ([f] @ t)) ° map [f] ((inverse (retraction f)) @ t) ~ identity _.
Proof.
  intro. eapply composition. apply comp. apply identity. apply (triangle f). 
  eapply composition. apply comp. apply map_inv. apply identity. apply inv_R.
Defined.

Lemma Equiv_adjoint_id A B (f : A <~> B) :
 modification (Equiv_adjoint (identity [f])) (identity _).
Proof.
  intro b. eapply composition. apply Equiv_adjoint_simpl.
  eapply composition. apply comp. apply identity. eapply composition. eapply (map2 (adjoint f)).
  eapply composition. apply comp. apply inv_id. apply identity. apply id_R.
  apply identity. apply (triangle_inv' f).
Defined.

Lemma Equiv_adjoint2 A B (f g: A <~> B) (H H': [f] ~1 [g] ) (e : H~ H'):
 Equiv_adjoint H ~ Equiv_adjoint H'.
Proof.
  intro b. eapply composition. apply Equiv_adjoint_simpl.
  eapply inverse.  eapply composition. apply Equiv_adjoint_simpl.
  apply comp; try apply identity. apply (map2 (adjoint g)).
  apply comp; try apply identity. apply inv. eapply inverse, e.
Defined.  

Lemma Equiv_adjoint_inv A B (f g: A <~> B) (H : [f] ~1 [g] ) :
 Equiv_adjoint H ° Equiv_adjoint (inverse H) ~ identity _.
Proof.
  intro b. eapply composition. apply comp; apply Equiv_adjoint_simpl.
  eapply composition. apply assoc. eapply composition. apply comp.
  apply (α_map ((inverse (retraction g)) : nat_trans _ _)). 
  apply (map_comp (adjoint g)).
  eapply composition. apply assoc. eapply composition. apply comp.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity. eapply composition. 
  eapply inverse, (map_comp (adjoint g)). eapply composition.
  eapply (map2 (adjoint g)).
  assert (foo := Π2 (inverse H)). apply foo.
  apply (map_comp (adjoint g)). apply identity. apply identity.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity.
  eapply composition. eapply inverse, (map_comp (adjoint g)). eapply composition.
  eapply (map2 (adjoint g)). eapply composition. apply comp.
  apply (map_comp [f]). apply identity.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity.
  apply (α_map (section f)). simpl. 
  eapply composition. apply assoc. eapply composition.
  apply comp. apply (triangle_inv f). apply identity. apply id_R. 
  apply (map_comp (adjoint g)).
  eapply composition. apply assoc. eapply composition. apply comp.
  eapply composition. eapply inverse, (map_comp (adjoint g)). eapply composition.
  eapply (map2 (adjoint g)). apply inv_L. apply (map_id (adjoint g)). 
  apply identity. apply id_R. apply (triangle_inv' g).
Defined.

Lemma Equiv_adjoint_comp A B (f f' f'': A <~> B) (H : [f] ~1 [f']) (H' : [f'] ~1 [f'']):
 Equiv_adjoint (H' ° H) ~ Equiv_adjoint H' ° Equiv_adjoint  H.
Proof.
  intro b. eapply composition. apply Equiv_adjoint_simpl.
  eapply composition. apply comp. apply identity.  eapply composition. 
  eapply (map2 (adjoint f'')).
  apply comp. eapply inverse, comp_inv. apply identity.
  eapply composition. apply (map_comp (adjoint f'')). apply comp.
  apply (map_comp (adjoint f'')). apply identity.
  eapply inverse. eapply composition. apply comp; apply Equiv_adjoint_simpl.
  eapply composition. apply assoc. eapply composition. apply comp.
  apply (α_map (inverse (retraction f'') : nat_trans _ _)). 
  apply (map_comp (adjoint f'')).
  eapply composition. apply assoc. eapply composition. apply comp.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity.
  eapply composition. eapply inverse, (map_comp (adjoint f'')). 
  eapply composition. eapply (map2 (adjoint f'')).
  assert (foo := Π2 (inverse H')). apply foo.
  apply (map_comp (adjoint f'')). apply identity. apply identity.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity.
  eapply composition. eapply inverse, (map_comp (adjoint f'')). 
  eapply composition. eapply (map2 (adjoint f'')). 
  eapply composition. apply comp.
  apply (map_comp [f']). apply identity.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity.
  apply (α_map (section f')). simpl. 
  eapply composition. apply assoc. eapply composition.
  apply comp. apply (triangle_inv f'). apply identity.
  apply id_R. apply (map_comp (adjoint f'')).
  eapply composition. apply assoc. eapply composition. apply comp.
  eapply composition. eapply inverse, (map_comp (adjoint f'')). 
  eapply composition. eapply (map_comp (adjoint f'')). 
  apply identity. apply identity. apply identity. apply identity.
Defined.

Notation  "g °' f" := (nat_comp' f g) (at level 50). 

(* end hide *)

Class EquivEq {T U} {f g : Equiv T U} (α : [f] ~ [g]) : Type :=  
 _eq_section : section f ~ section g ° (α °' (Equiv_adjoint α)). 

Definition Equiv_eq T U (f g : Equiv T U) := {α : nat_trans [f] [g] & EquivEq α}.

(** It is crucial here to be able to express the 2-dimensional equality
  between groupoids as a particular [Type] and not directly using the
  identity type. Indeed, whereas the functional extensionality principle
  makes the use of the identity type and modification equivalent to
  treat equality of natural transformations, the same is not possible
  for homotopy equivalences.  *)
(* begin hide *)

Hint Extern 0 (EquivEq [?α]) => apply α.2 : typeclass_instances.

Notation eq_section α := α.(proj2).

Definition eq_retraction {T U} {f g : T <~> U} (α:Equiv_eq f g) : 
  retraction f ~
  retraction g ° (nat_comp' [α] (Equiv_adjoint [α])).
Proof.
  intro. apply (Equiv_map_injective (EquivToIso f)). simpl.
  eapply composition. eapply inverse. apply (triangle f).
  eapply composition. apply (eq_section α). simpl. apply inverse.
  eapply composition. apply _map_comp.
  eapply left_simplify'. eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity.
  apply (α_map [α]). unfold id. 
  eapply composition. apply assoc. eapply composition. apply comp. apply identity.
  eapply inverse. apply (triangle g). apply inverse.
  eapply composition. apply comp. apply comp. eapply inverse. apply (α_map [α]).
  apply identity. apply identity. 
  eapply composition. eapply inverse. apply assoc. 
  eapply composition. apply comp. apply identity.
  eapply inverse. apply (α_map (section g)). eapply composition. apply assoc.
  apply comp; [idtac | apply identity].
  eapply composition. eapply inverse. apply assoc. apply inverse.
  eapply composition. apply comp. apply _map_comp. apply identity.
  eapply composition. eapply inverse. apply assoc.
  apply comp; [apply identity | idtac]. apply (α_map [α]).
Defined.

Definition AllEquivEq_Setoid : forall (T U : SetoidType) (f g : T <~> U) 
                               (α : nat_trans [f] [g]),
                     EquivEq α.
  intros. intro u. apply setoid_irr2. Defined.

Lemma ExLawComp_nat A B C (f f' f'': A ~1 B) (g g' g'' : B ~1 C) 
      (H:f ~1 f') (H': f' ~1 f'') (G : g ~1 g') (G': g' ~1 g'') :
    nat_comp' (H' ° H) (G' ° G) ~2 nat_comp' H' G' ° nat_comp' H G.
Proof.
  intro a. simpl. eapply composition. 
  apply comp. apply identity. apply (map_comp g''). 
  eapply composition. apply assoc. eapply inverse.
  eapply composition. apply assoc. apply comp; try apply identity. 
  eapply composition. eapply inverse. apply assoc. 
  eapply composition. apply comp. apply identity.
  apply (Π2 G'). eapply composition. apply assoc. apply identity.
Defined.

Program Instance Id_Equiv_eq T U : Identity (Equiv_eq (T:=T) (U:=U)).
Next Obligation. 
Proof.
  exists (identity [x]).
  intro u. eapply composition. eapply inverse. apply id_R.
  apply comp; try apply identity. eapply inverse. 
  eapply composition. 
  eapply (nat_comp2 (Equiv_adjoint_id _) (identity _) u). 
  apply (nat_comp_id _ _ u).
Defined.                 

Program Instance Inv_Equiv_eq T U : Inverse (Equiv_eq (T:=T) (U:=U)).
Next Obligation.
Proof.
  rename x into f, y into g. 
  exists (inverse [X]).
  rename X into α.
  intro u. eapply inverse; eapply composition. apply comp. apply identity.
  apply (eq_section α).
  eapply composition. apply assoc. 
  eapply composition. apply comp. eapply composition. eapply inverse.
  apply (ExLawComp_nat _ _ _ _ u).
  eapply composition. 
  eapply nat_comp2. apply (Equiv_adjoint_inv _). 
  apply (inv_R (Groupoid := nat_trans_grp T U)).
  apply (nat_comp_id _ _ u). apply identity. apply id_R.
Defined.

Program Instance Comp_Equiv_eq T U : Composition (Equiv_eq (T:=T) (U:=U)).

Next Obligation. 
Proof.
  rename x into f, y into g, z into h, X into H, X0 into H'. 
  exists (composition [H] [H']).
  rename H into α. rename H' into β. 
  intro u. eapply composition. apply (eq_section α). 
  eapply composition. apply comp. apply identity.
  apply (eq_section β). eapply composition. apply assoc.
  apply comp; try apply identity. 
  eapply composition. eapply inverse. 
  apply (ExLawComp_nat _ _ _ _ u).
  apply (fun a b => nat_comp2 a b u); try apply identity .
  eapply inverse, Equiv_adjoint_comp.
Defined.

Instance Equiv_eqHom (T U :GroupoidType) : HomT1 (Equiv T U) := 
  {eq1 := Equiv_eq (T:=T) (U:=U) }.

Definition Equiv_eq2 (T U :GroupoidType) (f g : Equiv T U) : HomT (Equiv_eq f g) :=
  λ (e e' : Equiv_eq f g), [e] ~ [e'].

Instance Equiv_eq2Hom (T U :GroupoidType) : HomT2 (Equiv_eq (T:=T) (U:=U)) := 
  {eq2 := Equiv_eq2 (T:=T) (U:=U) }.

Instance Equiv2_id (T U :GroupoidType) (f g : T <~> U) : 
  Identity (Equiv_eq2 (f:=f) (g:=g)) := 
  { identity x t := identity _ }.

Program Instance Equiv2_inv (T U :GroupoidType) (f g : T <~> U) : 
  Inverse (Equiv_eq2 (f:=f) (g:=g)) :=
  { inverse X Y e t := inverse (e t) }.

Program Instance Equiv2_comp (T U :GroupoidType) (f g : T <~> U) : 
  Composition (Equiv_eq2 (f:=f) (g:=g)) :=
  { composition X Y Z e e' t := composition (e t) (e' t) }.

Program Instance Equiv2_equiv (T U :GroupoidType) (f g : T <~> U) : 
  Equivalence (Equiv_eq2 (f:=f) (g:=g)).

Program Instance Equiv_eq_cat T U : Category (T <~> U).
Next Obligation. intro t. destruct f. apply id_R. Defined.
Next Obligation. intro t. destruct f; apply id_L. Defined.
Next Obligation. intro t. destruct f, g, h. apply assoc. Defined.
Next Obligation. 
  intro t. destruct f, g, f', g'. 
  apply comp. apply X. apply X0 . 
Defined.

Program Instance Equiv_eq_grp T U : Groupoid (T <~> U).
Next Obligation. intro t. destruct f; apply inv_R. Defined.
Next Obligation. intro t. destruct f; apply inv_L. Defined.
Next Obligation. intro t. destruct f, f'. apply inv. exact (X t). Defined.

Program Instance Equiv_eq2_cat (T U :GroupoidType) (f g : T <~> U) : 
  Equivalence (Equiv_eq2 (f:=f) (g:=g)).

Definition section_comp_l (X Y Z : GroupoidType) 
           (f : X <~> Y) (g : Y <~> Z) (z : [Z]) :=
  (section (g ° f) @ z).

Lemma section_comp (X Y Z : GroupoidType) 
      (f : X <~> Y) (g : Y <~> Z) (z : [Z]) :
  section_comp_l f g z ~ (section g @ z) ° map [g] (section f @ (adjoint g @ z)).
Proof.  
  unfold section_comp_l. simpl. simpl_id_bi'.
Defined.

Definition retraction_comp_l (X Y Z : GroupoidType) 
           (f : X <~> Y) (g : Y <~> Z) (z : [X]) :=
  retraction (g ° f) @ z.

Lemma retraction_comp X Y Z (f : X <~> Y) (g : Y <~> Z) z :
  retraction_comp_l f g z ~ 
  [retraction f] z ° map (adjoint f) ([retraction g] ([f] @ z)).
Proof. 
  unfold retraction_comp_l.
  simpl. simpl_id_bi'.
Defined.

Lemma Equiv_adjoint_idR X Y (f : X <~> Y)
      (H := nat_id_R [f]:[f ° identity X] ~1 [f]) (y : [Y])
      (e := Equiv_adjoint H @ y)
      (e':= identity (adjoint f) @ y) :
  e ~ e'.
(* Lemma Equiv_adjoint_idR X Y (f : X <~> Y) *)
(*       (H := nat_id_R [f]:[f ° identity X] ~1 [f]) (y : [Y]) : *)
(*   Equiv_adjoint H @ y ~ identity (adjoint f) @ y. *)
  eapply composition. apply Equiv_adjoint_simpl. simpl.
  unfold id, _Equiv_comp_obligation_1.
  simpl_id'. simpl_id'. simpl. apply (triangle_inv' f).
Defined.

Lemma Equiv_adjoint_idL X Y (f : X <~> Y) 
      (H := (nat_id_L [f]:[identity _°f] ~1 [f])) (y : [Y])
      (e := Equiv_adjoint H @ y)
      (e':= identity (adjoint f) @ y):
   e ~ e'.
Proof.
  eapply composition. apply Equiv_adjoint_simpl. simpl.
  unfold id, _Equiv_comp_obligation_1.
  simpl_id'. apply (triangle_inv' f).
Defined.

Instance EquivHom : HomT1 GroupoidType := {eq1 := Equiv}.

Instance Equiv_eqHom' : HomT2 eq1 := {eq2 := Equiv_eq}.

Definition Equiv_adjoint_assoc (X Y Z W : GroupoidType)
        (f : X <~> Y) (g : Y <~> Z) (h : Z <~> W) (w:[W]) 
        (H := (nat_assoc [f] [g] [h] : [(h ° g) °f] ~1 [h ° (g ° f)])) : 
    (Equiv_adjoint H @ w) ~2 (identity (adjoint ((h ° g) °f)) @ w).
Proof.
  simpl. eapply composition. apply (Equiv_adjoint_simpl _ _ H w). simpl.
  simpl_id'.
  eapply composition. apply comp. eapply composition. eapply inverse.
  apply comp_inv. apply comp. eapply composition. eapply inverse.
  apply comp_inv. apply comp. apply identity.
  eapply composition. eapply inverse. apply map_inv.
  eapply (map2 (adjoint f)). apply identity.
  eapply composition. eapply inverse. simpl.
  apply map_inv.
  eapply (map2 (adjoint f)).
  eapply composition. eapply inverse. apply map_inv.
  eapply (map2 (adjoint g)). apply identity. apply identity.
  eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity.
  eapply composition. eapply inverse. apply (map_comp (adjoint f)).
  eapply _map2. eapply composition. eapply inverse. apply (map_comp (adjoint g)).
  eapply _map2. eapply composition. apply comp. apply identity. eapply composition.
  apply _map_comp.
  apply comp. apply identity. apply _map_comp.
  eapply composition. apply assoc. eapply composition. apply comp.
  eapply inverse.
  (* The anotation is necessary as typeclass resolution  *)
  (*    is run only after unification *)
  apply (α_map (@inverse _ _ (nat_inv Z Z) _ _ (retraction h))).
  apply identity.
  eapply composition. apply assoc. eapply composition. apply comp.
  eapply composition. eapply inverse. apply assoc.  apply comp.
  apply identity.   eapply inverse.
  apply (α_map (inverse (Inverse:=nat_inv Z Z) (retraction h))).
  apply identity.
  eapply composition. eapply inverse. apply assoc. eapply composition. apply comp.
  apply identity. eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp.
  apply identity. apply (triangle_inv' h). apply id_L. apply identity.
  simpl. unfold id.
  eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity.
  eapply composition. eapply inverse. apply _map_comp.
  eapply _map2. eapply composition. apply comp. apply identity.
  apply _map_comp.
  eapply composition. apply assoc. eapply composition. apply comp.
  eapply inverse.
  apply (α_map (@inverse _ _ (nat_inv _ _) _ _ (retraction g))). apply identity.
  eapply composition. eapply inverse. apply assoc. eapply composition. apply comp.
  apply identity. apply (triangle_inv' g). apply id_L.
  apply (triangle_inv' f).
Defined.

Definition Equiv_adjoint_comp' (X Y Z : GroupoidType)
        (f f': X <~> Y) (g g': Y <~> Z) (e : f ~ f') (e' : g ~ g')
        (H := Equiv_adjoint (e' .1 °' e .1 : [g ° f] ~1 [g' ° f'])) :
  H ~ nat_comp' (Equiv_adjoint (e' .1)) ((Equiv_adjoint (e.1))).  
  intro b. eapply composition. apply Equiv_adjoint_simpl. apply inverse.
  eapply composition. apply comp. apply Equiv_adjoint_simpl.
  eapply (map2 (adjoint f')). apply Equiv_adjoint_simpl. simpl.
  simpl_id_bi'.
  eapply composition. apply comp. eapply inverse. apply comp_inv.
  apply identity. eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity. 
  eapply composition. apply comp. eapply inverse. apply (map_inv (adjoint f')). 
  eapply identity. eapply inverse. apply (map_comp (adjoint f')). apply inverse.
  eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity. 
  eapply inverse. apply (map_comp (adjoint f')). 
  apply comp; try apply identity. apply (map2 (adjoint f')). apply inverse.
  eapply composition. apply comp. apply identity.
  apply (map_comp (adjoint g')). eapply composition. apply assoc.
  eapply composition. apply comp. eapply composition.
  apply comp. apply identity. eapply composition. apply (map_inv (adjoint g')).
  eapply composition. eapply inv. apply (map_comp (adjoint g')). 
  eapply inverse. apply comp_inv. eapply composition. apply assoc.
  apply comp. eapply composition. apply comp_inv. 
  eapply composition. eapply inv. apply (retraction g').2. simpl.
  eapply inverse. apply comp_inv. apply identity. apply identity.
  eapply composition. apply comp. 
  eapply inverse. apply assoc. apply identity.
  eapply composition. eapply inverse. apply assoc. apply inverse.
  eapply composition. eapply inverse. apply assoc. apply comp; try apply identity.
  eapply composition. apply assoc. eapply composition. apply comp. apply identity.
  apply (map_comp (adjoint g')). eapply composition. apply assoc.
  apply inverse. eapply composition. apply comp. apply identity. 
  apply (map_comp (adjoint g')). eapply composition. apply assoc.
  apply comp; try apply identity. eapply composition.
  eapply inverse. apply assoc. eapply composition.
  apply comp. apply identity.
  eapply composition. apply comp. eapply inverse. apply (map_inv (adjoint g')). 
  apply identity. eapply composition. eapply inverse. apply (map_comp (adjoint g')).
  eapply composition. eapply (map2 (adjoint g')). eapply inverse. 
  pose ((e'^-1).1.2). simpl in n. apply n. 
  apply (map_comp (adjoint g')). eapply composition. apply assoc.
  apply comp; try apply identity.
  eapply inverse. pose ((retraction g')^-1).2.
  simpl in n. apply n. 
Defined.

Program Instance Equiv_Equiv_eq T U : Equivalence (Equiv_eq (T:=T) (U:=U)).

Program Instance Equiv_cat : Category GroupoidType. 
Next Obligation. 
  set (H := nat_id_R [f]). exists H. 
  intro.
  eapply composition. apply section_comp.
  eapply composition. apply comp. apply (map_id [f]). apply identity.
  eapply inverse. eapply composition. apply comp.
  eapply composition. apply id_R. apply identity. apply identity.
  eapply composition. apply comp. eapply composition. eapply (map2 [f]).
  apply Equiv_adjoint_idR. simpl. apply (map_id [f]). apply identity. 
  apply identity.
Defined.

Next Obligation. 
  set (H := nat_id_L [f]). exists H. 
  intro. simpl. simpl_id_bi'.
  eapply composition. apply comp. eapply (map2 [f]).
  apply Equiv_adjoint_idL. apply identity. 
  eapply composition; try apply id_R. apply comp; [idtac | apply identity].
  apply (map_id [f]).
Defined.
Next Obligation. 
  exists (nat_assoc [f] [g] [h]).
  intro. simpl.
  simpl_id_bi'.
  eapply composition. apply assoc. eapply inverse.
  eapply composition. apply assoc. apply comp; [idtac |
                                                apply identity].
  eapply inverse.
  eapply composition. apply comp. apply identity.
  apply (map_comp [h]).
  eapply composition. apply assoc. apply comp; [idtac |
                                                apply identity].
  eapply composition; try apply id_R.
  apply comp; [idtac | apply identity].
  eapply composition; try apply (map_id [h]).
  apply (map2 [h]).
  eapply composition; try apply (map_id [g]).
  apply (map2 [g]).
  eapply composition; try apply (map_id [f]).
  apply (map2 [f]). exact (Equiv_adjoint_assoc f g h t).
Defined.
Next Obligation. 
  exists (nat_comp' [X] [X0]). 
  intro. simpl. simpl_id_bi'.
  apply inverse. eapply composition. eapply comp. eapply (map2 (g.1)). 
  apply (α_map X). apply (α_map X0). simpl.
  eapply composition. apply assoc. apply inverse.
  eapply composition. apply assoc. apply comp; try apply identity.
  apply inverse. eapply composition. apply assoc. 
  apply inverse. eapply composition. apply comp. apply comp.
  apply identity. eapply (map2 (g'.1)). eapply (map2 (f'.1)).
  apply Equiv_adjoint_comp'. apply identity. 
  eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity.
  eapply composition. eapply inverse. apply (map_comp (g'.1)). 
  eapply (map2 (g'.1)). eapply composition. apply comp. 
  apply (map_comp (f'.1)). apply identity. eapply composition.
  eapply inverse. apply assoc. apply comp. apply identity. 
  apply (α_map (section f')). simpl. eapply composition.
  apply comp. apply identity. apply (map_comp (g'.1)).
  eapply composition. apply assoc. eapply composition.
  apply comp. apply identity. apply (map_comp (g'.1)).
  eapply composition. apply assoc. apply comp; try apply identity.
  eapply composition. eapply inverse. apply assoc.
  eapply composition. eapply inverse. apply assoc.
  eapply composition. eapply comp. apply identity.
  eapply composition. apply comp. apply identity. 
  eapply inverse. apply (map_comp (g'.1)). 
  eapply inverse. apply (map_comp (g'.1)). 
  eapply composition. eapply inverse. apply (α_map [X0]). 
  apply comp; try apply identity.
  apply (map2 [g]). eapply composition. apply assoc.
  apply identity.
Defined.

Program Instance Equiv_grp : Groupoid GroupoidType.
Next Obligation. 
  exists (section f). 
  intro; simpl; simpl_id_bi'.
  eapply composition. apply comp. apply identity.
  exact (Equiv_adjoint_simpl (f ° inverse f) (identity y) (section f) t).
  simpl. unfold id.
  simpl_id'. eapply composition. apply assoc.
  eapply composition; try apply id_R.
  apply comp; [idtac | apply identity].
  apply inv_L.
Defined.
Next Obligation. exists (retraction f). intro. simpl.
                 simpl_id_bi'. 
                 unfold __Equiv_inv_obligation_1, __Equiv_inv_obligation_2.
                 apply comp. apply inverse. apply (triangle' f).
                 eapply composition. 
                 exact (Equiv_adjoint_simpl (f^-1 ° f) (identity x) (retraction f) t).
                 simpl. unfold id.
                 simpl_id'. 
                 unfold __Equiv_inv_obligation_1, __Equiv_inv_obligation_2.
                 eapply composition. apply assoc.
                 eapply composition; try apply id_R.
                 apply comp; [idtac | apply identity].
                 eapply composition. apply comp. apply identity. 
                 eapply (map2 (adjoint f)). apply (triangle f).
                 eapply right_simplify'.
                 eapply composition. apply assoc.
                 eapply composition. apply comp. apply inv_R.
                 apply identity. simpl_id_bi'.
                 apply inverse. eapply composition. 
                 Focus 2. apply (triangle' f). apply (map2 (adjoint f)). 
                 apply inverse. apply (triangle f). 
Defined.
Next Obligation. exists (Equiv_adjoint [X]). intro. 
                 eapply composition. apply (eq_retraction X). simpl.
                 unfold __Equiv_inv_obligation_1, __Equiv_inv_obligation_2.
                 apply comp; try apply identity.
                 apply comp; try apply identity.
                 apply (map2 (adjoint f')). 
                 apply inverse. eapply composition.
                 exact (Equiv_adjoint_simpl (f^-1) (f'^-1) _ t).
                 simpl. unfold __Equiv_inv_obligation_1, __Equiv_inv_obligation_2.
                 unfold __Equiv_inv_obligation_3.
                 eapply composition. apply comp. apply identity.
                 eapply composition. 
                 eapply (map2 [f']). eapply composition. apply comp. apply identity.
                 apply (eq_retraction X). simpl.
                 eapply composition. apply assoc. apply comp.
                 eapply composition. apply assoc.
                 eapply composition. apply comp. apply inv_R. apply identity. 
                 apply id_R. apply identity.
                 apply (map_comp [f']). eapply composition. apply assoc.
                 pose ((section f')^-1).2. simpl in n. unfold NaturalTransformation in n.
                 simpl in n.
                 eapply composition. apply comp. eapply inverse.  apply n.
                 apply identity. eapply composition. eapply inverse. apply assoc.
                 eapply composition. apply comp. apply identity.
                 eapply composition. apply comp. apply identity. 
                 eapply inverse. apply (triangle f'). apply inv_R.
                 apply id_L.
Defined.

Program Instance Equiv_eq2_equ (T U : GroupoidType) (f g : T <~> U) :
  Equivalence (Equiv_eq2 (f:=f) (g:=g)).

Program Instance Equiv_eqEquivalence T U : Equivalence (Equiv_eq (T:=T) (U:=U)).

Definition Equiv' := (λ T T' : SetoidType, [[T]] <~> [[T']]).

Program Instance EquivHom_Setoid : HomT1 SetoidType :=  {| eq1 := Equiv' |}.

Program Instance Equiv_eqHom_Setoid : HomT2 Equiv' :=
{| eq2 := fun T T' => Equiv_eq (T:=[[T]]) (U:=[[T']]) |}.

Instance _Type_id' : Identity Equiv' :=
 { identity T := (identity ([[T]]) ; _Equiv_Id) }.

Instance _Type_inv' : Inverse Equiv' :=
  { inverse T U f := (adjoint f ; _Equiv_inv f) }.

Instance _Type_comp' : Composition Equiv' :=
  { composition T U V f g := ([g] ° [f] ; _Equiv_comp f g) }.

Program Instance Equiv_cat_Setoid : Category SetoidType.
Next Obligation. exact (Equiv_cat_obligation_1 f). Defined.
Next Obligation. exact (Equiv_cat_obligation_2 f). Defined.
Next Obligation. exact (Equiv_cat_obligation_3 f g h). Defined.
Next Obligation. exact (Equiv_cat_obligation_4 X X0). Defined.

(*
Definition EquivEqEq2 (T U : GroupoidType) 
(f g : T <~> U) (α : [f] ~ [g]) (H H' : EquivEq α) :
  H = H'.
  apply path_forall. intros u. 
  apply is_Trunc_2.
Defined.
 *)

Definition Equiv'' := (λ T T' : GroupoidType, T <~> T').

Program Instance EquivHom_Groupoid : HomT1 GroupoidType :=  {| eq1 := Equiv'' |}.

Program Instance Equiv_eqHom_Groupoid : HomT2 Equiv'' :=
{| eq2 := fun T T' : GroupoidType => Equiv_eq (T:=T) (U:=T') |}.

Instance _Type_id'' : Identity Equiv'' := 
 { identity T := (identity T; _Equiv_Id) }.

Instance _Type_inv'' : Inverse Equiv'' :=
  { inverse T U f := (adjoint f ; _Equiv_inv f) }.

Instance _Type_comp'' : Composition Equiv'' :=
  { composition T U V f g := ([g] ° [f] ; _Equiv_comp f g) }.

Program Instance Equiv_cat_Groupoid : Category GroupoidType.
Next Obligation. exact (Equiv_cat_obligation_1 f). Defined.
Next Obligation. exact (Equiv_cat_obligation_2 f). Defined.
Next Obligation. exact (Equiv_cat_obligation_3 f g h). Defined.
Next Obligation. exact (Equiv_cat_obligation_4 X X0). Defined.

Program Instance Equiv_Groupoid_G : Groupoid GroupoidType. 
Next Obligation. exact (Equiv_grp_obligation_1 f). Defined.
Next Obligation. exact (Equiv_grp_obligation_2 f). Defined.
Next Obligation. exact (Equiv_grp_obligation_3 X). Defined.

Program Instance Equiv_Groupoid_S : Groupoid SetoidType. 
Next Obligation. exact (Equiv_grp_obligation_1 f). Defined.
Next Obligation. exact (Equiv_grp_obligation_2 f). Defined.
Next Obligation. exact (Equiv_grp_obligation_3 X). Defined.


(* Definition _Type : GroupoidType := (GroupoidType ; Equiv_grp). *)
Definition Type1 : GroupoidType := (GroupoidType ; Equiv_Groupoid_G).

Notation _Type := Type1.
(*end hide *)

(** We can define the pre-groupoid [_Type] of groupoids and homotopy
 equivalences.  However, groupoids together with homotopy equivalences
 do not form a groupoid but rather a 2-groupoid. As we only have a
 formalization of groupoids, this can not be expressed in our
 setting. Nevertheless, we can state that setoids (inhabitants of
 [SetoidType]) form a groupoid.  *)

Definition Type0 : GroupoidType := (SetoidType ; Equiv_Groupoid_S).

(** %\noindent% In the definition above, [Equiv_Groupoid] is a proof
that [Equiv] and [Equiv_eq] form a groupoid. It makes again use of
functional extensionality to prove contractibility of higher cells.  As
the type of pre-groupoids appears both in the term and the type, the use of
polymorphic universes is crucial here to avoid an inconsistency. *)
(* begin hide *)

Notation equiv_assoc := (@assoc _ Equiv_cat).
Notation equiv_comp  := (@comp  _ Equiv_cat).
Notation equiv_id_R  := (@id_R  _ Equiv_cat).
Notation equiv_id_L  := (@id_L  _ Equiv_cat).
Notation equiv_inv_R  := (@inv_R _ Equiv_grp).
Notation equiv_inv_L  := (@inv_L _ Equiv_grp).
Notation equiv_inv  := (@inv _ Equiv_grp).

(* Notation equiv_assoc := Equiv_cat.(assoc). *)
(* Notation equiv_comp  := Equiv_cat.(comp). *)
(* Notation equiv_id_R  := Equiv_cat.(id_R). *)
(* Notation equiv_id_L  := Equiv_cat.(id_L). *)

(* Notation equiv_inv_R  := Equiv_grp.(inv_R). *)
(* Notation equiv_inv_L  := Equiv_grp.(inv_L). *)
(* Notation equiv_inv  := Equiv_grp.(inv). *)

Ltac compose := eapply composition.

Ltac simpl_id_end := 
  match goal with
    | [ |- eq2 (?P ^-1 ° ?P) _] => compose;
       [first [apply inv_L | apply equiv_inv_L]|idtac]
    | [ |- eq2 (?P ° ?P ^-1) _] => compose;
       [first [apply inv_R | apply equiv_inv_R]|idtac]
    | [ |- eq2 (?P ° identity ?x) _] => compose;
       [first [apply id_R | apply equiv_id_R]|idtac]
    | [ |- eq2 (identity ?x ° ?P) _] => compose;
       [first [apply id_L | apply equiv_id_L]|idtac]
    | [ |- eq2 ((?P ^-1) ^-1) _] => compose;
       [first [apply inv_inv | apply (@inv_inv _Type)]|idtac]
    | [ |- eq2 ((identity ?T) ^-1) _] => compose;
       [first [apply (inv_id _ T)| apply (@inv_id _Type)]|idtac]
    | [ |- Equiv_eq (?P ^-1 ° ?P) _] => compose; [apply equiv_inv_L|idtac]
    | [ |- Equiv_eq (?P ° ?P ^-1) _] => compose; [apply equiv_inv_R|idtac]
    | [ |- Equiv_eq (?P ° identity ?x) _] => compose; [apply equiv_id_R|idtac]
    | [ |- Equiv_eq (identity ?x ° ?P) _] => compose; [apply equiv_id_L|idtac]
    | [ |- Equiv_eq ((?P ^-1) ^-1) _] => compose; [apply (@inv_inv _Type)|idtac]
    | [ |- Equiv_eq ((identity _) ^-1) _] => compose; [apply (@inv_id _Type)|idtac]
  end.

Ltac simpl_id_end_extended := first [ simpl_id_end |
                                      match goal with
                   | [ |- Equiv_eq ?e _ ] => apply (identity e)
                   | [ |- eq2 ?e _ ] => apply (identity e)
                   | [ |- _ ] => idtac
                 end].

Ltac simpl_id := first [simpl_id_end ; simpl_id |
  lazymatch goal with
    | |- context [identity _] => fail
    | |- _ => apply identity
  end|
  match goal with
    | [ |- eq2 (?P ^-1) _] =>
      eapply composition;
        [first [apply equiv_inv | apply inv] ; simpl_id | idtac]; 
        try apply identity
    | [ |- eq2 (map ?F (identity _)) _] => 
      eapply composition;
        [eapply (map_id F); simpl_id | idtac]; 
        simpl_id
    | [ |- Equiv_eq (map ?F (identity _)) _] => 
      eapply composition;
        [eapply (map_id F); simpl_id | idtac]; 
        simpl_id
    | [ |- eq2 (map ?F ?P) _] => 
      first [eapply composition;
              [eapply (map2 F); simpl_id | idtac]; 
              [apply identity | idtac] | 
             (eapply composition;
                              [eapply (map2 F); simpl_id | idtac];instantiate);
             first [match goal with
              | [ |- eq2 (map ?G ?H) _] => constr_eq (map F P) (map G H) end | 
                    simpl_id] |idtac]
    | [ |- Equiv_eq (map ?F ?P) _] => 
      first [eapply composition;
              [eapply (map2 F); simpl_id | idtac]; 
              [apply identity | idtac] | 
             (eapply composition;
                              [eapply (map2 F); simpl_id | idtac];instantiate);
             first [match goal with
              | [ |- Equiv_eq (map ?G ?H) _] => constr_eq (map F P) (map G H) end | 
                    simpl_id] |idtac]
    | [ |- Equiv_eq (?P ^-1) _] =>
      eapply composition;
        [apply equiv_inv; simpl_id | idtac]; 
        try apply identity
    | [ |- Equiv_eq (?Q ° ?P) _] =>
      eapply composition;
        [apply equiv_comp ; simpl_id | idtac];
        simpl_id_end_extended
    | [ |- Equiv_eq ?e _ ] => apply (identity e)
    | [ |- eq2 (?Q ° ?P) _] =>
      eapply composition;
        [first [apply comp |
                apply equiv_comp] ; simpl_id | idtac];
        simpl_id_end_extended
    | [ |- eq2 ?e _ ] => first [has_evar e; idtac | apply (identity e)]
    | [ |- _ ] => idtac
  end].


Ltac simpl_id_bi := simpl_id; eapply inverse; simpl_id.

Definition Fun_Type_Groupoid (T U : [Type1]) := T ---> U.

Program Instance comp_funG : Composition Fun_Type_Groupoid :=
  { composition x y z X X0 := (λ x, X0 @ (X @ x) ; arrow_comp _ _ _ _ _) }.

Instance id_funG : Identity Fun_Type_Groupoid :=
  { identity x := (id (A:=[x]) ; arrow_id _) }.

Infix "--->" := Fun_Type_Groupoid (at level 55).
Infix "-G->" := Fun_Type_Groupoid (at level 55). 

Instance _Fun_Groupoid (T U : [Type1]) : Groupoid (T -G-> U).
Next Obligation. intro t. apply inv_R. Defined.
Next Obligation. intro t. apply inv_L. Defined.
Next Obligation. intro t. apply inv. exact (X t). Defined.

(*
Instance _Fun_Groupoid (T U : [Type1]) : Groupoid (T -G-> U).
Next Obligation. 
  apply (@contr_equiv _ _ _ (isequiv_inverse (isequiv_apD10 _ E E'))).
  apply contr_forall. intros z.
  apply (@is_Trunc_2 _ _ _ _ (e @ z) (e' @ z)).
Defined.

 *)

Definition Fun_Groupoid (T U : [Type1]) := (T -G-> U; _Fun_Groupoid T U) : GroupoidType.

Infix "-||->" := Fun_Groupoid (at level 90). 


(* Program Instance comp_fun_Setoid : Composition Fun_Type_Setoid := *)
(*   { composition x y z X X0 := (λ x, X0 @ (X @ x) ; _) }. *)

(* Program Instance id_fun_Setoid : Identity Fun_Type_Setoid := *)
(*   { identity x := (id (A:=[x]) ; arrow_id _) }. *)


(* end hide *)
(** ** Rewriting in homotopy type theory
  %\label{sec:rew}%

  When considering a dependent family [F] of type [[A --> _Type]], the [_map] function
  provides a homotopy equivalence between [F @ x] and [F @ y] for any [x]
  and [y] such that [x ~1 y]. The underlying map of homotopy equivalence
  can hence be used to cast any term of type [[F @ x]] to [[F @ y]].
*)

Definition transport A (F:[A --> _Type]) {x y:[A]} (e:x ~1 y) 
  : (F @ x) ---> (F @ y) := [map F e].

(** Using compatibility on [_map], we can reason on different transport paths.  
  Intuitively, any two transport maps with the same domain
  and codomain should be the same up to homotopy. As we only consider
  groupoids, there is only one relevant level of compatibilities,
  higher compatibilities are trivial. [transport_eq] is an example of a
  derivable equality between two transport maps, when the proofs
  relating [x] and [y] are equal.  *)

Definition transport_eq A (F:[A --> _Type]) {x y:[A]} {e e':x ~1 y} (H:e ~ e') 
  : transport F e ~1 transport F e' := [map2 F H].

(** %\noindent% In the text, 
  we also use [transport_id], [transport_comp] and [transport_map] for compatibilities with identities, composition and for the functoriality of [transport]. *)

(* begin hide *)

Definition transport_map A {x y} (F: [A --> _Type]) 
  {p q : [F @ x]} (e : x ~1 y) (H : p ~1 q) : 
  (transport F e) @ p ~1 (transport F e) @ q :=
  map [map F e] H.

Definition transport_comp A {x y z : [A]} (F: [A --> _Type])
  (e : x ~1 y) (e' : y ~1 z) : 
  transport F (e' ° e) ~1 transport F e' ° transport F e :=  
  [map_comp F e e'].

Definition transport_id A (F : [A --> _Type]) {x : [A]}
  : transport F (identity x) ~1 identity _ := 
  [map_id F].

Definition transport_inv A (x : [A]) (F: [A --> _Type]) 
  (y : [A]) (e : x ~1 y) : transport F (inverse e) ° transport F e ~1 identity _. 
Proof. 
  eapply composition. eapply inverse. exact (transport_comp F e (e^-1)). auto.
  eapply composition. exact (transport_eq _ (inv_L _ _ e)).
  apply transport_id. 
Defined.

(* Definition Trunc_2 (T:GroupoidType) (x y : [T]) *)
(*   (e e' : x ~1 y) (E E' : e ~2 e') : Contr (E = E') := *)
(*   is_Trunc_2 x y e e' E E'. *)

(* Definition eq_is_eq2 (T:[Type0]) {x y : [T]} *)
(*   (e e' : x ~1 y) (E : e = e') : e ~2 e'. *)
(*   destruct E. apply identity. *)
(* Defined. *)

(* Definition eq_is_eq2_Type0 {x y : [Type0]} *)
(*   (e e' : x ~1 y)  (E E' : e ~2 e') (H : E = E') : E ~2 E'. *)
(*   destruct H. apply identity. *)
(* Defined. *)

(* Ltac trunc_eq := match goal with *)
(*                      | [ |- ?e ~ ?e'] => *)
(*                        let H := fresh in *)
(*                        let H':=fresh in  *)
(*                        set(H':=e) in *; clearbody H'; *)
(*                        apply (eq_is_eq2_Type0 (@center _ (Trunc_2 (Type0) _ _ _ _ H' e')))                   end. *)
       
Definition Trunc_1 (T:[Type0]) (x y : [T])
  (e e' : x ~1 y)  : e ~ e' :=
  is_Trunc_1 x y e e' .

Ltac trunc1_eq :=   match goal with
    | [ |- ?e ~ ?e'] =>
      let X := fresh in
      let X':=fresh in
      set(X:=e) in *;
      set(X':=e') in *;
      let H := fresh in
      assert (H:=@HoTT_light.center _ (Trunc_1 _ _ _ X X'));
      try ((destruct H; apply identity)
             || (simpl in *; destruct H; apply identity))    
  end. 


(* cleaner but slower version ... *)
(* Ltac trunc1_eq :=   match goal with *)
(*     | [ |- ?e ~ ?e'] => *)
(*       exact (HoTT_light.transport (fun X => e ~ X) *)
(*                                   (@HoTT_light.center _ (Trunc_1 _ _ _ e e')) *)
(*                                   (identity e)) *)
(*   end.  *)


(* Ltac trunc1_eq_expl T :=   match goal with *)
(*     | [ |- ?e ~ ?e'] => *)
(*       let X := fresh in *)
(*       let X':=fresh in *)
(*       set(X:=e) in *; *)
(*       set(X':=e') in *; *)
(*       apply (eq_is_eq2 T (@HoTT_light.center _ (Trunc_1 _ _ _ X X'))) *)
(*   end. *)

Ltac trunc_eq := intro; apply Trunc_1.

Lemma map2_id : forall T (f : [T --> Type0]) {x y:[T]} (e: x ~1 y), 
                  map2 f (identity e) ~2 identity (map f e).
Proof. intros. pose (identity (map f e)). trunc_eq. Defined.

Lemma map2_comp : forall T (f : [T --> Type0]) {x y:[T]} (e e' e'':x ~1 y) 
                       (E:e ~2 e') (E':e'~2 e''),
                    map2 f (E' ° E) ~2 map2 f E' ° map2 f E.
Proof. intros. trunc_eq. Defined.

Lemma map2_id_L : ∀ T (f : [T --> Type0]) {x y : [T]} (e:x ~1 y),
  map2 f (id_L' e) ~2
  id_L' (map f e) ° (identity (map f e) ** map_id f) ° map_comp f _ _. 
Proof. intros. trunc_eq. Defined.

Lemma map2_id_R : ∀ T (f : [T --> Type0]) {x y : [T]} (e:x ~1 y),
  map2 f (id_R' e) ~2 
  id_R' (map f e) ° (map_id f ** identity (map f e)) ° map_comp f _ _.
Proof. intros. trunc_eq. Defined.

Definition assoc'' {T} {Hom1 : HomT1 T} {Hom2: HomT2 eq1} {Category} 
           {x y z w : T} {e e' e''} := 
  assoc (Category := Category) x y z w e e' e''.

Lemma map2_assoc : ∀ T (f : [T --> Type0]) {x y z w : [T]} 
                     (e:x ~1 y) (e':y ~1 z) (e'':z ~1 w),
  assoc'' ° (identity _ ** map_comp f e' e'')  ° map_comp f e (e'' ° e')  ~
  (map_comp f _ _ ** identity _) ° map_comp f (e' ° e) e'' ° map2 f assoc''.
Proof. intros. trunc_eq. Defined.

Lemma map2_comp' : ∀ T (f : [T --> Type0]) {x y z : [T]} 
                     (e e':x ~1 y) (g g':y ~1 z) 
                     (E : e ~2 e') (E' : g ~2 g'),
  map_comp f _ _ ° map2 f (comp _ _ _ _ _ _ _ E E') ~ 
  comp _ _ _ _ _ _ _ (map2 f E) (map2 f E') ° map_comp f _ _.
Proof. intros. trunc_eq. Defined.

Lemma map_inv2 {T} (f : [T --> Type0]) :
  ∀ x y (e e' : x ~1 y) (E : e ~2 e') , 
    map2 f (inverse E) ~2 inverse (map2 f E).
Proof. intros. trunc_eq. Defined.

Lemma map3 : ∀ T (f : [T --> Type0]) {x y : [T]} (e e' : x ~1 y) (E E' : e ~2 e'),
               map2 f E ~2 map2 f E'.
Proof. intros. trunc_eq. Defined.

(* end hide *)
(** ** Dependent Product 
  %\label{sec:depprod}%
  As for functions, dependent functions will be interpreted as functors. 
  But this time, the compatibilities with higher-order morphisms cannot
  be expressed as simple equalities, as some transport has to be done to 
  make those equalities typable. We call such a functor a 
  %\emph{dependent functor}%. Dependent functors are defined between a groupoid [T] and a functor [U] from [T] to [_Type] (the pre-groupoid of groupoids). [U] must be seen as a type depending on [T], or as a family of types indexed by [T]. 
*)

Class DependentFunctor T (U : [T --> _Type]) (f : ∀ t, [U @ t]) : Type := {
  _Dmap      : ∀ {x y} (e: x ~1 y), transport U e @ (f x) ~1 f y ;
  _Dmap_id   : ∀ x, _Dmap (identity x) ~ transport_id U @ (f x);
  _Dmap_comp : ∀ x y z (e : x ~1 y) (e' : y ~1 z),
   _Dmap (e' ° e) ~2 _Dmap e' ° transport_map U _ (_Dmap e) ° 
                     (transport_comp U e e' @ _);
  _Dmap2  : ∀ x y (e e': x ~1 y) (H: e ~ e'),
    _Dmap e ~ _Dmap e' ° (transport_eq U H @ (f x))}.

Definition Prod_Type T (U:[T --> _Type]) := {f : ∀ t, [U @ t] & DependentFunctor U f}.

(* begin hide *)

Hint Extern 0 (DependentFunctor _ [?f]) => exact (proj2 f) : typeclass_instances.

Notation Dmap f := (@_Dmap _ _ _ f.2 _ _).
Notation Dmap_id f := (@_Dmap_id _ _ _ f.2 _).
Notation Dmap_comp f := (@_Dmap_comp _ _ _ f.2 _ _ _).
Notation Dmap2 f := (@_Dmap2 _ _ _ f.2 _ _ _ _).

Definition right_simplify'' (T:SetoidType) (x y z: [T]) (f : x ~1 y)
           (g g' : y ~1 z)
  := right_simplify T x y z f g g' (inverse f) (inv_R _ _ _).

(* end hide *)
(** 
  Equality between dependent functors is given by dependent natural transformations
  and equality at level 2 is given by dependent modifications.
*)

(* begin hide *)

Class DNaturalTransformation T (U:[T --> _Type]) {f g: Prod_Type U} (α : ∀ t, f @ t ~1 g @ t)
 := _α_Dmap : ∀ {t t'} e, α t' ° Dmap f e ~ Dmap g e ° transport_map U e (α t).

Definition Dnat_trans T (U:[T --> _Type]) (f g: Prod_Type U)  
  := {α : ∀ t : [T], f @ t ~1 g @ t & DNaturalTransformation α}.

Hint Extern 0 (DNaturalTransformation [?f]) => exact (proj2 f) : typeclass_instances.
Notation α_Dmap f := (@_α_Dmap _ _ _ _ _ (proj2 f) _ _).

Program Instance Dnat_id T U : Identity (Dnat_trans (T:=T) (U := U)).
Next Obligation. 
  rename x into f. exists (λ t , identity (f @ t)). 
  intros. unfold transport_map. intros t t' e. 
  eapply composition. apply id_L.
  eapply inverse. eapply composition. eapply comp.
  apply (map_id [map U e]).
  apply identity. apply id_R.
Defined.
 
Program Instance Dnat_inv T U : Inverse (Dnat_trans (T:=T) (U := U)).
Next Obligation. 
  rename x into f, y into g, X into  H. 
  exists (λ t , inverse (H @ t)).
  intros. unfold transport_map. destruct H as [H Hmap]. simpl in *.
  intros t t' e.
  eapply inverse. unfold transport_map in Hmap. eapply right_simplify'.
  eapply composition. apply assoc.
  eapply composition. apply comp.
  eapply composition. apply comp. apply identity. apply (map_inv [map U e]).
  apply inv_L. apply identity.
  eapply composition. apply id_R.
  eapply inverse. eapply composition.
  eapply composition. apply assoc.
  eapply composition. apply comp. eapply inverse; apply Hmap. apply identity.
  eapply composition. eapply inverse.  apply assoc.
  apply comp. apply identity. apply inv_L.
  apply id_L.
Defined.

Program Instance Dnat_comp T (U:[T --> _Type]) : 
  Composition (Dnat_trans (U := U)).
Next Obligation. 
  rename x into f, y into g, z into h, X into H, X0 into H'. 
  exists (λ t , composition (H @ t) (H' @ t)).
  intros. unfold transport_map. intros t t' e. eapply inverse.
  eapply composition. apply comp.
  apply (map_comp [map U e]).
  apply identity.
  eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity.
  eapply inverse. apply (Π2 H').
  eapply composition. apply assoc.
  eapply composition. apply comp. eapply inverse, (Π2 H). apply identity.
  eapply composition. eapply inverse.  apply assoc. apply identity.
Defined.

Program Instance Dnat_transHom T (U:[T --> _Type]) : HomT1 (Prod_Type U) := 
  {eq1 := Dnat_trans (T:=T) (U:=U)}.

Definition Dmodification T U (f g : Prod_Type U) : HomT (f ~1 g)
  := λ α β , ∀ t : [T], α @ t ~ β @ t.

(* end hide *)

(* begin hide *)

Arguments Dmodification [T] [U] f g _ _.

Instance DmodificationHom T U : HomT2 eq1 :=
  {eq2 := @Dmodification T U}.

Instance Dnat2_id T (U:[T --> _Type]) (f g : Prod_Type U) :
  Identity (Dmodification f g) 
 := { identity x t := identity _ }.

Instance Dnat2_inv T (U:[T --> _Type]) (f g : Prod_Type U) :
  Inverse (Dmodification f g)  :=
  { inverse X Y f x := inverse (f x) }.

Instance Dnat2_comp T (U:[T --> _Type]) (f g : Prod_Type U) :
  Composition (Dmodification f g) :=
  { composition X Y Z f g x := composition (f x) (g x) }.

Instance Dnat2_equiv T (U:[T --> _Type]) (f g : Prod_Type U) :
  Equivalence (Dmodification f g).

Instance Dnat_trans_cat T (U:[T --> _Type]) :
  Category (Prod_Type U).
Next Obligation. intro t. apply id_R. Defined.
Next Obligation. intro t. apply id_L. Defined.
Next Obligation. intro t. apply assoc. Defined.
Next Obligation. intro t. apply comp. apply X. apply X0. Defined.

Program Instance Dnat_trans_grp T (U:[T --> _Type]) : Groupoid (Prod_Type U).
Next Obligation. intro t. apply inv_R.  Defined.
Next Obligation. intro t. apply inv_L.  Defined.
Next Obligation. intro t. apply inv. exact (X t).  Defined.

Program Instance Dmodification_equiv T (U:[T --> _Type]) (f g : Prod_Type U) :
  Equivalence (Dmodification f g).

(* end hide *)
(** %\noindent% We can now equip dependent functors with a groupoid structure
    as we have done for functors.
    We note [_Prod U] the dependent product over a family of groupoids [U].
*)

(* begin hide *)

Instance Type1_Type_ T (f: [T --> Type1]) : @Functor T _Type (λ X : [T], f @ X ) := 
  {| _map x y := map f ; 
     _map_id x := map_id f ; 
     _map_comp x y z := map_comp f;
     _map2 x y e e' := map2 f |}.

Definition Type1_Type T : [T --> Type1] -> [T --> _Type] := 
  fun f => (fun X => f @ X ; Type1_Type_ f).

(*
Program Instance prod_Groupoid (T:[Type1]) (U:[|T|g --> Type1]) : 
  Groupoid (Prod_Type (Type1_Type U)).
Next Obligation.
  apply (@contr_equiv _ _ _ (isequiv_inverse (isequiv_apD10 _ E E'))).
  apply contr_forall. intros z.
  apply (@is_Trunc_2 _ _ _ _ _ _ (E z) (E' z)).
Defined.
*)

Definition _Prod T (U:[T --> _Type]) := (Prod_Type U ; Dnat_trans_grp T U).

(* Definition Prod1 T (U:[|T|g --> Type1]) := (Prod_Type (Type1_Type U) ; prod_Groupoid T U). *)

Notation "[[ x ']]'" := (SetoidTypeToGroupoidType x) (at level 50).

Instance Type0_Type_ T (f: [T --> Type0]) : @Functor T _Type (λ X : [T], [[ f @ X]]) := 
  {| _map x y := map f ; 
     _map_id x := map_id f ; 
     _map_comp x y z := map_comp f;
     _map2 x y e e' := map2 f |}.

Definition Type0_Type T : [T --> Type0] -> [T --> _Type] := 
  fun f => (fun X => [[f @ X]] ; Type0_Type_ f).

Notation "'[[[' x ']]]'" := (Type0_Type x) (at level 50).

(* Definition map_id_Typ0 Γ (A:[Γ-->Type0]) (γ:[Γ]) (x : [A @ γ]) : [map_id (Type0_Type A)] @ x = [map_id A] @ x. *)
(*   simpl. apply eq_refl. *)
(* Defined. *)

Class DependentFunctor0 T (U : [T --> Type0]) (f : ∀ t, [U @ t]) : Type := {
  _Dmap0      : ∀ {x y} (e: x ~1 y), transport ([[[U]]]) e @ (f x) ~1 f y ;
  _Dmap_comp0 : ∀ x y z (e : x ~1 y) (e' : y ~1 z),
   _Dmap0 (e' ° e) ~2 _Dmap0 e' ° transport_map ([[[U]]]) _ (_Dmap0 e) ° 
                     (transport_comp ([[[U]]]) e e' @ _);
  _Dmap20  : ∀ x y (e e': x ~1 y) (H: e ~ e'),
    _Dmap0 e ~ _Dmap0 e' ° (transport_eq ([[[U]]]) H @ (f x))}.

Definition Prod_Type0 T (U:[T --> Type0]) := {f : ∀ t, [U @ t] & DependentFunctor0 U f}.

Hint Extern 0 (DependentFunctor0 _ [?f]) => exact (proj2 f) : typeclass_instances.

Notation Dmap0 f := (@_Dmap0 _ _ _ f.2 _ _).
Notation Dmap_comp0 f := (@_Dmap_comp0 _ _ _ f.2 _ _ _).
Notation Dmap20 f := (@_Dmap20 _ _ _ f.2 _ _ _ _).

Definition Dmap_id0 {T} {U:[T --> Type0]} (f: Prod_Type0 U) {x: [T]} :
  Dmap0 f (identity x) ~ transport_id ([[[U]]]) @ (f @ x).
Proof.
  eapply right_simplify'. eapply right_simplify'.
  eapply composition. eapply inverse. eapply (Dmap_comp0 f).
  eapply composition. eapply (Dmap20 f (id_L _ _ (identity x))).
  unfold transport_eq, transport_map, transport_comp, transport_id.
  apply inverse. eapply composition. apply comp. apply identity.
  apply (α_map [map_id ([[[U]]])]). eapply composition. apply assoc.
  apply comp; [idtac | apply identity]. apply inverse.
  eapply composition. apply (map2_id_L U).
  unfold id_L'. simpl. apply comp. apply identity.
  eapply composition. eapply id_L. eapply composition. apply id_L.
  simpl_id_bi'. 
Defined.

Instance DepFun0DepFun T (U : [T --> Type0]) (f : Prod_Type0 U) :
  DependentFunctor ([[[U]]]) f.1 :=
{| 
  _Dmap := fun x y => Dmap0 f;
  _Dmap_id := fun x => Dmap_id0 f;
  _Dmap_comp := fun x y z => Dmap_comp0 f;
  _Dmap2 := fun x y e e' => Dmap20 f
|}.

(*
Definition DNaturalTransformationEq2 T (U:[T --> Type0]) 
 {f g: Prod_Type (Type0_Type U)} (α : ∀ t : [T], f @ t ~1 g @ t)
  (H H' : DNaturalTransformation (T:=T) (U:=Type0_Type U) α):
  H = H'.
  apply path_forall. intros t. apply path_forall. intros t'.
  apply path_forall. intros E.
  apply is_Trunc_2.
Defined.
 *)


Program Instance prod_Groupoid1 T (U:[T --> Type0]) : 
  Groupoid (Prod_Type (Type0_Type U)) := Dnat_trans_grp _ _.

Program Instance Prod_setoid T (U:[T --> Type0]) : 
  Setoid (Prod_Type (Type0_Type U)).
Next Obligation.
  intro z. apply (@is_Trunc_1 _ _ _ _ (e @ z) (e' @ z)).
Defined.

(* end hide *)
(** A family of setoids can be seen as a family of groupoids using a
lifting that we abusively note [ [[[U]]] ]. We can prove that the
dependent product over a family of setoids is also a setoid. We note
[Prod0] the restriction of [_Prod] to families of setoids.  *)

(* begin hide *)

Definition Prod0 T (U:[T --> Type0]) : [Type0] := (Prod_Type ([[[U]]]); Prod_setoid T U).

(* end hide *)
(** ** Dependent sums 

%\label{sec:sigma}% In the interpretation of Σ types, we pay for the
fact that we are missing the 2-dimensional nature of [_Type]. Indeed, as
we will need rewriting in the definition of equality on Σ types,
delivering the corresponding groupoid structure requires to reason on
compatibility between rewritings, which amount to the missing
2-dimensional laws. However, as [Type0] is a groupoid, all 2-dimensional
equalities become trivial on a family of setoids, so we can define the
groupoid of Σ types over a groupoid [T] and a morphism of type [ [T -||-> Type0] ].*)

(*  This *)
(* corresponds to the fact that our source theory has restricted sums: the *)
(* first component cannot be a type itself.  *)


Definition sum_type T (U : [T --> Type0]) := {t : [T] & [U @ t]}.

(** %\noindent%
  The 1-equality between dependent pairs is given by 1-equality on the
  first and second projections, with a transport on the second
  projection on the left.
*)

Definition sum_eq T (U : [T --> Type0]) : HomT (sum_type U) := 
  λ m n, {P : [m] ~1 [n] & transport ([[[U]]]) P @ (Π2 m) ~1 Π2 n}.

(* begin hide *)

Program Instance sum_id T U : Identity (sum_eq (T:=T) (U:=U)) :=
  { identity x := (identity (Π1 x) ;transport_id (Type0_Type U) @ Π2 x) }.

Program Instance sum_inv T U: Inverse (sum_eq (T:=T) (U:=U)).
Next Obligation. 
Proof. 
  rename x into m, y into n, X into H. 
  exists (inverse [H]).
  apply (Equiv_injective (map U [H])).
  eapply composition; try exact (inverse (Π2 H)). unfold transport. 
  assert (map_inv_R : forall {T U} (U : Fun_Type T U) x y (e : x ~1 y),
                        map U e ° map U (inverse e) ~ identity (U @ y)). 
  - intros. eapply composition. apply comp. apply map_inv. 
    apply identity. apply inv_R.
  - apply ([map_inv_R T _ U _ _ _] @ (Π2 n)).
Defined.

Program Instance sum_comp T U : Composition (sum_eq (T:=T) (U:=U)).
Next Obligation. 
  rename x into m, y into n, z into p, X into H1, X0 into H2. 
  exists ([H2] ° [H1]). 
  eapply composition. 
  apply (transport_comp (Type0_Type U) [H1] [H2]).
  eapply composition; [idtac | exact (Π2 H2)].
  unfold composition. simpl. unfold transport.  
  apply (map [map U [H2] ] (Π2 H1)).
Defined.

Program Instance sum_eqHom T (U : [T --> Type0]) : HomT1 (sum_type U) := 
  {eq1 := sum_eq (T:=T) (U:=U)}.

(* end hide *)
(** %\noindent%
  In the same way, 2-equality between 1-equalities is given by projections
  and rewriting.
*)

Definition sum_eq2 T (U : [T --> Type0]) (M N : sum_type U) : HomT (M ~1 N) 
  := λ e e' , {P : [e] ~ [e'] & Π2 e ~ Π2 e' ° (transport_eq ([[[U]]]) P @ (Π2 M))}.

(* begin hide *)

Program Instance sum_eq2_id T U (M N : sum_type (T:=T) U) :
  Identity (sum_eq2 (M:=M) (N:=N)).
Next Obligation. 
  exists (identity _). (* apply setoid_irr2. *)
  eapply inverse. eapply composition.
  apply comp. apply (map2_id U [x] (Π2 M)).
  apply identity. apply id_R.
Defined.


Program Instance sum_eq2_inv T U (M N : sum_type (T:=T) U) :
  Inverse (sum_eq2 (M:=M) (N:=N)).
Next Obligation.
  exists (inverse [X]). (* apply setoid_irr2. *)
  eapply inverse. eapply composition.
  apply comp.
  
  apply (map_inv2 U _ _ _ _ [X]). apply identity.
  unfold sum_eq2 in X. unfold transport_eq in X.
  eapply (right_simplify_gen). intros. exact (Equivalence_2 x0 y0).
  apply inv_R.
  eapply composition. Focus 2. apply (Π2 X).
  eapply composition. apply assoc.
  eapply composition. apply comp. apply inv_L. apply identity.
  apply id_R.
Defined.

Program Instance sum_eq2_comp T U (M N : sum_type (T:=T) U) :
  Composition (sum_eq2 (M:=M) (N:=N)).
Next Obligation.
  exists (composition [X] [X0]). apply (setoid_irr2 _). 
Defined.

Program Instance sum_eq2Hom T (U : [T --> Type0])  : HomT2 (sum_eq (U:=U)) := 
  {eq2 := sum_eq2 (T:=T) (U:=U)}.

Program Instance sum_eq2_eq T U (M N : sum_type (T:=T) U) :
  Equivalence (sum_eq2 (M:=M) (N:=N)).

Program Instance sum_category2 T U : Category (sum_type (T:=T) U).

Next Obligation.
  exists (id_R _ _ [f]). unfold transport_eq. 
  refine (setoid_irr2 _ _ _ _ _).
Defined.

Next Obligation.
  exists (id_L _ _ [f]). unfold transport_eq. simpl.
  apply setoid_irr2.
Defined.

Next Obligation.
  exists (assoc _ _ _ _ [f] [g] [h]). simpl. 
  apply setoid_irr2.
Defined.

Next Obligation.
  exists (comp _ _ _ _ _ _ _ [X] [X0]). simpl.
  apply setoid_irr2.
Defined.

Lemma id_R'' (T : CatType) (x y : [T]) (f g : x ~1 y) : 
  f ~2 g -> f ° identity x ~2 g.
Proof. intros. eapply composition. apply id_R'. apply X. Defined.

Program Instance sum_groupoidP T (U : [T --> Type0]) :
  Groupoid (sum_type U).
Next Obligation. exists (inv_R _ _ _). apply (setoid_irr2 _). Defined.
Next Obligation. simpl in *. exists (inv_L _ _ _). apply (setoid_irr2 _). Defined.
Next Obligation. simpl in *. exists (inv _ _ _ _ [X]). apply (setoid_irr2 _). Defined.

Program Instance sum_setoid (T : [Type0]) U : Setoid (sum_type (T:=[[T]]) U).
Next Obligation.
  refine (Build_sigma _ _ _ ).
  apply (@is_Trunc_1  _ _ _ _ _ _). 
  apply (@is_Trunc_1 _ _ _ _ _ _).
Defined.

(* Definition _Sum T (U:[T-->Type0]) : [_Type] := (sum_type U ; sum_groupoidP _ U).  *)

Definition _Sum0 T (U:[ [[T]] -->Type0]) : [Type0] := (sum_type U ; sum_setoid T U). 

Typeclasses Opaque sum_eq sum_eq2 nat_trans modification 
            Dnat_trans Dmodification Equiv_eq Equiv_eq2.

(* end hide *)

(** %\noindent% This way, we can define the groupoid [_Sum0 U] of dependent sums for any family of setoids. When [T] is a setoid, [_Sum0 U] is also a setoid.
*)
