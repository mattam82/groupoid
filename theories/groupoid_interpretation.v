(** printing ~1 $\sim_1$ *)
(** printing ~11 $\sim_1$ *)
(** printing ~ $\sim_2$ *)
(** printing ~~ $\sim_1$ *)
(** printing ~2 $\sim_2$ *)
(** printing ⋅⋅ $⋅$ *)
(** printing ⋅⋅⋅ $⋅$ ⋅⋅*)
(** printing Π1 $\pi_1$*)
(** printing Π2 $\pi_2$*)
(** printing Πi $\pi_i$*)
(** printing --> $\longrightarrow$*)
(** printing ---> $\longrightarrow$*)
(** printing ----> $\longrightarrow_\Univ$*)
(** printing -|-> $\longrightarrow$*)
(** printing -||-> $\longrightarrow$*)
(** printing β $\beta$*)
(** printing χ $\chi$*)
(** printing γ $\gamma$*)
(** printing γt $\gamma t$*)
(** printing [! $\llbracket$*)
(** printing !] $\rrbracket$*)
(** printing |- $\vdash$*)
(** printing === $\equiv$*)
(** printing @ $\star$*)
(** printing @@ $\star$*)
(** printing @@@ $\star_\Univ$*)
(** printing ° $\circ$*)
(** printing °° $\circ$*)
(** printing °°° $\circ$*)
(** printing °°°° $\circ$*)
(** printing |g $|_g$*)
(** printing |0g $|_0$*)
(** printing [[ % %*)
(** printing ]] $_{\upharpoonright s}$*)
(** printing [[[ % %*)
(** printing ]]] $_{\upharpoonright s}$*)
(** printing Category_1 $\mathclass{PreCategory}_1$*)
(** printing Category_2 $\mathclass{PreCategory}_2$*)
(** printing CategoryP $\mathsf{PreCategory}$*)
(** printing CatType $\mathbf{UCat}$*)
(** printing Category $\mathsf{O-Category}$*)
(** printing GroupoidP $\mathsf{PreGroupoid}$*)
(** printing Groupoid $\mathsf{IsType_1}$*)
(** printing Setoid $\mathsf{IsType_0}$*)
(** printing Propoid $\mathsf{IsType_{-1}}$*)
(** printing UGroupoidType $\mathsf{Type_{1^+}}$*)
(** printing GroupoidType $\cst{Type_1}$*)
(** printing SetoidType $\mathsf{Type_0}$*)
(** printing PropoidType $\mathsf{Type_{-1}}$*)
(** printing Type0 $\mathsf{Type}_{0}^1$*)
(** printing _Type $\mathsf{Type}_{1^+}^{1^+}$*)
(** printing Groupoid_1 $\mathsf{Groupoid}_1$*)
(** printing Groupoid_2 $\mathsf{Groupoid}_2$*)
(** printing Equivalence_2 $\mathsf{Equivalence}_2$*)
(** printing Hom1 $\mathsf{Hom}_1$*)
(** printing Hom2 $\mathsf{Hom}_2$*)
(** printing Hom3 $\mathsf{Hom}_3$*)
(** printing _adjoint $\mathsf{adjoint}$*)
(** printing _section $\mathsf{section}$*)
(** printing _retraction $\mathsf{retraction}$*)
(** printing _triangle $\mathsf{triangle}$*)
(** printing nat_comp' $\mathsf{comp}$*)
(** printing _α_map $\mathsf{α}_\mathsf{map}$*)
(** printing _α_Dmap $\mathsf{α}_{\mathsf{map}^\Pi}$*)
(** printing α_map $\mathsf{α}_\mathsf{map}$*)
(** printing α_Dmap $\mathsf{α}_{\mathsf{map}^\Pi}$*)
(** printing _eq_gsection $\mathsf{eq\_section}$*)
(** printing _eq_retraction $\mathsf{eq\_retraction}$*)
(** printing Prod_Type $\Pi_\mathsf{T}$*)
(** printing _Prod $\Pi$*)
(** printing _Sum $\Sigma$*)
(** printing _Sum0 $\Sigma$*)
(** printing sum_type $\Sigma_\mathsf{T}$*)
(** printing sum_eq $\Sigma_\mathsf{Eq}$*)
(** printing sum_eq2 $\Sigma_{\mathsf{Eq}_2}$*)
(** printing eq2 $\mathsf{eq}_2$*)
(** printing eq1 $\mathsf{eq}_1$*)
(** printing HomT $\mathsf{HomSet}$*)
(** printing HomT2 $\mathsf{HomSet}_2$*)
(** printing HomT1 $\mathsf{HomSet}_1$*)
(** printing id_R $\mathsf{id}_R$*)
(** printing id_L $\mathsf{id}_L$*)
(** printing inv_R $\mathsf{inv}_R$*)
(** printing inv_L $\mathsf{inv}_L$*)
(** printing ^-1 $\hspace{-1ex}^{-1}$*)
(** printing Trunc_2 $\mathsf{Trunc}_2$*)
(** printing map_id $\mathsf{map}_\mathsf{id}$*)
(** printing map_comp $\mathsf{map}_\mathsf{comp}$*)
(** printing map2 $\mathsf{map}_2$*)
(** printing _map $\mathsf{map}$*)
(** printing _map_id $\mathsf{map}_\mathsf{id}$*)
(** printing _map_comp $\mathsf{map}_\mathsf{comp}$*)
(** printing _map2 $\mathsf{map}_2$*)
(** printing map1 $\mathsf{map}_1$*)
(** printing Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing _Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing Dmap_id $\mathsf{map}^\Pi_\mathsf{id}$*)
(** printing Dmap_comp $\mathsf{map}^\Pi_\mathsf{comp}$*)
(** printing Dmap2 $\mathsf{map}^\Pi_2$*)
(** printing _Dmap_id $\mathsf{map}^\Pi_\mathsf{id}$*)
(** printing _Dmap_comp $\mathsf{map}^\Pi_\mathsf{comp}$*)
(** printing _Dmap2 $\mathsf{map}^\Pi_2$*)
(** printing Dmap1 $\mathsf{map}^\Pi_1$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DNaturalTransformation $\mathsf{NaturalTransformation}^\Pi$*)
(** printing Dnat_trans $\mathsf{nat\_trans}^\Pi$*)
(** printing Dmodification $\mathsf{modification}^\Pi$*)
(** printing sum_weakgroupoid $\Sigma_\mathsf{WG}$*)
(** printing prod_weakgroupoid $\Pi_\mathsf{WG}$*)
(** printing IrrRelGroupoid $\mathsf{IrrRelWG}$*)
(** printing Hom_irr $\mathsf{HomIrr}$*)
(** printing ↑ $\shortuparrow$*)
(** printing ⇑ $\shortuparrow$*)
(** printing ⇑⇑ $\shortuparrow$*)
(** printing LamT_1 $\mathsf{\Lambda_{comp}}$*)
(** printing LamT $\Lambda$*)
(** printing TypFam_1 $\mathsf{TypFam_{comp}}$*)
(** printing Sub_1 $\mathsf{Sub_{comp}}$*)
(** printing SubExt_1 $\mathsf{SubExt_{comp}}$*)
(** printing substF_1 $\mathsf{substF_{comp}}$*)
(** printing Var_1 $\mathsf{Var_{comp}}$*)
(** printing Prod_1 $\mathsf{Prod_{comp}}$*)
(** printing Lam_2 $\mathsf{Lam_{comp}}$*)
(** printing App_1 $\mathsf{App_{comp}}$*)
(** printing Sub_1 $\mathsf{Sub_{comp}}$*)
(** printing Pair_1 $\mathsf{Pair_{comp}}$*)
(** printing Proj1_1 $\mathsf{Proj1_{comp}}$*)
(** printing Proj2_1 $\mathsf{Proj2_{comp}}$*)
(** printing BetaT_1 $\mathsf{BetaT_{comp}}$*)
(** printing Sigma_1 $\mathsf{Sigma_{comp}}$*)
(** printing transport_id $\mathsf{transport_{id}}$*)
(** printing transport_eq $\mathsf{transport_{eq}}$*)
(** printing transport_map $\mathsf{transport_{map}}$*)
(** printing transport_comp $\mathsf{transport_{comp}}$*)
(** printing transport $\mathsf{transport}$*)
(** printing _Prod $\Pi$*)
(** printing Prod0 $\Pi_0$*)
(** printing prod_comp $\mathsf{\Pi_{comp}}$*)
(** printing prod_comp' $\mathsf{\Pi_{comp}}$*)
(** printing J_1 $\mathsf{J_{comp}}$*)
(** printing Id_1 $\mathsf{Id_{comp}}$*)
(** printing Refl_1 $\mathsf{Refl_{comp}}$*)
(** printing UId_1 $\mathsf{≡_{comp}}$*)
(** printing Equiv_Intro_1 $\mathsf{Equiv\_Intro_{comp}}$*)
(** printing Equiv_Elim_1 $\mathsf{Equiv\_Elim_{comp}}$*)
(** printing UId $≡$*)
(** printing UType $\Univ$*)
(** printing Elt $\mathsf{Tm}$*)
(* begin hide *)

Require Export Unicode.Utf8_core.
Require Import Coq.Program.Tactics.
Require Import HoTT_light.
Require Import groupoid.
Require Import fun_eq.
Require Import groupoid_interpetation_def.

Set Implicit Arguments.
Set Universe Polymorphism.
(* Set Program Mode. *)
 
Opaque Equiv_adjoint.
Opaque map_id map_inv.


(* Program Instance UTypFam_1 {Γ : Context} (A: UTyp Γ) : Functor (T := |Γ|g) (U:=_Type) (λ s : [Γ], |A @ s|g --> Type1). *)
(* Next Obligation. intros. apply fun_eqT. apply (map A X). apply identity. Defined. *)
(* Next Obligation. admit. Defined. *)
(* Next Obligation. admit. Defined. *)
(* (* Next Obligation. exists (fun_eq_map' A x y z e e'). *) *)
(* (*                  apply AllEquivEq. Defined. *) *)
(* (* Next Obligation. unfold TypFam_1_obligation_1. *) *)
(* (*                  exists (fun_eq_eq (map2 A X) (identity (identity  (|Type0|g)))). *) *)
(* (*                  apply AllEquivEq. *) *)
(* (* Defined. *) *)

(* Definition UTypFam {Γ : Context} (A: UTyp Γ) :=  *)
(*   [_Prod (λ γ, |A @ γ|g --> Type1; UTypFam_1 _)].  *)


Definition ext (Γ: Context) (T : Typ Γ) : Type := sigma (fun γ => [T @ γ]).

Definition cons {Γ: Context} {T : Typ Γ} (γ : [Γ]) (x : [T @ γ]) : ext T := (γ;x).

Definition sum_id_right {Γ} {A:Typ Γ} {γ γ' : [Γ]}
  (e : γ ~1 γ') (a' : [A @ γ']) : (cons γ (adjoint (map A e) @ a')) ~1 (cons γ' a').
exists e. apply ((section (map A e)) @ a'). 
Defined.

Definition sum_id_left {Γ: Context} {T : Typ Γ} 
        {γ : [Γ]} {x y : [T @ γ]}  (e : x ~1 y) : (cons γ x) ~1 (cons γ y)
 := (identity _ ; e ° ([map_id T] @ x)).

Definition sum_id_left_comp {Γ: Context} {T : Typ Γ}
        (γ : [Γ]) (x y z: [T @ γ])  (e: x ~1 y) (e' : y ~1 z) : 
  sum_id_left e' ° sum_id_left e ~2 sum_id_left (e' ° e).
exists (id_R _ _ _). simpl. eapply composition.  apply assoc.
eapply composition.  apply assoc. eapply inverse.
eapply composition.  apply assoc. eapply composition.  apply assoc. eapply inverse.
apply comp; try apply identity. eapply composition. apply comp. apply comp.
apply identity. apply (map_comp [map T (identity γ)]).
apply identity. eapply composition. eapply inverse. apply assoc. eapply composition.
apply comp. apply identity. eapply composition. eapply inverse. apply assoc.
apply comp. apply identity. unfold eq_rect,id. 
apply (α_map [map_id T]).
eapply composition. apply assoc. eapply composition. apply assoc. apply comp; try apply identity.
apply comp; try apply identity. 
eapply inverse. eapply composition. apply (map2_id_R _ _ x). simpl. 
eapply composition. apply comp. apply identity. eapply composition. apply id_L.  apply id_R.
apply identity.
Defined.



Definition sum_id_left_map {Γ: Context} {T : Typ Γ}
        (γ : [Γ])   (x y : [T @ γ])  (e e': x ~1 y) (H : e ~2 e') : 
  sum_id_left e ~2 sum_id_left e'.
exists (identity _). simpl. eapply inverse. eapply composition. 
apply assoc. apply comp; try apply (inverse H). 
eapply composition; try apply id_R. apply comp; try apply identity.
apply (map2_id T _ x). 
Defined.

Definition sum_id_left_right {Γ: Context} {A : Typ Γ}
 (x y : [Γ]) (e : x ~1 y) (t t' : [A @ y]) (e' : t ~1 t'):
  sum_id_left e' ° sum_id_right e t ~
  sum_id_right e t' ° sum_id_left (map (adjoint (map A e)) e').
  exists (inverse  (id_R _ _ _) ° id_L _ y e). simpl. 
  admit.
Defined.

Definition curry {Γ: Context} {T : Typ Γ} (U : TypDep T) (γ : [Γ]) :=
  λ t : [T @ γ], U @ (γ; t).

Program Instance Curry1 {Γ: Context} {T : Typ Γ}
        (U : TypDep T) (γ : [Γ]) : Functor (T:=[[T @ γ]]) (curry U γ).
Next Obligation. exact (map U (sum_id_left X)). Defined.
Next Obligation. 
  eapply composition. apply (map2 U (inverse (sum_id_left_comp _ _ _ _ e e'))).
  apply (map_comp U).
Defined.
Next Obligation.
  apply (map2 U). apply sum_id_left_map. exact X.
Defined.

(* Notation "[[ x ']]'" := (SetoidTypeToGroupoidType x) (at level 50). *)

Definition Curry {Γ: Context} {T : Typ Γ}
        (U : TypDep T) (γ : [Γ]) : Typ (T @ γ) :=
  (curry U γ ; Curry1 U γ). 


Definition UFamily {Γ: Context} (A : Typ Γ) : [ [[Γ]] --> _Type] :=
  (λ s : [Γ], [[ (A @ s) ]] -||-> Type0; TypFam_1 A).



Program Instance LamT_1 {Γ: Context} {A : Typ Γ} (B: TypDep A) : 
  DependentFunctor (UFamily A) (Curry B).
Next Obligation. exists (fun a => map B (sum_id_right e a)).
                 intros t t' X. unfold id.
                 eapply composition. eapply inverse. apply (map_comp B).
                 eapply composition. Focus 2. apply (map_comp B).
                 apply (map2 B). apply inverse, sum_id_left_right. Defined.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.
(* end hide *)
(** 
  Terms of [TypDep A] and [TypFam A] can be related using a dependent closure
  at the level of types. In the interpretation of typing judgments, this connection 
  will be used to switch between the fibration and the morphism points of view.
*)

Definition LamT {Γ: Context} {A : Typ Γ} (B: TypDep A)
  : TypFam A := (λ γ, (λ t, B @ (γ; t) ; _); LamT_1 B).

(* begin hide *)


(* end hide *)
(** 
  ** Substitutions 

  A substitution is represented by a context morphism [[Γ --> Δ]]. 
  Note that although a substitution [σ] can be composed with a dependent type [A] 
  by using composition of functors, we need to define a fresh notion of composition, 
  noted [A ⋅ σ], with the same computational content but with new universe indices 
  to avoid universe inconsistency.

  A substitution σ can be extended by an term [a: Elt (A ⋅ σ)] 
  of [A : Typ Δ].

*)
(* begin hide *)

Notation  "f '⋅⋅' σ" := (@action _ _ ActionType _ _  σ f) (at level 50).

(* Eval compute in 2. *)

Program Instance SubExt_1 {Γ Δ : Context} {A : Typ Δ} (f: [Γ -|-> Δ]) 
         (t: Elt (A ⋅⋅ f)) : 
  Functor (U := [[_Sum0 A]]) (λ s, (f @ s; t @ s)).
Next Obligation. exact (map f X; Dmap t X). Defined.
Next Obligation. exists (map_comp f e e'). simpl. 
                 eapply composition. exact (Dmap_comp t e e'). 
                 apply inverse. eapply composition. apply assoc. 
                 apply identity.
Defined.
Next Obligation. exact (map2 f X; Dmap2 t X). Defined.

(* end hide *)

Definition SubExt {Γ Δ : Context} {A : Typ Δ} (σ: [Γ -|-> Δ]) (a: Elt (A ⋅⋅ σ)) 
  : [Γ -|-> _Sum0 A ] := (λ γ, (σ @ γ; a @ γ) ; SubExt_1 _ _).

(** %\noindent% where [SubExt_1] is a proof that it is functorial. 
*)
(* begin hide *)

Arguments SubExt {Γ Δ A} σ a.

Program Instance SubExtId_1 {Γ : Context} {A : Typ Γ} (t: Elt (A)) : 
  Functor (T:=[[Γ]]) (U := [[_Sum0 A]]) (λ s , (s; t @ s)).
Next Obligation. exact (X ; Dmap t X). Defined.
Next Obligation. exists (identity _). eapply composition.
                 exact (Dmap_comp t e e'). simpl. unfold transport_eq.
                 eapply composition. Focus 2. apply comp. 
                 eapply inverse. eapply (map2_id A). apply identity. simpl.
                 simpl_id_bi.
Defined.
Next Obligation. exact (X; Dmap2 t X). Defined.

Definition SubExtId {Γ : Context} {A : Typ Γ} 
 (t: Elt A) : [Γ -|-> (_Sum0 A)] := (λ γ, (γ; t @ γ) ; SubExtId_1 _ ).

Program Definition comp_fun_depfun {T T': Context} {U : [ [[T']] --> _Type]}
        (F : [ T -|-> T' ]) (G : [_Prod U]) : [_Prod (U ⋅ F)] :=
(λ x : [T], G @ (F @ x); _).
Next Obligation. Admitted. 

Notation  "g '°°' f" := (comp_fun_depfun f g) (at level 50). 

Program Instance substF_1 {T Γ : Context} {A:Typ Γ} (F:TypFam A) (f:[T -|-> Γ]) :
  DependentFunctor (λ t : [_], ([[[A ⋅⋅ f]]] @ t) -||-> Type0; TypFam_1 (A ⋅⋅ f)) 
                       ([F °° f] : ∀ t : [T], [[(A ⋅⋅ f) @ t]] ---> Type0).
Next Obligation. exact (Dmap F (map f e)). Defined.
Next Obligation. Admitted.
Next Obligation. Admitted.
Next Obligation. Admitted.

Infix "--->" := Fun_Type_Groupoid (at level 55).

(* end hide *)

Definition substF {T Γ} {A:Typ Γ} (F:TypFam A) (σ:[T -|-> Γ]) : TypFam (A ⋅⋅ σ) 
  := ([F °° σ] : ∀ t : [T], [[[A ⋅⋅ σ]]] @ t ---> Type0; substF_1 F σ). 

(* begin hide *)

Notation  "F '°°°' σ " := (substF F σ) (at level 50).

(* end hide *)
(** A substitution [σ] can be applied to a type family [F] using the
  composition of a functor with a dependent functor. We
  abusively note all those different compositions with [°] as it is done in
  mathematics, whereas they are distinct operators in the %\Coq%
  development.
  The weakening substitution of $\Gamma, x:A \vdash$ is given by the first
  projection. *)



(* begin hide *)

Program Instance Sub_1 (Γ: Context) (T : Typ Γ)
         : Functor (T:=[[_Sum0 T]]) (U := [[Γ]]) (λ γt , [γt]).
Next Obligation. apply [X]. Defined.
Next Obligation. apply comp; apply identity. Defined.
Next Obligation. apply [X]. Defined.


Definition Sub {Γ: Context} {T : Typ Γ} : [_Sum0 T -|-> Γ] 
  :=  (λ γt:[ [[_Sum0 T]] ], [γt] ; Sub_1 _ _).

Notation "⇑ A" := (A ⋅⋅ Sub) (at level 9, t at level 9).
(* end hide *)
(**
  
  A type family [F] in [TypFam A] can be partially substituted with an
  term [a] in [Elt A], noted [F {{a}}], to get its value (a type) at
  [a]. This process is defined as [F {{a}} := (λ γ, (F @ γ) @ (a @ γ) ;
  _)] (where [_] is a proof it is functorial). Note that this
  pattern of application %\emph{up-to a context $\gamma$}% will be used
  later to defined other notions of application. Although the
  computational definitions are the same, the compatibility conditions
  are always different.  This notion of partial substitution in a type
  family enables to state that [LamT] defines a type level
  $\lambda$-abstraction.  *)
(* begin hide *)

(* Eval compute in 3. *)

Instance SubstT_1 {Γ:Context} {A:Typ Γ} (F:TypFam A) (a:Elt A) :
 Functor (λ s, (F @ s) @ (a @ s)).
Admitted.


Definition SubstT {Γ:Context} {A:Typ Γ} (F:TypFam A) (a:Elt A) : Typ Γ :=
  (λ γ, (F @ γ) @ (a @ γ) ; SubstT_1 _ _).
Obligation Tactic := idtac.


(* Instance USubstT_1 {Γ:Context} {A:UTyp Γ} (F:UTypFam A) (a:UElt A) : *)
(*  Functor (λ s, (F @ s) @ (a @ s)). *)
(* Admitted.  *)


(* Definition USubstT {Γ:Context} {A:UTyp Γ} (F:UTypFam A) (a:UElt A) : UTyp Γ := *)
(*   (λ γ, (F @ γ) @ (a @ γ) ; USubstT_1 _ _). *)

Notation  "F '{{' a '}}'" := (SubstT F a) (at level 50).

(* Notation  "F '{{{' a '}}}'" := (USubstT F a) (at level 50). *)

Instance BetaT_1 {Δ Γ : Context} {A:Typ Γ} (B:TypDep A) (σ:[Δ -|-> Γ]) (a:Elt (A ⋅⋅ σ)):
   @NaturalTransformation _ _  ((@LamT Γ A B °°° σ) {{a}})
    (B ⋅⋅ @SubExt Δ Γ A σ a) (λ t : [Δ], identity (((LamT B °°° σ) {{a}}) @ t)).
Admitted.
  (* econstructor. intros; mysimpl. eapply composition. apply equiv_id_L. *)
  (* apply inverse. eapply composition. apply equiv_id_R. *)
  (* unfold _map; simpl. unfold SubstT_1_obligation_1,groupoid.arrow_comp_obligation_1. *)
  (* unfold _map; simpl. unfold SubExt_1_obligation_1, Curry1_obligation_1. *)
  (* unfold groupoid.arrow_comp_obligation_1. *)
  (* apply inverse. eapply composition. eapply inverse. apply (map_comp B). *)
  (* apply (map2 B).   Transparent _Type _Type_comp. *)
  (* simpl; red; simpl. *)
  (* exists (id_R _ _ _). unfold transport_eq, transport_comp. mysimpl. simpl_id_bi. *)
  (* eapply composition. apply comp. apply map2_id_R. apply identity. simpl. *)
  (* simpl_id. *)
  (* unfold equiv_adjoint. simpl. apply inverse. *)
  (* eapply composition. apply assoc. eapply composition. *)
  (* apply comp. apply comp. apply identity. apply _map_comp. apply identity. *)
  (* eapply composition. eapply inverse. apply assoc. apply inverse. *)
  (* eapply composition. eapply inverse. apply assoc. *)
  (* apply comp; [apply identity | idtac]. apply inverse. *)
  (* eapply composition. eapply inverse. apply assoc. *)
  (* apply comp; [apply identity | idtac]. *)
  (* eapply composition. apply comp. *)
  (* eapply composition. apply _map_comp. apply comp.  apply map_inv. apply identity. *)
  (* apply identity. *)
  (* eapply composition. eapply inverse. apply assoc. *)
  (* eapply composition. eapply comp. apply identity. *)
  (* apply (α_map (section (map A (map σ e)))). *)
  (* eapply composition. eapply assoc. eapply composition; try apply id_R. *)
  (* apply comp; [idtac | apply identity]. *)
  (* eapply right_simplify'.   eapply composition. eapply assoc. *)
  (* eapply composition. apply comp. apply inv_L. apply identity. simpl_id_bi. *)
  (* apply inverse. apply (triangle (map A (map σ e))). *)
(* Defined. *)
(* end hide *)

Definition BetaT Δ Γ (A:Typ Γ) (B:TypDep A) (σ:[Δ -|-> Γ]) (a:Elt (A ⋅⋅ σ)) 
  : LamT B °°° σ {{a}} ~1 B ⋅⋅ (SubExt σ a) := (λ _, identity _ ; BetaT_1 _ _ _).

(* begin hide *)

Program Instance Var_1 {Γ:Context} (A:Typ Γ) :  
  DependentFunctor (Type0_Type ⇑ A) (λ t : [ [[_Sum0 A]] ] , Π2 t).
Next Obligation. intros. apply (Π2 e). Defined.
Next Obligation. admit. Defined.
Next Obligation. (* intros. unfold Var_1_obligation_1. simpl.  *)
                 (* apply comp; try apply identity. unfold transport_comp. *)
                 (* eapply composition. eapply inverse. apply id_R. *)
                 (* apply comp; try apply identity. eapply inverse.  *)
                 (* unfold transport. simpl. unfold groupoid.arrow_comp_obligation_1. *)
                 (* simpl.  *)
                 (* assert (map2 A (comp _ _ _ _ _ _ _ (identity [e]) (identity [e'])) ~ identity (map A ([e'] °[e]))).  *)
                 (* (* trunc_eq. *) *)
                 (* admit. *)
                 (* apply X. *)
  admit.
Defined.
Next Obligation. intros. apply (Π2 H). Defined.

(* end hide *)
(**

  ** Interpretation of the typing judgment
  %\label{sec:interp}%

  The typing rules of Figure %\ref{fig:emltt}% are
  interpreted in the groupoid model as described below.

  %\paragraph{\textsc{Var}.}% 

  The rule %\textsc{Var}% is given by the second projection plus a proof
  that the projection is dependently functorial. Note the explicit
  weakening of [A] in the returned type. This is because we need to
  make explicit that the context used to type [A] is extended with an
  term of type [A]. The rule of Figure %\ref{fig:emltt}% is more general 
  as it performs an implicit weakening. We do not interpret this part of 
  the rule as weakening is explicit in our model. 

*)

Definition Var {Γ} (A:Typ Γ) : Elt ⇑A := (λ t, Π2 t; Var_1 A).

(* begin hide *)

Instance Prod_1 {Γ} (A:Typ Γ) (F : TypFam A) :
  @Functor ([[Γ]]) Type0 (λ s : [Γ], Prod0 (F @ s)).
(* Next Obligation. admit. (* intros. apply (Prod_eqT F X). *) Defined. *)
(* Next Obligation. admit. (* intros. simpl. red. simpl. exists (inverse (Prod_eq_comp F e e')). *) *)
(*                  (* apply AllEquivEq. *) *)
(* Defined. *)
(* Next Obligation. admit. (* intros. simpl. red. simpl. exists (Prod_eq_map F e e' X). *) *)
(*                  (* apply AllEquivEq. *) *)
(* Defined. *)
Admitted.
(* end hide *)

(** %\paragraph{\textsc{Prod}.}% The rule %\textsc{Prod}% is interpreted
  using the dependent functor space, plus a proof that equivalent
  contexts give rise to isomorphic dependent functor spaces.  Note that
  the rule is defined on type families and not on the dependent type
  formulation because here we need a fibration point of view. *)

Definition Prod {Γ} (A:Typ Γ) (F:TypFam A) 
  : Typ Γ := (λ s, Prod0 (F @ s); Prod_1 A F).

(* begin hide *)

Program Instance App_1 {Γ} {A:Typ Γ} {F:TypFam A} (c:Elt (Prod F)) (a:Elt A) :
  DependentFunctor (Type0_Type (F {{a}})) (λ s : [Γ], [ [c] s] ([a] s)).

Next Obligation. intros. eapply composition; try apply (Dmap (c @ y) (Dmap a e)).
                 unfold transport.
                 eapply composition; try eapply
                   (map [map ([F] y) (Dmap a e)] (Dmap c e @ ([map A e] @ (a @ x)))).
                 unfold transport. simpl. (* unfold _map at 2; simpl. *)
                 (* unfold Prod_eq_1. simpl. unfold id. *)
                 (* eapply composition; try apply (α_map (Dmap F e) (Dmap a e)). *)
                 (* simpl. apply _map. (* unfold _map at 2; simpl. *) *)
                 (* unfold equiv_adjoint. *)
                 (* eapply composition. *)
                 (* apply (map_comp (F @ x) _ (map (adjoint (map A e)) (Dmap a e))). simpl. *)
                 (* apply _map. apply (Dmap (c @ x)). *) admit.
Defined.
Next Obligation. admit. Defined.
Next Obligation. admit. Defined.
Next Obligation. admit. Defined.
 
(* end hide *)
(**
  %\paragraph{\textsc{App}.}%

  The rule %\textsc{App}% is interpreted using an up-to context application 
  and a proof of dependent functoriality. We abusively note [M @@ N] the application 
  of [App].
*)

Definition App {Γ} {A:Typ Γ} {F:TypFam A} (c:Elt (Prod F)) (a:Elt A) 
  : Elt (F {{a}}) := (λ s, (c @ s) @ (a @ s); App_1 c a).

(* begin hide *)

Notation "M '@@' N" := (App M N) (at level 50).

Instance Lam_1 {Γ} {A:Typ Γ} {F:TypDep A}
  (b:Elt F) (γ:[Γ]) :
  DependentFunctor (Type0_Type ((LamT F) @ γ)) (fun t => b @ (γ ; t)).
Admitted.

Definition Lam_partial {Γ} {A:Typ Γ} {F:TypDep A}
  (b:Elt F) (γ:[Γ]) : [Prod (LamT F) @ γ] :=
 (λ t, b @ (γ ; t) ; Lam_1 _ _). 

Instance Lam_2 {Γ} {A:Typ Γ} {B:TypDep A} (b:Elt B) :
 DependentFunctor (Type0_Type (Prod (LamT B))) (Lam_partial b).
Admitted.

(* end hide *)
(**
  %\paragraph{\lrule{Lam}.}%

  Term-level $\lambda$-abstraction is defined with the same
  computational meaning as type-level $\lambda$-abstraction, but it
  differs on the proof of dependent functoriality. Note that we use
  [LamT] in the definition because we need both the fibration (for
  [Prod]) and the morphism (for [Elt B]) point of view. 
*)

Definition Lam {Γ} {A:Typ Γ} {B:TypDep A} (b:Elt B)
  : Elt (Prod (LamT B)) := (λ γ, (λ t, b @ (γ ; t) ; _); Lam_2 b).

(* begin hide *)

Instance Sigma_1 {Γ} (A:Typ Γ) (F : TypFam A) :
  @Functor ([[Γ]]) Type0 (λ s : [Γ], _Sum0 (F @ s)).
Admitted.

(* end hide *)

(**
  %\paragraph{\textsc{Sigma}, \textsc{Pair} and \textsc{Projs}.}%
  The rules for Σ types are interpreted using the 
  dependent sum [_Sum0] on setoids.  
*)

Definition Sigma {Γ} (A:Typ Γ) (F:TypFam A) 
  : Typ Γ := (λ γ: [Γ], _Sum0 (F @ γ); Sigma_1 A F). 

(* begin hide *)

Instance Pair_1 {Γ} {A:Typ Γ} {B:TypFam A} (a: Elt A) (b : Elt (B {{a}})) : 
  DependentFunctor (Type0_Type (Sigma B)) (λ γ, (a @ γ; b @ γ)).
Admitted.

(* end hide *)
(** %\noindent% Pairing and projections are obtained
  by a context lift of pairing and projection of the underlying dependent sum.
*)

(* begin hide *)

Definition Pair {Γ} {A:Typ Γ} {B:TypFam A} (a: Elt A) (b : Elt (B {{a}}))
  : Elt (Sigma B) := (λ γ, (a @ γ; b @ γ) ; Pair_1 a b).


Instance Proj1_1 {Γ} {A:Typ Γ} {B:TypFam A} (t: Elt (Sigma B)) :
DependentFunctor (Type0_Type A) (λ γ, [t @ γ]).
Admitted. 


Definition Proj1 {Γ} {A:Typ Γ} {B:TypFam A} (t: Elt (Sigma B))
  : Elt A := (λ γ, [t @ γ] ; Proj1_1 t).


Instance Proj2_1 {Γ} {A:Typ Γ} {B:TypFam A} (t: Elt (Sigma B)) :
DependentFunctor (Type0_Type (B {{Proj1 t}})) (λ γ, Π2 (t @ γ)).
Admitted. 


Definition Proj2 {Γ} {A:Typ Γ} {B:TypFam A} (t: Elt (Sigma B))
  : Elt (B {{Proj1 t}}) := (λ γ, Π2 (t @ γ); Proj2_1 t).
(* end hide *)

(**
  %\paragraph{\lrule{Conv}.}%
  It is not possible to prove in %\Coq% that the conversion rule is
  preserved because the application of this rule is implicit and
  can not be reified. Nevertheless, to witness this preservation, 
  we show that beta conversion is valid as a definitional equality
  on the first projection. As conversion is only done on 
  types and interpretation of types is always projected, this is 
  enough to guarantee that the conversion rule is also admissible.

*)

Definition Beta {Γ} {A:Typ Γ} {F:TypDep A} (b:Elt F) (a:Elt A) 
  : [Lam b @@ a] = [b °° SubExtId a] := eq_refl _.

(**
 %\noindent% where [SubExtId] is a specialization of [SubExt] with 
  the identity substitution.
*)

(* begin hide *)
(* Eval compute in 4. *)

Instance groupoid_eq1 (T:[_Type]) (a b : [T]): Groupoid (a ~1 b) :=
  IrrRelGroupoid {| eq1 := @eq2 _ _ _ a b|}.

Program Instance setoid_eq1 (T:[_Type]) (a b : [T]): Setoid (a ~1 b).
Next Obligation. intros. apply is_Trunc_2. Defined.

Program Definition Id_ {Γ} (A: Typ Γ) (a b : Elt A) (γ : [Γ]) : [Type0] :=
  (a @ γ ~1 b @ γ ; setoid_eq1 ([[[A]]] @ γ) (a@γ) (b@γ)). 

Program Instance _Id_functor {Γ} (A: Typ Γ) (a b : Elt A) (x y:[Γ]) (X : x ~1 y) : Functor (T := [[Id_ a b y]]) (U:=[[Id_ a b x]]) (fun E => Equiv_injective _ _ _ ((Dmap b X)^-1 ° E ° (Dmap a X))).
Next Obligation. intros. unfold Equiv_injective. simpl. apply comp. apply identity.
                 apply inv. apply comp. apply identity. apply (map2 (adjoint (map A X))). 
                 apply inv. apply comp. apply identity. apply left_compose'. exact X0.
                 Defined.
Next Obligation. intros. exact tt. Defined. 
Next Obligation. intros. exact tt. Defined. 

Definition Id_functor {Γ} (A: Typ Γ) (a b : Elt A) (x y:[Γ]) (X : x ~1 y) : [Id_ a b y -|-> Id_ a b x] := (_; _Id_functor _ a b x y X). 

Program Instance Id_1 {Γ} (A: Typ Γ) (a b : Elt A) : Functor (T := [[Γ]]) (U := Type0) (Id_ a b).
Next Obligation. intros. apply IsoToEquiv. exists (Id_functor a b y x (X^-1)).
                 apply (@Build_Iso_struct _ _ _ (Id_functor a b x y X)).
                 admit.
                 admit. Defined.
Next Obligation. Admitted.
Next Obligation. Admitted.

(* end hide *)
(** 
  ** Identity Types
  %\label{sec:extprinc}%
  One of the main interest of the groupoid interpretation is that it
  allows to interpret a type directed notion of equality which validates 
  the J eliminator of identity types but also various extensional principles.
  For any terms [a] and [b] of a dependent type [A:Typ Γ], we note [Id a b] the equality type
  between [a] and [b] obtained by lifting [~1] to get a type depending on [Γ].
*)

Definition Id {Γ} (A: Typ Γ) (a b : Elt A) 
  : Typ Γ := (λ γ, (a @ γ ~1 b @ γ ; _); Id_1 A a b). 

(* begin hide *)

(* Proof. *)
(*   exact ((prod_eq (T:=[[[P{{a}}]]]) (U:=[[[P{{b}}]]])  *)
(*                  (fun γ => (map (P @ γ) (e @ γ)); J_1 e P)) @ p). *)
(* Defined. *)

(* Program Instance Id_id Γ (A: Typ Γ) : @Identity _ (@Id _ A). *)
(* Next Obligation. unfold Id. intros. exact (identity x). Defined.  *)
Instance Refl_1 Γ (A: Typ Γ) (a : Elt A) :
DependentFunctor ([[[Id a a]]]) (λ γ : [Γ], identity (a @ γ)).
Admitted.
(* end hide *)

(** The introduction rule of identity types which corresponds to reflexivity is interpreted by the (lifting of) identity of the underlying setoid. *)

Definition Refl Γ (A: Typ Γ) (a : Elt A) 
  : Elt (Id a a) := (λ γ, identity (a @ γ); Refl_1 _).

(* begin hide *)


Instance prod_eq1 A (T U : [A --> _Type]) (eqTU : T ~1 U)
        (t : [_Prod T]) :
        DependentFunctor U (λ a : [A], [eqTU @ a] @ (t @ a)).
Admitted.

Instance prod_eq2 A (T U : [A-->_Type]) (eqTU : T ~1 U) :
        Functor (T := _Prod T) (U:=_Prod U) (λ t, (λ a:[A], [eqTU @ a] @ (t @ a); prod_eq1 eqTU t) : [_Prod U]).
Admitted.

Definition prod_eq A (T U : [A --> _Type]) (e:T ~1 U) : [_Prod T --> _Prod U] := (_ ; prod_eq2 e).

Definition prod_comp Γ (A: Typ Γ) (a b : Elt A) (P : TypFam A) (e:P{{a}} ~1 P{{b}}) :  [Prod0 (P{{a}}) -|-> Prod0 (P{{b}})] := @prod_eq _ ([[[P{{a}}]]]) ([[[P{{b}}]]]) e.

Definition prod_eq' A (T U : Typ A) (e:T ~1 U) : [Prod0 T -|-> Prod0 U] := @prod_eq _ ([[[T]]]) ([[[U]]]) e.

Notation "e 'with' t" := (prod_eq' t @ e) (at level 50).

(* Lemma eq_Prod_ctxt {T Γ} (A:Typ Γ) (F:TypFam A) (f: [T -|-> Γ]) : *)
(*   nat_trans ([[[ (Prod F) ]]] ⋅ f) ([[[ (Prod (F °°° f)) ]]]). *)
(*   exists (fun t => identity (_Prod ([[[[F] ([f] t)]]]))). *)
(*   intros t t' e. *)
(*   (* eapply composition. apply equiv_id_L. apply inverse. *) *)
(*   (* eapply composition. apply equiv_id_R. *) *)
(*   (* unfold _map. simpl. unfold groupoid.arrow_comp_obligation_1; simpl. *) *)
(*   (* unfold Prod_1_obligation_1. *) *)
(*   (* red. simpl. *) *)
(*   admit. *)
(* Defined. *)

(* Notation "↑ t" := (t °° Sub with eq_Prod_ctxt _ _) (at level 9, t at level 9). *)

Program Definition comp_fun_depfun0 {T T': Context} {U : [ [[T']] -||-> Type0]}
        (F : [ T -|-> T' ]) (G : [Prod0 U]) : [Prod0 (U ⋅⋅ F)] :=
(λ x : [T], G @ (F @ x); _).
Next Obligation. Admitted. 

Notation  "g '°°°°' f" := (comp_fun_depfun0 f g) (at level 50). 


Definition depEq Γ (A:Typ Γ) (a :Elt A) : Typ Γ := Sigma (LamT (Id (a °°°° Sub) (Var A))).

(* Definition BetaT2 Γ (A:Typ Γ) (a:Elt A) : LamT (Id (a °°°° Sub) (Var A)) {{a}} ~1 Id a a. *)
(* exists (fun _ => identity _). *)
(* admit. *)
(* Defined. *)

Definition BetaT2 Γ (A:Typ Γ) (a b:Elt A) : LamT (Id (a °°°° Sub) (Var A)) {{b}} ~1 Id a b.
exists (fun _ => identity _).
intros t t' e. admit. 
(* assert (nat_trans [map (LamT (Id (a °°°° Sub) (Var A)) {{b}}) e] *)
(*    [map (Id a b) e]). red. simpl. exists (identity _). *)
(* mysimpl. eapply composition. apply equiv_id_L. apply inverse. *)
(* eapply composition. apply equiv_id_R. red.  exists (identity _). simpl. *)
(* mysimpl. simpl. simpl_id_bi. admit. *)
Defined.

Definition J_Pair Γ (A:Typ Γ) (a b:Elt A) (e:Elt (Id a b)) (P:TypFam (depEq a))  
           (γ : [Γ]) : 
  Pair (prod_eq' (BetaT2 a a) ^-1 @ Refl a) @ γ ~1
  Pair (e with (inverse (BetaT2 _ _)))@ γ.
  exists (e @ γ). simpl. admit. 
  (* unfold transport, id. simpl_id. *)
  (* eapply composition. apply comp. simpl. apply inv. *)
  (* eapply composition. *)
  (* apply (eq_retraction (map_id A (x:=γ) ° map2 A (inv_id _)) (a @ γ)). *)
  (* simpl. eapply composition. apply id_L. apply identity. *)
  (* simpl. eapply composition. apply inv. apply comp. *)
  (* apply inv. eapply composition.  *)
  (* apply (eq_retraction (map_id A (x:=γ) ° map2 A (inv_id _)) (b @ γ)). *)
  (* simpl. simpl_id. eapply (map2 (adjoint (map A (identity γ) ^-1))). *)
  (* apply inv. apply comp. unfold groupoid.sum_inv_obligation_1. *)
Defined.

Instance J_1 Γ (A:Typ Γ) (a b:Elt A) (e:Elt (Id a b)) (P:TypFam (depEq a)) :
  NaturalTransformation (f:=P {{Pair (Refl a with (inverse (BetaT2 _ _)))}}) 
                        (g:=P {{Pair (e with (inverse (BetaT2 _ _)))}}) 
                        (λ γ : [Γ], map (P @ γ) (J_Pair e P γ)).
Admitted.

Notation "⇑⇑ A" := (A with (inverse (BetaT2 _ _))) (at level 9).

(* end hide *)

(** We can interpret the J eliminator of MLTT on [Id] using functoriality of [P] and of product ([prod_comp]). In the definition of J, the predicate [P] depends on the proof of equality, which is interpreted using a [Sigma] type. The functoriality of [P] is used on the term [J_Pair e P γ], which is a proof that [(a;Refl a)] is equal to [(b;e)]. The notation [⇑⇑ A] is used to convert the type of terms according to equality on [LamT]. *)

Definition J Γ (A:Typ Γ) (a b:Elt A) (P:TypFam (Sigma (LamT (Id (a °°°° Sub) (Var A)))))
               (e:Elt (Id a b)) (p:Elt (P{{Pair ⇑⇑ (Refl a)}})) 
  : Elt (P{{Pair ⇑⇑e}}) := prod_comp (λ γ, (map (P @ γ) (J_Pair e P γ)); J_1 _ _) @ p. 

(* Definition J Γ (A:Typ Γ) (a b:Elt A) (e:Elt (Id a b)) (P:TypFam A) (p:Elt (P{{a}})) *)
(*  : Elt (P{{b}}) := (prod_comp (λ γ, (map (P @ γ) (e @ γ)); J_1 _ _)) @ p.  *)


(* begin hide *)
 
(* Definition equiv_adjoint {Γ:Context} {A:Typ Γ} (a:Elt A)  *)
(*         {x y : [Γ]} (e : x ~1 y) : a @ x ~1 (adjoint (map A e)) @ (a @ y) := *)
(*   (map (adjoint (map A e)) (Dmap a e)) ° [inverse (retraction (map A e))] (a @ x). *)


(* Definition sum_id_left {Γ: Context} {T : Typ Γ}  *)
(*         {γ : [Γ]} {x y : [T @ γ]}  (e : x ~1 y) : (cons γ x) ~1 (cons γ y) *)
(*  := (identity _ ; e ° ([map_id T] @ x)). *)

(* Definition Dmap_id_adjoint {Γ} {A:Typ Γ} (F:TypFam A) {γ : [Γ]} *)
(*   {x y : [A @ γ]} (e : x ~1 y) : [Dmap F (identity γ)] y ° *)
(*           (map ([F] γ) (equiv_adjoint (Var A) (sum_id_left e))) *)
(*  ~ map ([F] γ) e. *)
(* admit. *)
(* Defined. *)

(* Definition FunExt_1_aux (Γ: Context) (A : Typ Γ) *)
(*         (F : TypDep A) (M : Elt (Prod (LamT F))) (γ : [Γ]) *)
(*         (t t' : [A @ γ]) (e : t ~1 t') : *)
(*   Dmap (M @ γ) e ° ([Dmap_id_adjoint (LamT F) e] @ ([ [M] γ] t)) ~ *)
(* App_1_obligation_1 *)
(*     (F := substF (LamT F) Sub) *)
(*     (λ a : [_Sum A], M @ [a]; *)
(*      @prod_eq1 (_Sum A) ([[[Prod (LamT F)]]] ⋅ Sub) ([[[Prod (LamT F °°° Sub)]]]) (eq_Prod_ctxt (LamT F) Sub) (M °° Sub)) (Var A) *)
(*     (γ; t) (γ; t') (sum_id_left e). *)
(* admit. Defined. *)

(* Eval compute in 5. *)

(* Definition FunExt_1 (Γ: Context) (A : Typ Γ) (F : TypDep A)  *)
(*   (M N : Elt (Prod (LamT F))) (α : ↑M @@ Var A ~1 ↑N @@ Var A) :  *)
(*   ∀ γ : [Γ], M @ γ ~1 N @ γ.  *)
(* intro. exists (fun t => α @ (γ ; t)).  *)
(* intros t t' e; simpl in *. *)
(* admit. *)
(* Defined. *)

(* Time apply H. *)
(* unfold transport_map. eapply composition. apply comp. apply identity. *)
(* eapply inverse.  *)
(* pose (HFun:= FunExt_1_aux N γ t t' e).  *)
(* cbn beta iota zeta delta -[_Type_comp curry Equiv_cat _Equiv_Id _Dmap transport_comp] in HFun. *)
(* apply  *)
(* Transparent _Type Equiv_adjoint. *)
(* exact HFun. apply identity. *)
(* unfold _map; simpl. eapply composition. apply assoc. apply inverse. *)
(* eapply composition. apply assoc. apply comp; [idtac | apply identity]. *)
(* apply inverse. apply (α_map [Dmap_id_adjoint (LamT F) e]). *)
(* Defined. *)

(** As the whole interpretation is functorial with respect to a context,
  the naturality condition required on equality between dependent
  functors can be deduced from the existence of a transformation. 
  This allows to state dependent functional extensionality. *)

(* Program Definition _FunExt (Γ: Context) (A : Typ Γ) (F : TypDep A)  *)
(*   (M N : Elt (Prod (LamT F))) (α : Id (↑M @@ Var A) (↑N @@ Var A)) : Id M N  *)
(*   := (FunExt_1 α; _). *)
(* Next Obligation. intros t t' e a. simpl. *)
(* (* eapply right_simplify'. eapply composition. apply assoc. *) *)
(* (* eapply composition. apply comp. exact (foo M). apply identity. *) *)
(* (* destruct α as [α [H]]. eapply composition. apply (H _ _ (sum_id_right e t0)). *) *)
(* (* unfold transport_map. eapply composition;[apply comp;[apply identity|]|]. *) *)
(* (* eapply inverse. apply foo. mysimpl. clear foo H. eapply composition. apply assoc. *) *)
(* (* apply inverse. eapply composition. apply assoc. apply comp; [idtac | apply identity]. *) *)
(* (* apply inverse. apply (α_map [X] (α (t; [adjoint (map A e)] t0))). *) *)
(* admit. *)
(* Defined. *)
(* (* end hide *) *)

(* Definition FunExt (Γ: Context) (A : Typ Γ) (F : TypDep A)  *)
(*   (M N : Elt (Prod (LamT F))) (α : Id (↑M @@ Var A) (↑N @@ Var A)) : Id M N := *)
(*   _FunExt α. *)

(** 
  %\noindent% where [↑M] is the weakening for terms. This rule corresponds 
  to the introduction of equality on dependent functions in %\cite{DBLP:conf/popl/LicataH12}%.
*)

(* begin hide *)
(*  exact (@_FunExt _ A F M N α).*)


(* Definition FunExt_Elim (Γ: Context) (A : Typ Γ)  *)
(*         (F : TypDep A) (M N : Elt (Prod (LamT F))) (a : Elt A) (α : M ~1 N) *)
(*         : M @@ a ~1 N @@ a. *)
(* exists (fun γ => ((α @ γ) @ (a @ γ))). econstructor. intros; simpl.  *)
(* admit. Defined. *)

(* Transparent map_id. *)

(* Definition map_id_Type0 Γ (A:[Γ --> |Type0|g]) (γ:[Γ]) (x : [A @ γ]) : [map_id (Type0_Type A)] @ x = [map_id A] @ x. *)
(*  simpl. apply eq_refl. *)
(* Defined. *)

(* Opaque map_id.  *)

(* Definition _Dmap_id {T} {U:[T --> |Type0|g]} (f: Prod_Type ([[[U]]])) {x: [T]} : *)
(*   Dmap f (identity x) ~ transport_id ([[[U]]]) @ (f @ x). *)
(* Proof. *)
(*   eapply (right_simplify'). eapply right_simplify'. *)
(*   eapply composition. eapply inverse. eapply (Dmap_comp f). *)
(*   eapply composition. eapply (Dmap2 f (id_L _ _ (identity x))). *)
(*   unfold transport_eq, transport_map, transport_comp, transport_id. *)
(*   apply inverse. eapply composition. apply comp. apply identity. *)
(*   apply (α_map [map_id ([[[U]]])]). eapply composition. apply assoc. *)
(*   apply comp; [idtac | apply identity]. apply inverse. *)
(*   eapply composition. apply (map2_id_L U).  *)
(*   simpl. unfold id. simpl_id_bi'. pose (eq:=map_id_Type0 U). case eq. intros; apply identity. *)
(* Defined. *)

(* Program Instance fun_todep_fun_2 (T: UGroupoidType) (U:[_Type]): Functor (λ _ : [T], U). *)
(* Next Obligation. intros. apply identity. Defined. *)
(* Next Obligation. intros. unfold fun_todep_fun_2_obligation_1. eapply inverse. *)
(*                  exact (@id_L _ Equiv_cat _ _ (identity U)). Defined. *)
(* Next Obligation. unfold fun_todep_fun_2_obligation_1. intros. apply identity. Defined. *)

(* Program Definition fun_todep_fun_1 T U : [T --> _Type] := *)
(*   (λ _ : [T], U; fun_todep_fun_2  _ _). *)

(* Program Instance fun_todep_fun1 T (U:[_Type]) (M : [T --> |U|g]) :  *)
(*   DependentFunctor (fun_todep_fun_1 T U) [M]. *)
(* Next Obligation. intros. apply (map M e). Defined. *)
(* Next Obligation. intros. unfold fun_todep_fun1_obligation_1, fun_todep_fun_1, fun_todep_fun_2.  *)
(*                  eapply composition. apply (map_id M). unfold transport_id.  *)
(*                  apply inverse. Transparent map_id. simpl. unfold id. simpl_id. *)
(*                  eapply composition. do 3 (apply inv). apply (inv_inv _ _ (identity (M @ x))). *)
(*                  eapply composition. apply inv. apply (inv_inv _ _ (identity (M @ x))). *)
(*                  apply (inv_id (M @x)). Opaque map_id. *)
(* Defined. *)
(* Next Obligation. unfold fun_todep_fun1_obligation_1, fun_todep_fun_1, fun_todep_fun_2. *)
(*                  intros. eapply composition. apply (map_comp M e e'). *)
(*                  eapply inverse. eapply composition. apply assoc. apply comp; try apply identity. *)
(*                  unfold id. unfold transport_map. simpl. unfold groupoid.arrow_id_obligation_1. *)
(*                  eapply composition; try apply id_R.  apply comp; try apply identity. *)
(*                  apply (inv_id (M @ x)). Defined. *)
(* Next Obligation. unfold fun_todep_fun1_obligation_1, fun_todep_fun_1, fun_todep_fun_2. *)
(*                  intros. eapply composition. apply (map2 M H). eapply inverse. apply id_R. Defined. *)

(* Definition fun_todep_fun T U (M : [T --> |U|g]) : *)
(*   [_Prod (fun_todep_fun_1 T U)] := ([M]; fun_todep_fun1 _ _ M). *)

(* Program Instance _cst_fun (A B : [Type0]) : Functor (T:=[[A]]) (U:=Type0) (fun _=> B). *)
(* Next Obligation. intros. apply identity. Defined. *)
(* Next Obligation. intros. eapply inverse. *)
(*                  exact (@id_L _ Equiv_cat _ _ (identity B)). Defined. *)
(* Next Obligation. intros. apply identity. Defined. *)

(* Program Definition cst_fun (A B : [Type0]) : [[A]] ---> Type0 := *)
(*   (λ _ , B; _cst_fun  _ _). *)

(* Instance _cst_fibration (Γ: Context) (A B : Typ Γ) : DependentFunctor (T:=|Γ|g) (λ γ,  [[ (A @ γ) ]] -||-> Type0; TypFam_1 A) (fun γ : [Γ] => cst_fun (A @ γ) (B @ γ)). *)
(* Admitted. *)
(* (* Next Obligation. intros. unfold transport, cst_fun, _cst_fun. simpl. unfold id. *) *)
(*                  red. simpl.  *)
(*                  exact (cst_fun (A @ y) (B @ x ~1 B @ y))). intros a a' X.  *)

(*                  exact (fun_todep_fun_1 _ (map B e)). intros a a' X.  *)
(*                  unfold transport, cst_fun. simpl. unfold id. red.  simpl. *)
(*                  exists (identity _). *)
(* Admitted. *)

(* Definition cst_fibration (Γ: Context) (A B : Typ Γ) : TypFam A := *)
(*   (fun γ : [Γ] => cst_fun (A @ γ) (B @ γ); _cst_fibration _ _). *)

(* Program Definition cst_fun2 (A B : [Type0]) : [[A]] --> Type0 := *)
(*   (λ _ , B; _cst_fun  _ _). *)

(* Instance prod_eq1 (T U T' U': [_Type]) (e: T ~1 T') (e' : U ~1 U') *)
(*         (t : [_Prod T]) : *)
(*         DependentFunctor U (λ a : [A], [eqTU @ a] @ (t @ a)). *)
(* Admitted. *)

(* Instance prod_eq2 (A: UGroupoidType) (T U : [A --> _Type]) (eqTU : T ~1 U) : *)
(*         Functor (U:=|_Prod U|g) (λ (t : [|_Prod T|g]), (λ a : [A], [eqTU @ a] @ (t @ a)  ; prod_eq1 eqTU t) : [_Prod U]). *)
(* Admitted. *)

Require Import HoTT_light.

Ltac trunc1_eq :=
  match goal with
    | [ |- eq2 ?e ?e'] =>
      let H:=fresh in
      pose (H:=@center _ (is_Trunc_1 _ _ e e'));
        destruct H;
        apply identity
  end. 


Program Instance set_fun_1 (Γ: Context) (A B : Typ Γ) : Functor (T := [[Γ]]) (U:=Type0) (fun γ => A @ γ -|-> B @ γ).
Next Obligation. intros. simpl. apply (fun_eqT (map A X) (map B X)). Defined.
Next Obligation. intros. unfold set_fun_1_obligation_1. (* exists (fun_eq_eq' (map _ _ _ _).  *) admit. Defined.
Next Obligation. intros. unfold set_fun_1_obligation_1. exists (fun_eq_eq (map2 A X) (map2 B X)).
                 intros f t. 
                 trunc1_eq.
Defined.

Definition set_fun (Γ: Context) (A B : Typ Γ) : Typ Γ :=
  (fun γ : [Γ] => A @ γ -|-> B @ γ; set_fun_1 Γ A B).

(* Definition set_fun (Γ: Context) (A B : Typ Γ) : Typ Γ := Prod (cst_fibration A B).  *)

Infix "---->" := set_fun (at level 55). 

Instance AppF_1 {Γ} {A B:Typ Γ} (f:Elt (A ----> B)) (a:Elt A) :
  DependentFunctor ([[[B]]]) (λ s : [Γ], (f @ s) @ (a @ s)).
Admitted.

Definition AppF {Γ} {A B:Typ Γ} (f:Elt (A ----> B)) (a:Elt A)
: Elt B := (λ s, (f @ s) @ (a @ s); AppF_1 _ _).

(* Program Instance Uset_fun_1 (Γ: Context) (A B : Typ Γ) : Functor (T := |Γ|g) (U:=Type1) (fun γ => A @ γ -||-> B @ γ). *)
(* Next Obligation. intros. simpl. apply (fun_eqT (map A X) (map B X)). Defined. *)
(* Next Obligation. intros. unfold set_fun_1_obligation_1. (* exists (fun_eq_eq' (map _ _ _ _).  *) admit. Defined. *)
(* Next Obligation. intros. unfold set_fun_1_obligation_1. exists (fun_eq_eq (map2 A X) (map2 B X)). *)
(*                  intros f t. admit. *)
(* Defined. *)

(* Definition Uset_fun (Γ: Context) (A B : Typ Γ) : Typ Γ := *)
(*   (fun γ : [Γ] => A @ γ -||-> B @ γ; Uset_fun_1 Γ A B). *)

(* Definition set_fun (Γ: Context) (A B : Typ Γ) : Typ Γ := Prod (cst_fibration A B).  *)

(* Infix "-U->" := Uset_fun (at level 55).  *)

(* Instance AppU_1 {Γ} {A B:Typ Γ} (f: Elt (A -U-> B)) (a:Elt A) : *)
(*   DependentFunctor (Type1_Type B) (λ s : [Γ], (f @ s) @ (a @ s)). *)
(* Admitted. *)

(* Definition AppU {Γ} {A B:Typ Γ} (f:Elt (A -U-> B)) (a:Elt A) *)
(* : Elt B := (λ s, (f @ s) @ (a @ s); AppU_1 _ _). *)

Program Definition ndep {Γ} (T:Context) : Typ Γ := (λ γ, T; _).
Next Obligation. intros. admit. Defined.

(* Definition UType {Γ} := ndep (Γ:=Γ) Type0. *)

Definition eq_fun_ctxt {T Γ} (A B: Typ Γ) (f: [T -|-> Γ]) :
  nat_trans ([[[A ----> B]]] ⋅ f)  ([[[A ⋅⋅ f  ----> B ⋅⋅ f]]]).
  red; simpl. exists (fun t => identity _). red. intros. 
  admit.
Defined.

Notation "e 'with' t" := (prod_eq t @ e) (at level 50).

Notation "↑ t" := (t °° Sub with eq_fun_ctxt _ _ _) (at level 9, t at level 9). 

Notation "'Forall' X" := (Prod (LamT X)) (at level 55).

Program Definition UId_ {Γ} (A B: Typ Γ) (γ : [Γ]) :[Type0].  
exists (Equiv' (A @ γ) (B @ γ)).
admit.
Defined.

Instance UId_1 {Γ} (A B: Typ Γ) : Functor (T := [[Γ]]) (U := Type0) (UId_ A B).
Admitted.

Notation "P '@@@' A" := (AppF ↑P A) (at level 50).

Infix "~11" := (Equiv') (at level 50).

(* end hide *)
(** 
  ** Universe
  %\label{sec:universe}% 
  To interpret the universe $\Univ$, we need to define its syntax and interpretation of syntax as setoids altogether. That is, $\Univ$ requires inductive-recursive definitions to be interpreted.
  As such definition are not available in %\Coq%, we cannot completely interpret $\Univ$%\footnote{The folklore coding trick to encode inductive-recursive definition using an indexed family as done in~\cite{altenkirch-mcbride-wierstra:ott-now} does not work here because it transforms an inductive-recursive Agda Set into a larger universe which is no longer a setoid.}%. Nevertheless, we present a way to interpret the identity type on $\Univ$ and Rule %\textsc{Id-Equiv-Intro}% which corresponds to the univalence axiom for $\Univ$.

   We interpret the identity type on $\Univ$ in the same way as [Id], except that it 
relates two dependent types [A] and [B] instead of terms of a dependent type.
*)

Definition UId {Γ} (A B: Typ Γ) : Typ Γ := (λ γ, (A @ γ ~11 B @ γ ; _); UId_1 A B). 

(**
 To define the notion of isomorphism, we need to define a proper notion of function (noted [A ----> B]) that does not use the restriction of [Prod] to constant type families. This is because the definition of an isomorphism involves two functions that have to be composed in both ways, which lead to universe inconsistency if we use dependent products to encode functions. We define the notion of application (noted [g @@@ f]) for this kind of functions. 
*)

Class iso_struct (Γ: Context) (A B : Typ Γ) (f : Elt (A ----> B)) := 
{ iso_adjoint : Elt (B ----> A)  ;
  iso_section : Elt (Prod (LamT (Id (iso_adjoint @@@ (f @@@ Var A)) (Var A)))) ;
  iso_retract : Elt (Prod (LamT (Id (f @@@ (iso_adjoint @@@ Var B)) (Var B))))}.

Definition iso (Γ: Context) (A B : Typ Γ) := {f : Elt (A ----> B) & iso_struct f}.
(* begin hide *)

Infix "≡" := UId (at level 55).


(* Program Definition DF (Γ: Context) (A : Typ Γ) : (Elt Type) := ([A];_). *)
(* Next Obligation. intros. admit. Defined. *)

(* Program Definition DF_1 (Γ: Context) (A: (Elt Type)) : Typ Γ  := ([A];_). *)
(* Next Obligation. intros. admit. Defined. *)

(* Notation "P '@@' A" := (DF_1 (AppU P (DF A))) (at level 50). *)

(* Definition UId {Γ} (A B: Typ Γ) : Typ Γ := Id (DF A) (DF B). *)



(* Definition UId {Γ} (A B: Typ Γ)(γ : [Γ]) : Typ Γ := Id (DF A) (DF B). *)

Definition Equiv_Intro_ (Γ: Context) (A B : Typ Γ) (e : iso A B) 
           : ∀ γ : [Γ], A @ γ ~11 B @ γ.
Proof.
  intro. apply IsoToEquiv. exists ([e] @ γ). 
  apply (@Build_Iso_struct _ _ _ (@iso_adjoint _ _ _ _ e.2 @ γ)). 
  pose ([@iso_retract _ _ _ _ e.2 @ γ]). 
  simpl in *. exists p. red. intros. simpl.
  trunc1_eq.
  pose ([@iso_section _ _ _ _ e.2 @ γ]). 
  simpl in *. exists p. red. intros. 
  trunc1_eq.
Defined.

Instance Equiv_Intro_1 (Γ: Context) (A B : Typ Γ) (e : iso A B) : 
  DependentFunctor ([[[A ≡ B]]]) (Equiv_Intro_ e).
Admitted.

(* end hide *)

(**
  Then, we can show that this definition of isomorphism corresponds to equivalence of setoids.
  Again, the only extra work is with the management of context lifting. This provides a computational 
  content to the univalence axiom restricted to setoids.
*)

Definition Equiv_Intro (Γ: Context) (A B : Typ Γ) (e : iso A B) : Elt (A ≡ B).
Proof. exact (Equiv_Intro_ e; Equiv_Intro_1 e). Defined.





(* Definition Equiv_Elim Γ (A B:Typ Γ) (e:Elt (A ≡ B)) (P:TypFam UType) (p:Elt (P {{A}})) : Elt (P{{{DF B}}}) := J e p. *)




