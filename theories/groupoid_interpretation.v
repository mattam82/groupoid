(** printing ~1 $\sim_1$ *)
(** printing ~11 $\sim_1$ *)
(** printing ~ $\sim_2$ *)
(** printing ~~ $\sim_1$ *)
(** printing ~2 $\sim_2$ *)
(** printing ⋅⋅ $⋅$ *)
(** printing ⋅⋅⋅ $⋅$ ⋅⋅*)
(** printing Π1 $\pi_1$*)
(** printing Π2 $\pi_2$*)
(** printing Πi $\pi_i$*)
(** printing --> $\longrightarrow$*)
(** printing ---> $\longrightarrow$*)
(** printing ----> $\longrightarrow_\Univ$*)
(** printing -|-> $\longrightarrow$*)
(** printing -||-> $\longrightarrow$*)
(** printing β $\beta$*)
(** printing χ $\chi$*)
(** printing γ $\gamma$*)
(** printing γt $\gamma t$*)
(** printing [! $\llbracket$*)
(** printing !] $\rrbracket$*)
(** printing |- $\vdash$*)
(** printing === $\equiv$*)
(** printing @ $\star$*)
(** printing @@ $\star$*)
(** printing @@@ $\star_\Univ$*)
(** printing ° $\circ$*)
(** printing °° $\circ$*)
(** printing °°° $\circ$*)
(** printing °°°° $\circ$*)
(** printing |g $|_g$*)
(** printing |0g $|_0$*)
(** printing [[ % %*)
(** printing ]] $_{\upharpoonright s}$*)
(** printing [[[ % %*)
(** printing ]]] $_{\upharpoonright s}$*)
(** printing Category_1 $\mathclass{PreCategory}_1$*)
(** printing Category_2 $\mathclass{PreCategory}_2$*)
(** printing CategoryP $\mathsf{PreCategory}$*)
(** printing CatType $\mathbf{UCat}$*)
(** printing Category $\mathsf{O-Category}$*)
(** printing GroupoidP $\mathsf{PreGroupoid}$*)
(** printing Groupoid $\mathsf{IsType_1}$*)
(** printing Setoid $\mathsf{IsType_0}$*)
(** printing Propoid $\mathsf{IsType_{-1}}$*)
(** printing UGroupoidType $\mathsf{Type_{1^+}}$*)
(** printing GroupoidType $\cst{Type_1}$*)
(** printing SetoidType $\mathsf{Type_0}$*)
(** printing PropoidType $\mathsf{Type_{-1}}$*)
(** printing Type0 $\mathsf{Type}_{0}^1$*)
(** printing _Type $\mathsf{Type}_{1^+}^{1^+}$*)
(** printing Groupoid_1 $\mathsf{Groupoid}_1$*)
(** printing Groupoid_2 $\mathsf{Groupoid}_2$*)
(** printing Equivalence_2 $\mathsf{Equivalence}_2$*)
(** printing Hom1 $\mathsf{Hom}_1$*)
(** printing Hom2 $\mathsf{Hom}_2$*)
(** printing Hom3 $\mathsf{Hom}_3$*)
(** printing _adjoint $\mathsf{adjoint}$*)
(** printing _section $\mathsf{section}$*)
(** printing _retraction $\mathsf{retraction}$*)
(** printing _triangle $\mathsf{triangle}$*)
(** printing nat_comp' $\mathsf{comp}$*)
(** printing _α_map $\mathsf{α}_\mathsf{map}$*)
(** printing _α_Dmap $\mathsf{α}_{\mathsf{map}^\Pi}$*)
(** printing α_map $\mathsf{α}_\mathsf{map}$*)
(** printing α_Dmap $\mathsf{α}_{\mathsf{map}^\Pi}$*)
(** printing _eq_gsection $\mathsf{eq\_section}$*)
(** printing _eq_retraction $\mathsf{eq\_retraction}$*)
(** printing Prod_Type $\Pi_\mathsf{T}$*)
(** printing _Prod $\Pi$*)
(** printing _Sum $\Sigma$*)
(** printing _Sum0 $\Sigma$*)
(** printing sum_type $\Sigma_\mathsf{T}$*)
(** printing sum_eq $\Sigma_\mathsf{Eq}$*)
(** printing sum_eq2 $\Sigma_{\mathsf{Eq}_2}$*)
(** printing eq2 $\mathsf{eq}_2$*)
(** printing eq1 $\mathsf{eq}_1$*)
(** printing HomT $\mathsf{HomSet}$*)
(** printing HomT2 $\mathsf{HomSet}_2$*)
(** printing HomT1 $\mathsf{HomSet}_1$*)
(** printing id_R $\mathsf{id}_R$*)
(** printing id_L $\mathsf{id}_L$*)
(** printing inv_R $\mathsf{inv}_R$*)
(** printing inv_L $\mathsf{inv}_L$*)
(** printing ^-1 $\hspace{-1ex}^{-1}$*)
(** printing Trunc_2 $\mathsf{Trunc}_2$*)
(** printing map_id $\mathsf{map}_\mathsf{id}$*)
(** printing map_comp $\mathsf{map}_\mathsf{comp}$*)
(** printing map2 $\mathsf{map}_2$*)
(** printing _map $\mathsf{map}$*)
(** printing _map_id $\mathsf{map}_\mathsf{id}$*)
(** printing _map_comp $\mathsf{map}_\mathsf{comp}$*)
(** printing _map2 $\mathsf{map}_2$*)
(** printing map1 $\mathsf{map}_1$*)
(** printing Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing _Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing Dmap_id $\mathsf{map}^\Pi_\mathsf{id}$*)
(** printing Dmap_comp $\mathsf{map}^\Pi_\mathsf{comp}$*)
(** printing Dmap2 $\mathsf{map}^\Pi_2$*)
(** printing _Dmap_id $\mathsf{map}^\Pi_\mathsf{id}$*)
(** printing _Dmap_comp $\mathsf{map}^\Pi_\mathsf{comp}$*)
(** printing _Dmap2 $\mathsf{map}^\Pi_2$*)
(** printing Dmap1 $\mathsf{map}^\Pi_1$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DNaturalTransformation $\mathsf{NaturalTransformation}^\Pi$*)
(** printing Dnat_trans $\mathsf{nat\_trans}^\Pi$*)
(** printing Dmodification $\mathsf{modification}^\Pi$*)
(** printing sum_weakgroupoid $\Sigma_\mathsf{WG}$*)
(** printing prod_weakgroupoid $\Pi_\mathsf{WG}$*)
(** printing IrrRelGroupoid $\mathsf{IrrRelWG}$*)
(** printing Hom_irr $\mathsf{HomIrr}$*)
(** printing ↑ $\shortuparrow$*)
(** printing ⇑ $\shortuparrow$*)
(** printing ⇑⇑ $\shortuparrow$*)
(** printing LamT_1 $\mathsf{\Lambda_{comp}}$*)
(** printing LamT $\Lambda$*)
(** printing TypFam_1 $\mathsf{TypFam_{comp}}$*)
(** printing Sub_1 $\mathsf{Sub_{comp}}$*)
(** printing SubExt_1 $\mathsf{SubExt_{comp}}$*)
(** printing substF_1 $\mathsf{substF_{comp}}$*)
(** printing Var_1 $\mathsf{Var_{comp}}$*)
(** printing Prod_1 $\mathsf{Prod_{comp}}$*)
(** printing Lam_2 $\mathsf{Lam_{comp}}$*)
(** printing App_1 $\mathsf{App_{comp}}$*)
(** printing Sub_1 $\mathsf{Sub_{comp}}$*)
(** printing Pair_1 $\mathsf{Pair_{comp}}$*)
(** printing Proj1_1 $\mathsf{Proj1_{comp}}$*)
(** printing Proj2_1 $\mathsf{Proj2_{comp}}$*)
(** printing BetaT_1 $\mathsf{BetaT_{comp}}$*)
(** printing Sigma_1 $\mathsf{Sigma_{comp}}$*)
(** printing transport_id $\mathsf{transport_{id}}$*)
(** printing transport_eq $\mathsf{transport_{eq}}$*)
(** printing transport_map $\mathsf{transport_{map}}$*)
(** printing transport_comp $\mathsf{transport_{comp}}$*)
(** printing transport $\mathsf{transport}$*)
(** printing _Prod $\Pi$*)
(** printing Prod0 $\Pi_0$*)
(** printing prod_comp $\mathsf{\Pi_{comp}}$*)
(** printing prod_comp' $\mathsf{\Pi_{comp}}$*)
(** printing J_1 $\mathsf{J_{comp}}$*)
(** printing Id_1 $\mathsf{Id_{comp}}$*)
(** printing Refl_1 $\mathsf{Refl_{comp}}$*)
(** printing UId_1 $\mathsf{≡_{comp}}$*)
(** printing Equiv_Intro_1 $\mathsf{Equiv\_Intro_{comp}}$*)
(** printing Equiv_Elim_1 $\mathsf{Equiv\_Elim_{comp}}$*)
(** printing UId $≡$*)
(** printing UType $\Univ$*)
(** printing Elt $\mathsf{Tm}$*)
(* begin hide *)

Require Export Unicode.Utf8_core.
Require Import Coq.Program.Tactics.
Add LoadPath "." as Groupoid.
Require Import Groupoid.HoTT_light.
Require Import Groupoid.groupoid.
Require Import Groupoid.fun_eq.
Require Import Groupoid.groupoid_interpretation_def.
Require Import Groupoid.Equiv_adjoint.
Require Import Groupoid.fun_depfun.
Require Import Groupoid.sum_id.
Require Import Groupoid.prod_eq.
Require Import Groupoid.sum_eq.

Set Implicit Arguments.
Set Universe Polymorphism.
(* Set Program Mode. *)
 
(* Opaque Equiv_adjoint. *)
(* Opaque map_id map_inv. *)


Definition curry {Γ: Context} {T : Typ Γ} (U : TypDep T) (γ : [Γ]) :=
  λ t : [T @ γ], U @ (γ; t).


Program Instance Curry1 {Γ: Context} {T : Typ Γ}
        (U : TypDep T) (γ : [Γ]) : Functor (T:=[[T @ γ]]) (curry U γ)
:=
  {| _map := λ (x y : [T @ γ]) X, map U (sum_id_left X)  ;
     _map_id := λ x, map_id U ° map2 U (sum_id_left_id γ x) ;
     _map_comp := λ _ _ _ e e', map_comp U (sum_id_left e) (sum_id_left e')
                              ° map2 U (sum_id_left_comp _ _ _ _ e e') ^-1 ;
     _map2 := λ _ _ _ _ X, map2 U (sum_id_left_map _ _ _ _ _ X)|}.

Definition Curry {Γ: Context} {T : Typ Γ}
        (U : TypDep T) (γ : [Γ]) : Typ (T @ γ) :=
  (curry U γ ; Curry1 U γ). 

Definition UFamily {Γ: Context} (A : Typ Γ) : [ [[Γ]] --> _Type] :=
  (λ s : [Γ], [[ (A @ s) ]] -||-> Type0; TypFam_1 A).

Lemma simpl_app {A B} {P : (A -> B) -> Type} (f : A -> B) (t : P f) x : @eq _  ((f; t) @ x) (f x).
Proof. simpl. reflexivity. Defined.

Obligation Tactic := intros.

Ltac betared :=
  repeat match goal with
      |- context C [?f @ ?t] => 
      let f' := eval hnf in f in
                             match f with
                               | (?f'; _) =>
                                 let new := context C [ f' t ] in change new; cbv beta
                             end
         end. 

Global Arguments right_simplify' : simpl never.

Program Instance LamT_1 {Γ: Context} {A : Typ Γ} (B: TypDep A) : 
  DependentFunctor (UFamily A) (Curry B).
Next Obligation. 
  exists (fun a => map B (sum_id_right e a)).
  intros t t' X. unfold id.
  eapply composition. eapply inverse. simpl. eapply (map_comp B).
  eapply composition. Focus 2. apply (map_comp B).
  apply (map2 B). apply inverse. apply sum_id_left_right. 
Defined.

Next Obligation.
  intro. apply equiv_eq_nat_trans. 
  refine [(map2 B) _]. eapply composition. Focus 2.
  apply sum_id_left_map.  
  simpl_id_bi. exists (identity _). trunc1_eq.
Defined.

Next Obligation.
  intro. apply equiv_eq_nat_trans. 
  eapply composition. Focus 2.
  eapply (@comp _ category_fun).
  apply identity. apply (map_comp B). 
  eapply composition. Focus 2.
  refine [map_comp B _ _]. refine [map2 B _]. 
  exists (inverse (id_R _ _ _)). 
  trunc1_eq.
Defined.

Next Obligation. 
Proof.
  intro. apply equiv_eq_nat_trans. 
  eapply composition. Focus 2.
  refine [map_comp B _ _]. apply (map2 B).
  exists (inverse (id_R _ _ _) ° H).  
  trunc1_eq.
Defined.

(* end hide *)
(** 
  Terms of [TypDep A] and [TypFam A] can be related using a dependent closure
  at the level of types. In the interpretation of typing judgments, this connection 
  will be used to switch between the fibration and the morphism points of view.
*)

Definition LamT {Γ: Context} {A : Typ Γ} (B: TypDep A)
  : TypFam A := (λ γ, (λ t, B @ (γ; t) ; _); LamT_1 B).

(* begin hide *)


(* end hide *)
(** 
  ** Substitutions 

  A substitution is represented by a context morphism [[Γ --> Δ]]. 
  Note that although a substitution [σ] can be composed with a dependent type [A] 
  by using composition of functors, we need to define a fresh notion of composition, 
  noted [A ⋅ σ], with the same computational content but with new universe indices 
  to avoid universe inconsistency.

  A substitution σ can be extended by a term [a: Elt (A ⋅ σ)] 
  of [A : Typ Δ].

*)
(* begin hide *)

(* Eval compute in 2. *)

Program Instance SubExt_1 {Γ Δ : Context} {A : Typ Δ} (f: [Γ -|-> Δ]) 
         (t: Elt (A ⋅⋅ f)) : 
  Functor (U := [[_Sum0 A]]) (λ s, (f @ s; t @ s)).
Next Obligation. exact (map f X; Dmap t X). Defined.
Next Obligation. exact (map_id f; Dmap_id t). Defined.
Next Obligation. exact (map_comp f e e'; (assoc' _ _ _)^-1 ° Dmap_comp t e e').
Defined.
Next Obligation. exact (map2 f X; Dmap2 t X). Defined.

(* end hide *)

Definition SubExt {Γ Δ : Context} {A : Typ Δ} (σ: [Γ -|-> Δ]) (a: Elt (A ⋅⋅ σ)) 
  : [Γ -|-> _Sum0 A ] := (λ γ, (σ @ γ; a @ γ) ; SubExt_1 _ _).

(** %\noindent% where [SubExt_1] is a proof that it is functorial. 
*)
(* begin hide *)

Arguments SubExt {Γ Δ A} σ a.

Program Instance SubExtId_1 {Γ : Context} {A : Typ Γ} (t: Elt (A)) : 
  Functor (T:=[[Γ]]) (U := [[_Sum0 A]]) (λ s , (s; t @ s)).
Next Obligation. exact (X ; Dmap t X). Defined.
Next Obligation. exists (identity _). simpl. eapply composition. exact (Dmap_id t). 
                 unfold transport_eq. apply inverse. eapply composition.
                 apply comp. simpl. apply (map2_id A). apply identity. simpl. 
                 simpl_id_bi. Defined.
Next Obligation. exists (identity _). eapply composition.
                 exact (Dmap_comp t e e'). simpl. unfold transport_eq.
                 eapply composition. Focus 2. apply comp. 
                 eapply inverse. eapply (map2_id A). apply identity. simpl.
                 simpl_id_bi.
Defined.
Next Obligation. exact (X; Dmap2 t X). Defined.

Definition SubExtId {Γ : Context} {A : Typ Γ} 
 (t: Elt A) : [Γ -|-> (_Sum0 A)] := (λ γ, (γ; t @ γ) ; SubExtId_1 _ ).

Program Instance substF_1 {T Γ : Context} {A:Typ Γ} (F:TypFam A) (f:[T -|-> Γ]) :
  DependentFunctor (λ t : [_], ([[[A ⋅⋅ f]]] @ t) -||-> Type0; TypFam_1 (A ⋅⋅ f)) 
                       ([F °° f] : ∀ t : [T], [[(A ⋅⋅ f) @ t]] ---> Type0).
Next Obligation. exact (Dmap F (map f e)). Defined.
Next Obligation. intro. apply equiv_eq_nat_trans. 
                 eapply composition. apply (Dmap2 F (map_id f)). 
                 eapply composition. eapply nat_comp'.
                 apply identity. eapply composition. apply (Dmap_id F). 
                 apply identity. eapply composition. simpl.
                 eapply inverse. refine [map_comp (F @ (f @ x)) _ _].
                 refine [map2 (F @ (f@x)) _ ]. 
                 trunc1_eq.
Defined.
Next Obligation. intro. apply equiv_eq_nat_trans.                  
  eapply composition. apply (Dmap2 F (map_comp f e e')).
  eapply composition. apply groupoid.Equiv_cat_obligation_4. apply identity.
  apply (Dmap_comp F (map f e) (map f e') t).
  unfold substF_1_obligation_1, transport_comp, transport_map, transport_eq.
  eapply composition. apply nat_assoc. 
  apply inverse. eapply composition.
  apply nat_assoc. apply inverse.
  eapply composition. apply nat_assoc.
  apply nat_comp'; [idtac | apply identity].
  apply nat_comp'; [idtac | apply identity].
  eapply composition. eapply inverse. 
  refine [map_comp (F @ (f @ x)) _ _ ].
  refine [map2 (F @ (f @ x)) _]. trunc1_eq.
Defined.
Next Obligation.
  intro. apply (Dmap2 F (map2 f H) t).
Defined.

Infix "--->" := Fun_Type_Groupoid (at level 55).

(* end hide *)

Definition substF {T Γ} {A:Typ Γ} (F:TypFam A) (σ:[T -|-> Γ]) : TypFam (A ⋅⋅ σ) 
  := ([F °° σ] : ∀ t : [T], [[[A ⋅⋅ σ]]] @ t ---> Type0; substF_1 F σ). 

(* begin hide *)

Notation  "F '°°°' σ " := (substF F σ) (at level 50).

(* end hide *)
(** A substitution [σ] can be applied to a type family [F] using the
  composition of a functor with a dependent functor. We
  abusively note all those different compositions with [°] as it is done in
  mathematics, whereas they are distinct operators in the %\Coq%
  development.
  The weakening substitution of $\Gamma, x:A \vdash$ is given by the first
  projection. *)



(* begin hide *)

Program Instance Sub_1 (Γ: Context) (T : Typ Γ)
         : Functor (T:=[[_Sum0 T]]) (U := [[Γ]]) (λ γt , [γt]).
Next Obligation. apply [X]. Defined.
Next Obligation. apply identity. Defined.
Next Obligation. apply comp; apply identity. Defined.
Next Obligation. apply [X]. Defined.


Definition Sub {Γ: Context} {T : Typ Γ} : [_Sum0 T -|-> Γ] 
  :=  (λ γt:[ [[_Sum0 T]] ], [γt] ; Sub_1 _ _).

Notation "⇑ A" := (A ⋅⋅ Sub) (at level 9).
(* end hide *)
(**
  
  A type family [F] in [TypFam A] can be partially substituted with an
  term [a] in [Elt A], noted [F {{a}}], to get its value (a type) at
  [a]. This process is defined as [F {{a}} := (λ γ, (F @ γ) @ (a @ γ) ;
  _)] (where [_] is a proof it is functorial). Note that this
  pattern of application %\emph{up-to a context $\gamma$}% will be used
  later to defined other notions of application. Although the
  computational definitions are the same, the compatibility conditions
  are always different.  This notion of partial substitution in a type
  family enables to state that [LamT] defines a type level
  $\lambda$-abstraction.  *)
(* begin hide *)

(* Eval compute in 3. *)

Program Instance SubstT_1 {Γ:Context} {A:Typ Γ} (F:TypFam A) (a:Elt A) :
 Functor (λ s, (F @ s) @ (a @ s)).
Next Obligation. eapply composition; try apply ([Dmap F X] (a @ y)).
                 simpl. unfold id. apply (map (F @ x)).
                 apply equiv_adjoint.
Defined. 
 Next Obligation. apply equiv_eq_nat_trans.
                  eapply composition. apply nat_comp'. 
                  apply identity. apply (Dmap_id F (a @ x)). 
                  eapply composition. eapply inverse. 
                  refine [map_comp (F @ x) _ _]. 
                  eapply composition. eapply (map2 (F @ x)).
                  apply Equiv_adjoint_identity. apply (map_id (F @ x)).
 Defined.
 Next Obligation.
   unfold SubstT_1_obligation_1.
   apply equiv_eq_nat_trans. 
   eapply composition. apply nat_comp'. apply identity.
   apply (Dmap_comp F e e' (a @ z)).
   eapply composition. 
   eapply nat_assoc. eapply composition. eapply nat_assoc.
   eapply inverse. eapply composition. apply nat_assoc.
   apply nat_comp'; try apply identity.
   unfold transport_map, transport_comp.
   apply inverse. eapply composition. apply nat_comp'.
   eapply composition. eapply inverse.
   refine [map_comp (F @ x) _ _]. 
   eapply composition. eapply (map2 (F @ x)).
   (* the following raises a wird error *)
   (* apply  Equiv_adjoint_comp. *)
   refine (Equiv_adjoint_comp _ _ _ _ _ _).
   apply (map_comp (F @ x)). apply identity.
   eapply composition. eapply inverse. apply nat_assoc.
   apply inverse. eapply composition. eapply inverse. apply nat_assoc.
   apply nat_comp'; try apply identity. apply inverse.
   apply (α_map (Dmap F e)).
Defined.
Next Obligation. 
  unfold SubstT_1_obligation_1.
  apply equiv_eq_nat_trans. 
  eapply composition. apply nat_comp'. apply identity.
  apply (Dmap2 F X (a @ y)).
  eapply composition. apply nat_assoc.
  apply nat_comp'; [idtac | apply identity].
  eapply composition. eapply inverse.
  refine [map_comp (F @ x) _ _]. 
  apply (map2 (F @ x)). apply Equiv_adjoint_eq.
Defined.
 
Definition SubstT {Γ:Context} {A:Typ Γ} (F:TypFam A) (a:Elt A) : Typ Γ :=
  (λ γ, (F @ γ) @ (a @ γ) ; SubstT_1 _ _).
Obligation Tactic := intros.

Notation  "F '{{' a '}}'" := (SubstT F a) (at level 50).

Instance BetaT_1 {Δ Γ : Context} {A:Typ Γ} (B:TypDep A) (σ:[Δ -|-> Γ]) (a:Elt (A ⋅⋅ σ)):
   @NaturalTransformation _ _  ((@LamT Γ A B °°° σ) {{a}})
    (B ⋅⋅ @SubExt Δ Γ A σ a) (λ t : [Δ], identity (((LamT B °°° σ) {{a}}) @ t)).
  red. intros. eapply composition. apply equiv_id_L.
  apply inverse. eapply composition. apply equiv_id_R.
  unfold _map; simpl. unfold SubstT_1_obligation_1,groupoid.arrow_comp_obligation_1.
  unfold _map; simpl. unfold SubExt_1_obligation_1.
  unfold groupoid.arrow_comp_obligation_1.
  apply inverse. eapply composition. eapply inverse. apply (map_comp B).
  apply (map2 B).   
  simpl; unfold sum_eq2; simpl. exists (id_R _ _ _).
  trunc1_eq.
  Defined.
(* end hide *)

Definition BetaT Δ Γ (A:Typ Γ) (B:TypDep A) (σ:[Δ -|-> Γ]) (a:Elt (A ⋅⋅ σ)) 
: LamT B °°° σ {{a}} ~1 B ⋅⋅ (SubExt σ a) := (λ _, identity _ ; BetaT_1 B σ a).

(* begin hide *)

Program Instance Var_0 {Γ:Context} (A:Typ Γ) :  
  DependentFunctor0 (⇑ A) (λ t : [ [[_Sum0 A]] ] , Π2 t).
Next Obligation. intros. apply (Π2 e). Defined.
Next Obligation. intros. unfold Var_0_obligation_1. simpl.
                 apply comp; try apply identity. unfold transport_comp.
                 eapply composition. eapply inverse. apply id_R.
                 apply comp; try apply identity. eapply inverse.
                 unfold transport. simpl. unfold groupoid.arrow_comp_obligation_1.
                 unfold Sub_1_obligation_3, Sub_1_obligation_1. simpl.
                 assert (Equiv_eq2 (map2 A (comp _ _ _ _ _ _ _ (identity [e]) (identity [e']))) (identity (map A ([e'] °[e])))).
                 match goal with
                     | [ |- Equiv_eq2 ?e ?e'] =>
                       let H := fresh in
                       let H':=fresh in 
                       set(H':=e) in *; clearbody H';
                       assert (H:=@center _ (Trunc_2 (Type0) _ _ _ _ H' e'));
                                         try ((destruct H; apply identity) 
                                                || (simpl in *; destruct H; apply identity))

                   end.
                 apply X.
Defined.
Next Obligation. intros. apply (Π2 H). Defined.

Definition Var0 {Γ} (A:Typ Γ) : Prod_Type0 ⇑A := (λ t, Π2 t; Var_0 A).

Instance Var_1 {Γ:Context} (A:Typ Γ) : 
  DependentFunctor ([[[⇑ A]]]) (λ t : [ [[_Sum0 A]] ] , Π2 t)
  := DepFun0DepFun (Var0 A).

(* end hide *)
(**

  ** Interpretation of the typing judgment
  %\label{sec:interp}%

  The explicit substitution versions of the typing rules of Figure
  %\ref{fig:emltt}% are modelled as described below.

  %\paragraph{\textsc{Var}.}% 

  The rule %\textsc{Var}% is given by the second projection plus a proof
  that the projection is dependently functorial. Note the explicit
  weakening of [A] in the returned type. This is because we need to
  make explicit that the context used to type [A] is extended with an
  term of type [A].

*)

Definition Var {Γ} (A:Typ Γ) : Elt ⇑A := (λ t, Π2 t; Var_1 A).

(* begin hide *)

Program Instance Prod_1 {Γ} (A:Typ Γ) (F : TypFam A) :
  @Functor ([[Γ]]) Type0 (λ s : [Γ], Prod0 (F @ s)) :=
  {| _map := fun _ _ X => Prod_eqT F X ;
     _map_id := fun X => (Prod_eq_id F; _);
     _map_comp := fun _ _ _ e e' => ((Prod_eq_comp F e e')^-1 ; _); 
     _map2 := fun _ _ _ _ X => (Prod_eq_map F _ _ X ; _) |}.
Next Obligation. apply AllEquivEq_Setoid. Defined.
Next Obligation. apply AllEquivEq_Setoid. Defined.
Next Obligation. apply AllEquivEq_Setoid. Defined.
(* end hide *)

(** %\paragraph{\textsc{Prod}.}% The rule %\textsc{Prod}% is interpreted
  using the dependent functor space, plus a proof that equivalent
  contexts give rise to isomorphic dependent functor spaces.  Note that
  the rule is defined on type families and not on the dependent type
  formulation because here we need a fibration point of view. *)

Definition Prod {Γ} (A:Typ Γ) (F:TypFam A) 
  : Typ Γ := (λ s, Prod0 (F @ s); Prod_1 A F).

(* begin hide *)

Program Instance App_0 {Γ} {A:Typ Γ} {F:TypFam A} (c:Elt (Prod F)) (a:Elt A) :
  DependentFunctor0 (F {{a}}) (λ s : [Γ], [ [c] s] ([a] s)).

Next Obligation. intros. eapply composition; try apply (Dmap (c @ y) (Dmap a e)).
                 unfold transport.
                 eapply composition; try eapply
                   (map [map ([F] y) (Dmap a e)] (Dmap c e @ ([map A e] @ (a @ x)))).
                 unfold transport. simpl. 
                 unfold Prod_eq_1, Prod_eq_. simpl. unfold id.
                 eapply composition; try apply (α_map (Dmap F e) (Dmap a e)).
                 simpl. 
                 apply (map [Dmap F e @ (a @ y)]).
                 unfold equiv_adjoint. eapply composition.
                 apply (map_comp (F @ x) _ (map (adjoint (map A e)) (Dmap a e))). simpl.
                 apply (map [map (F @ x) (map (adjoint (map A e)) (Dmap a e))]). 
                 apply (Dmap (c @ x)). 
Defined.
Next Obligation. intros; trunc1_eq. Defined.
Next Obligation. intros; trunc1_eq. Defined.

Definition App0 {Γ} {A:Typ Γ} {F:TypFam A} (c:Elt (Prod F)) (a:Elt A) 
  : Prod_Type0 (F {{a}}) := (λ s, (c @ s) @ (a @ s); App_0 c a).
 
Program Instance App_1 {Γ} {A:Typ Γ} {F:TypFam A} (c:Elt (Prod F)) (a:Elt A) :
  DependentFunctor (Type0_Type (F {{a}})) (λ s : [Γ], [ [c] s] ([a] s)) :=
   DepFun0DepFun (App0 _ _).

(* end hide *)
(**
  %\paragraph{\textsc{App}.}%

  The rule %\textsc{App}% is interpreted using an up-to context application 
  and a proof of dependent functoriality. We abusively note [M @@ N] the application 
  of [App].
*)

Definition App {Γ} {A:Typ Γ} {F:TypFam A} (c:Elt (Prod F)) (a:Elt A) 
  : Elt (F {{a}}) := (λ s, (c @ s) @ (a @ s); App_1 c a).

(* begin hide *)

Notation "M '@@' N" := (App M N) (at level 50).

Program Instance Lam_0 {Γ} {A:Typ Γ} {F:TypDep A}
  (b:Elt F) (γ:[Γ]) :
  DependentFunctor0 ((LamT F) @ γ) (fun t => b @ (γ ; t)).
Next Obligation. intros. apply (Dmap b (sum_id_left e)). Defined.
Next Obligation. intros. trunc1_eq. Defined.
Next Obligation. intros. trunc1_eq. Defined.

Definition Lam_partial0 {Γ} {A:Typ Γ} {F:TypDep A}
  (b:Elt F) (γ:[Γ]) : Prod_Type0 ((LamT F) @ γ) :=
 (λ t, b @ (γ ; t) ; Lam_0 _ _). 


Instance Lam_1 {Γ} {A:Typ Γ} {F:TypDep A}
  (b:Elt F) (γ:[Γ]) :
  DependentFunctor (Type0_Type ((LamT F) @ γ)) (fun t => b @ (γ ; t)) :=
  DepFun0DepFun (Lam_partial0 _ _).

Definition Lam_partial {Γ} {A:Typ Γ} {F:TypDep A}
  (b:Elt F) (γ:[Γ]) : [Prod (LamT F) @ γ] :=
 (λ t, b @ (γ ; t) ; Lam_1 _ _). 

Program Instance Lam_20 {Γ} {A:Typ Γ} {B:TypDep A} (b:Elt B) :
 DependentFunctor0 (Prod (LamT B)) (Lam_partial b).
Next Obligation. simpl. red; simpl.
                 exists (fun t => Dmap b (sum_id_right e t)).
                 red. intros; simpl. trunc1_eq.
Defined.
Next Obligation. intros. intro. trunc1_eq. Defined.
Next Obligation. intros. intro. trunc1_eq. Defined.

Definition Lam0 {Γ} {A:Typ Γ} {B:TypDep A} (b:Elt B)
  : Prod_Type0 (Prod (LamT B)) := (λ γ, (λ t, b @ (γ ; t) ; _); Lam_20 b).

Program Instance Lam_2 {Γ} {A:Typ Γ} {B:TypDep A} (b:Elt B) :
 DependentFunctor (Type0_Type (Prod (LamT B))) (Lam_partial b) :=
  DepFun0DepFun (Lam0 _).


(* end hide *)
(**
  %\paragraph{\lrule{Lam}.}%

  Term-level $\lambda$-abstraction is defined with the same
  computational meaning as type-level $\lambda$-abstraction, but it
  differs on the proof of dependent functoriality. Note that we use
  [LamT] in the definition because we need both the fibration (for
  [Prod]) and the morphism (for [Elt B]) point of view. 
*)

Definition Lam {Γ} {A:Typ Γ} {B:TypDep A} (b:Elt B)
  : Elt (Prod (LamT B)) := (λ γ, (λ t, b @ (γ ; t) ; _); Lam_2 b).

(* begin hide *)

(* same proof as for Prod *)

Program Instance Sigma_1 {Γ} (A:Typ Γ) (F : TypFam A) :
  @Functor ([[Γ]]) Type0 (λ s : [Γ], _Sum0 (F @ s)) :=
  {| _map := fun _ _ X => Sum_eqT F X ;
     _map_id := fun X => (Sum_eq_id F; _);
     _map_comp := fun _ _ _ e e' => ((Sum_eq_comp F e e')^-1 ; _); 
     _map2 := fun _ _ _ _ X => (Sum_eq_map F _ _ X ; _) |}.
Next Obligation. apply AllEquivEq_Setoid. Defined.
Next Obligation. apply AllEquivEq_Setoid. Defined.
Next Obligation. apply AllEquivEq_Setoid. Defined.

(* end hide *)

(**
  %\paragraph{\textsc{Sigma}, \textsc{Pair} and \textsc{Projs}.}%
  The rules for Σ types are interpreted using the 
  dependent sum [_Sum0] on setoids.  
*)

Definition Sigma {Γ} (A:Typ Γ) (F:TypFam A) 
  : Typ Γ := (λ γ: [Γ], _Sum0 (F @ γ); Sigma_1 A F). 

(* begin hide *)

Program Instance Pair_1 {Γ} {A:Typ Γ} {B:TypFam A} (a: Elt A) (b : Elt (B {{a}})) : 
  DependentFunctor (Type0_Type (Sigma B)) (λ γ, (a @ γ; b @ γ)).
Next Obligation. exists (Dmap a e). unfold id. 
                 eapply composition. Focus 2. apply (Dmap b e).
                 simpl. eapply composition. unfold transport.                 
                 eapply (map [map ([[[B @ y]]]) (Dmap a e)]). 
                 apply (map_id (B @ y)). simpl. unfold id.
                 apply inverse. eapply composition. 
                 eapply (map [Dmap B e @ (a @ y)] ). apply (map_comp (B @ x)).
                 apply (α_map (Dmap B e)).
Defined. 
Next Obligation. exists (Dmap_id a).
                 trunc1_eq. Defined.
Next Obligation. assert (Dmap a (e' ° e) ~
          (Dmap a e' ° map [map A e'] (Dmap a e))
          ° (([(map_comp A) e e'] @ (a @ x)) ^-1) ^-1).
                 eapply composition. apply (Dmap_comp a e e').
                 apply comp. apply inverse. apply inv_inv. apply identity.
                 exists X. trunc1_eq. Defined.
Next Obligation. exists (Dmap2 a H).
                 trunc1_eq. Defined.

(* end hide *)
(** %\noindent% Pairing and projections are obtained
  by a context lift of pairing and projection of the underlying dependent sum.
*)

(* begin hide *)

Definition Pair {Γ} {A:Typ Γ} {B:TypFam A} (a: Elt A) (b : Elt (B {{a}}))
  : Elt (Sigma B) := (λ γ, (a @ γ; b @ γ) ; Pair_1 a b).


Program Instance Proj1_1 {Γ} {A:Typ Γ} {B:TypFam A} (t: Elt (Sigma B)) :
DependentFunctor (Type0_Type A) (λ γ, [t @ γ]).
Next Obligation. exact ([Dmap t e]). Defined.
Next Obligation. exact ([Dmap_id t]). Defined.
Next Obligation. unfold Proj1_1_obligation_1; simpl.
                 eapply composition. exact ([Dmap_comp t e e']). simpl.
                 apply comp. apply (inv_inv _ _ _ ([(map_comp A) e e'] @ [t @ x])).
                 apply identity.
Defined.
Next Obligation. exact ([Dmap2 t H]). Defined.

Definition Proj1 {Γ} {A:Typ Γ} {B:TypFam A} (t: Elt (Sigma B))
  : Elt A := (λ γ, [t @ γ] ; Proj1_1 t).

Program Instance Proj2_1 {Γ} {A:Typ Γ} {B:TypFam A} (t: Elt (Sigma B)) :
DependentFunctor (Type0_Type (B {{Proj1 t}})) (λ γ, Π2 (t @ γ)).
Next Obligation. eapply composition. Focus 2. apply ((Dmap t e).2). simpl. unfold id.
                 unfold transport.
                 assert ([Dmap B e @ [t @ y] ] °
                      ([map (B @ x) (equiv_adjoint (Proj1 t) e)]) ~
                      [map ([[[B @ y]]]) [Dmap t e] ] °
   ([map (B @ y) (identity ([map A e] @ [t @ x]))] °
                                                   ([Dmap B e @ ([map A e] @ [t @ x])] °
                                        ([map (B @ x) (retraction (map A e) @ [t @ x]) ^-1])))).
                 unfold equiv_adjoint.
                 eapply composition. apply nat_comp'. apply (map_comp (B @ x)).
                 apply identity. eapply composition. eapply inverse. apply nat_assoc.
                 apply inverse. eapply composition. eapply inverse. apply nat_assoc.
                 eapply composition. eapply inverse. apply nat_assoc.
                 apply nat_comp'. apply identity. apply inverse. eapply composition.
                 apply (α_map (Dmap B e)). apply inverse.
                 eapply composition. eapply inverse. apply nat_assoc.
                 apply nat_comp'. apply identity. eapply composition.
                 eapply inverse. apply (map_comp (B @y)). apply (map2 (B @ y)).
                 apply id_R.
                 apply X.
Defined. 
Next Obligation. trunc1_eq. Defined. 
Next Obligation. trunc1_eq. Defined. 
Next Obligation. trunc1_eq. Defined. 


Definition Proj2 {Γ} {A:Typ Γ} {B:TypFam A} (t: Elt (Sigma B))
  : Elt (B {{Proj1 t}}) := (λ γ, Π2 (t @ γ); Proj2_1 t).
(* end hide *)

(**
  %\paragraph{\lrule{Conv}.}%
  %$\beta$%-reduction for abstraction is valid as a definitional equality,
  where [SubExtId] is a specialization of [SubExt] with the identity substitution.
*)

Definition Beta {Γ} {A:Typ Γ} {F:TypDep A} (b:Elt F) (a:Elt A) 
  : [Lam b @@ a] = [b °° SubExtId a] := eq_refl _.

(**
 %\noindent% 
  The other beta rules and the equational theory of 
  explicit substitutions can be validated in the same way, showing that
  this forms a CwF.
*)

(* begin hide *)

Instance groupoid_eq1 (T:[_Type]) (a b : [T]): Groupoid (a ~1 b) :=
  IrrRelGroupoid {| eq1 := @eq2 _ _ _ a b|}.

Program Instance setoid_eq1 (T:[_Type]) (a b : [T]): Setoid (a ~1 b).
Next Obligation. intros. apply is_Trunc_2. Defined.

Program Definition Id_ {Γ} (A: Typ Γ) (a b : Elt A) (γ : [Γ]) : [Type0] :=
  (a @ γ ~1 b @ γ ; setoid_eq1 ([[[A]]] @ γ) (a@γ) (b@γ)). 

Program Instance _Id_functor {Γ} (A: Typ Γ) (a b : Elt A) (x y:[Γ]) (X : x ~1 y) : Functor (T := [[Id_ a b y]]) (U:=[[Id_ a b x]]) (fun E => Equiv_injective _ _ _ ((Dmap b X)^-1 ° E ° (Dmap a X))).
Next Obligation. intros. unfold Equiv_injective. simpl. apply comp. apply identity.
                 apply inv. apply comp. apply identity. apply (map2 (adjoint (map A X))). 
                 apply inv. apply comp. apply identity. apply left_compose'. exact X0.
                 Defined.
Next Obligation. intros. exact tt. Defined. 
Next Obligation. intros. exact tt. Defined. 
Next Obligation. intros. exact tt. Defined. 

Definition Id_functor {Γ} (A: Typ Γ) (a b : Elt A) (x y:[Γ]) (X : x ~1 y) : [Id_ a b y -|-> Id_ a b x] := (_; _Id_functor _ a b x y X). 

Program Instance Id_1 {Γ} (A: Typ Γ) (a b : Elt A) : Functor (T := [[Γ]]) (U := Type0) (Id_ a b).
Next Obligation. intros. apply IsoToEquiv. exists (Id_functor a b y x (X^-1)).
                 apply (@Build_Iso_struct _ _ _ (Id_functor a b x y X)).
                 red. red. simpl. 
                 refine (Build_sigma _ _ _).
                 intro. trunc1_eq.
                 red. intros. exact tt.
                 red. red. simpl.
                 refine (Build_sigma _ _ _).
                 intro ; trunc1_eq.
                 red. intros. exact tt. 
Defined.
Next Obligation. apply equiv_eq_nat_trans. simpl. 
                 unfold Id_functor. red. simpl.
                 refine (Build_sigma _ _ _).
                 intro. trunc1_eq.
                 red. intros. exact tt. Defined.
Next Obligation. apply equiv_eq_nat_trans. simpl. 
                 unfold Id_functor. red. simpl.
                 refine (Build_sigma _ _ _).
                 intro. trunc1_eq.
                 red. intros. exact tt. Defined.
Next Obligation. apply equiv_eq_nat_trans. simpl. 
                 unfold Id_functor. red. simpl.
                 refine (Build_sigma _ _ _).
                 intro. trunc1_eq.
                 red. intros. exact tt. Defined.
(* end hide *)
(** 
  ** Identity Types
  One of the main interests of the groupoid interpretation is that it
  allows to interpret a type directed notion of equality which validates 
  the J eliminator of identity types but also various extensional principles,
  including functional extensionality. 
  For any terms [a] and [b] of a dependent type [A:Typ Γ], we note [Id a b] the equality type
  between [a] and [b] obtained by lifting [~1] to get a type depending on [Γ].
*)

Definition Id {Γ} (A: Typ Γ) (a b : Elt A) 
  : Typ Γ := (λ γ, (a @ γ ~1 b @ γ ; _); Id_1 A a b). 

(* begin hide *)

Program Instance Refl_1 Γ (A: Typ Γ) (a : Elt A) :
DependentFunctor ([[[Id a a]]]) (λ γ : [Γ], identity (a @ γ)).
Next Obligation. simpl. trunc1_eq. Defined.
Next Obligation. exact tt. Defined.
Next Obligation. exact tt. Defined.
Next Obligation. exact tt. Defined.
(* end hide *)

(** The introduction rule of identity types which corresponds to reflexivity is interpreted by the (lifting of) identity of the underlying setoid. *)

Definition Refl Γ (A: Typ Γ) (a : Elt A) 
  : Elt (Id a a) := (λ γ, identity (a @ γ); Refl_1 _ _ _).

(* begin hide *)

Definition depEq Γ (A:Typ Γ) (a :Elt A) : Typ Γ := Sigma (LamT (Id (a °°°° Sub) (Var A))).

Definition BetaT2 Γ (A:Typ Γ) (a b:Elt A) : LamT (Id (a °°°° Sub) (Var A)) {{b}} ~1 Id a b.
simpl. red. simpl. exists (fun _ => identity _).
intros t t' e.
simpl_id_bi. apply equiv_eq_nat_trans. simpl. red. simpl.
refine (Build_sigma _ _ _).
intro. 
apply comp. apply identity. 
eapply composition. eapply inverse. 
apply (comp_inv _ _ _ _ ((retraction (map A e ^-1) @ (b @ t')) ^-1)).
apply inverse. eapply composition. eapply inverse. 
apply (comp_inv _ _ _ _ ((retraction (map A e ^-1) @ (b @ t')) ^-1)).
apply comp; try apply identity. eapply inv. 
apply (map2 (adjoint (map A e ^-1))). trunc1_eq. 
red. intros. exact tt.
Defined.

Definition prod_comp Γ (A: Typ Γ) (a b : Elt A) (P : TypFam A) (e:P{{a}} ~1 P{{b}}) :  [Prod0 (P{{a}}) -|-> Prod0 (P{{b}})] := @prod_eq _ (P{{a}}) (P{{b}}) e.

Notation "e 'with' t" := (prod_eq t @ e) (at level 50).

Notation "⇑⇑ A" := (A with (inverse (BetaT2 _ _))) (at level 9).

Definition J_Pair Γ (A:Typ Γ) (a b:Elt A) (e:Elt (Id a b)) (P:TypFam (depEq a))  
           (γ : [Γ]) : 
  Pair (prod_eq (BetaT2 a a) ^-1 @ Refl a) @ γ ~1
  Pair (e with (inverse (BetaT2 _ _)))@ γ.
  exists (e @ γ). simpl. trunc1_eq.
Defined.

Instance J_1 Γ (A:Typ Γ) (a b:Elt A) (e:Elt (Id a b)) (P:TypFam (depEq a)) :
  NaturalTransformation (f:=P {{Pair (Refl a with (inverse (BetaT2 _ _)))}}) 
                        (g:=P {{Pair (e with (inverse (BetaT2 _ _)))}}) 
                        (λ γ : [Γ], map (P @ γ) (J_Pair e P γ)).
red. intros.
pose (Dmap P e0). pose (P @ t').  apply equiv_eq_nat_trans.
eapply composition. eapply inverse.
pose ([α_map (Dmap P e0) (J_Pair e P t')]).
pose ((identity [map (P @ t)
           (equiv_adjoint
              (Pair
                 (λ a0 : [Γ], id (identity (a @ a0));
                 prod_eq1 (groupoid.nat_inv_obligation_1 (BetaT2 a a))
                   (Refl a))) e0)])). 
simpl in n , n0. exact (n0 ** n). red. simpl.

pose (f := Dmap P e0 @ (b @ t'; id (e @ t'))). 
pose (@_map _ _ _ [Dmap P e0 @ (b @ t';  (e @ t'))].2).
match goal with | [ |- sigma (λ α : ?H, _)]
                  => assert H end.
intro. apply e2.
eapply composition. eapply inverse. apply (map_comp (P @ t)). 
apply inverse. eapply composition. eapply inverse. apply (map_comp (P @ t)). 
apply (map2 (P @ t)). simpl. red. 
match goal with | [ |- sigma (λ α : ?H, _)]
                  => assert H end.
simpl. trunc1_eq. exists H.  exact tt.
exists X. red. intros. simpl. trunc1_eq.
Defined.

(* end hide *)

(** We can interpret the J eliminator of MLTT on [Id] using functoriality of [P] and of product ([prod_comp]). In the definition of J, the predicate [P] depends on the proof of equality, which is interpreted using a [Sigma] type. The functoriality of [P] is used on the term [J_Pair e P γ], which is a proof that [(a;Refl a)] is equal to [(b;e)]. The notation [⇑⇑ a] is used to convert the type of terms according to equality on [LamT]. *)

Definition J Γ (A:Typ Γ) (a b:Elt A) (P:TypFam (Sigma (LamT (Id (a °°°° Sub) (Var A)))))
               (e:Elt (Id a b)) (p:Elt (P{{Pair ⇑⇑ (Refl a)}})) 
  : Elt (P{{Pair ⇑⇑e}}) := prod_comp (λ γ, (map (P @ γ) (J_Pair e P γ)); J_1 _ _) @ p. 

