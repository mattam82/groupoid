(** printing ~1 $\sim_1$ *)
(** printing ~ $\sim_2$ *)
(** printing ~2 $\sim_2$ *)
(** printing Π1 $\pi_1$*)
(** printing Π2 $\pi_2$*)
(** printing Πi $\pi_i$*)
(** printing --> $\longrightarrow$*)
(** printing ---> $\longrightarrow$*)
(** printing -|-> $\longrightarrow$*)
(** printing -||-> $\longrightarrow$*)
(** printing β $\beta$*)
(** printing χ $\chi$*)
(** printing γ $\gamma$*)
(** printing γt $\gamma t$*)
(** printing [! $\llbracket$*)
(** printing !] $\rrbracket$*)
(** printing |- $\vdash$*)
(** printing === $\equiv$*)
(** printing @ $\star$*)
(** printing ° $\circ$*)
(** printing °' $\circ$*)
(** printing |g $|_g$*)
(** printing |0g $|_0$*)
(** printing [[ % %*)
(** printing ]] $_{\upharpoonright s}$*)
(** printing [[[ % %*)
(** printing ]]] $_{\upharpoonright s}$*)
(** printing Category_1 $\mathclass{PreCategory}_1$*)
(** printing Category_2 $\mathclass{PreCategory}_2$*)
(** printing CategoryP $\mathsf{PreCategory}$*)
(** printing CatType $\mathbf{UCat}$*)
(** printing Category $\mathsf{O-Category}$*)
(** printing GroupoidP $\mathsf{PreGroupoid}$*)
(** printing Groupoid $\mathsf{IsType_1}$*)
(** printing Setoid $\mathsf{IsType_0}$*)
(** printing Propoid $\mathsf{IsType_{-1}}$*)
(** printing UGroupoidType $\mathsf{Type_{1}}$*)
(** printing GroupoidType $\mathsf{Type_1}$*)
(** printing SetoidType $\mathsf{Type_0}$*)
(** printing PropoidType $\mathsf{Type_{-1}}$*)
(** printing Type0 $\mathsf{Type}_{0}^1$*)
(** printing _Type $\mathsf{Type}_{1}^{1}$*)
(** printing Groupoid_1 $\mathsf{Groupoid}_1$*)
(** printing Groupoid_2 $\mathsf{Groupoid}_2$*)
(** printing Equivalence_2 $\mathsf{Equivalence}_2$*)
(** printing Hom1 $\mathsf{Hom}_1$*)
(** printing Hom2 $\mathsf{Hom}_2$*)
(** printing Hom3 $\mathsf{Hom}_3$*)
(** printing _adjoint $\coqdoccst{adjoint}$*)
(** printing _section $\coqdoccst{section}$*)
(** printing _retraction $\coqdoccst{retraction}$*)
(** printing _triangle $\coqdoccst{triangle}$*)
(** printing nat_comp' $\coqdoccst{comp}$*)
(** printing _α_map $\coqdoccst{α}_\mathsf{map}$*)
(** printing _α_Dmap $\coqdoccst{α}_{\mathsf{map}^\Pi}$*)
(** printing α_map $\coqdoccst{α}_\mathsf{map}$*)
(** printing α_Dmap $\coqdoccst{α}_{\mathsf{map}^\Pi}$*)
(** printing _eq_gsection $\coqdoccst{eq\_section}$*)
(** printing _eq_retraction $\coqdoccst{eq\_retraction}$*)
(** printing Prod_Type $\Pi_\coqdoccst{T}$*)
(** printing _Prod $\Pi$*)
(** printing Prod0 $\Pi_0$*)
(** printing _Sum $\Sigma$*)
(** printing _Sum0 $\Sigma$*)
(** printing Sum0 $\Sigma_0$*)
(** printing sum_type $\Sigma_\coqdoccst{T}$*)
(** printing sum_eq $\Sigma_\coqdoccst{Eq}$*)
(** printing sum_eq2 $\Sigma_{\coqdoccst{Eq}_2}$*)
(** printing eq2 $\coqdoccst{eq}_2$*)
(** printing eq1 $\coqdoccst{eq}_1$*)
(** printing HomT $\mathsf{HomSet}$*)
(** printing HomT2 $\mathsf{HomSet}_2$*)
(** printing HomT1 $\mathsf{HomSet}_1$*)
(** printing id_R $\coqdoccst{id}_R$*)
(** printing id_L $\coqdoccst{id}_L$*)
(** printing inv_R $\coqdoccst{inv}_R$*)
(** printing inv_L $\coqdoccst{inv}_L$*)
(** printing ^-1 $\hspace{-1ex}^{-1}$*)
(** printing Trunc_2 $\coqdoccst{Trunc}_2$*)
(** printing map_id $\coqdoccst{map}_\coqdoccst{id}$*)
(** printing map_comp $\coqdoccst{map}_\coqdoccst{comp}$*)
(** printing map2 $\coqdoccst{map}_2$*)
(** printing _map $\coqdoccst{map}$*)
(** printing _map_id $\coqdoccst{map}_\coqdoccst{id}$*)
(** printing _map_comp $\coqdoccst{map}_\coqdoccst{comp}$*)
(** printing _map2 $\coqdoccst{map}_2$*)
(** printing map1 $\coqdoccst{map}_1$*)
(** printing Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing _Dmap $\coqdoccst{map}^{\cst{\Pi}}$*)
(** printing Dmap_id $\coqdoccst{map}^\Pi_\mathsf{id}$*)
(** printing Dmap_comp $\coqdoccst{map}^\Pi_\mathsf{comp}$*)
(** printing Dmap2 $\coqdoccst{map}^\Pi_2$*)
(** printing _Dmap_id $\coqdoccst{map}^\Pi_\mathsf{id}$*)
(** printing _Dmap_comp $\coqdoccst{map}^\Pi_\mathsf{comp}$*)
(** printing _Dmap2 $\coqdoccst{map}^\Pi_2$*)
(** printing Dmap1 $\coqdoccst{map}^\Pi_1$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DependentFunctor $\mathsf{Functor}^\Pi$*)
(** printing DNaturalTransformation $\mathsf{NaturalTrans}^\Pi$*)
(** printing NaturalTransformation $\mathsf{NaturalTrans}$*)
(** printing Dnat_trans $\mathsf{nat\_trans}^\Pi$*)
(** printing Dmodification $\mathsf{modification}^\Pi$*)
(** printing sum_weakgroupoid $\Sigma_\mathsf{WG}$*)
(** printing prod_weakgroupoid $\Pi_\mathsf{WG}$*)
(** printing IrrRelGroupoid $\coqdoccst{IrrRelWG}$*)
(** printing Hom_irr $\coqdoccst{HomIrr}$*)
(** printing ↑ $\shortuparrow$*)
(** printing Equiv_Groupoid $\mathsf{Equiv_{Type_0}}$*)
(** printing Prod_Groupoid $\mathsf{Prod_{Type_0}}$*)
(** printing transport_id $\mathsf{transport_{id}}$*)
(** printing transport_eq $\mathsf{transport_{eq}}$*)
(** printing transport_map $\mathsf{transport_{map}}$*)
(** printing transport_comp $\mathsf{transport_{comp}}$*)
(** printing nat_trans_grp $\mathsf{fun_{grp}}$*)
(* begin hide *)

(* Add LoadPath "." as Groupoid. *)

Require Export Unicode.Utf8_core.
Require Import Coq.Program.Tactics.
Require Import eq_with_uip.

Set Universe Polymorphism.
Set Program Mode.
Set Primitive Projections.

Set Implicit Arguments.

Notation " { x : T & P } " := (sigma (fun x : T => P)).

Notation "x .1" := (proj1 x) (at level 3).
Notation "x .2" := (proj2 x) (at level 3).

Notation " ( x ; p ) " := (@Build_sigma _ _ x p).

Notation Π1 := proj1.
Notation Π2 := proj2.
Notation "[ T ]" := T.1.

(* end hide *)
(**
  This section presents our formalization of groupoids in %\Coq% with
  universe polymorphism. 
  We first explain our overloaded management of
  equalities and introduce type classes for groupoids and their
  associated structures, i.e., functors, natural transformations and
  homotopy equivalences
  (%\S\ref{sec:w2gpds}-\ref{sec:homequiv}%).
  Natural transformations give access to a homotopic form of
  functional extensionality, while homotopy equivalences provide
  extensionality at the level of 0-types.  Polymorphic universes are
  needed to state that setoids and homotopy equivalences form a
  groupoid.  Homotopic equivalences directly provide access to a
  rewriting mechanism on types (%\S\ref{sec:rew}%). This rewriting is
  used to extend functors and products to dependent functors and
  dependent sums (%\S\ref{sec:depprod}-\ref{sec:sigma}%).
 %\subsection{Notations} \input{notations}%
*)


(** ** Definition of groupoids %\label{sec:w2gpds}% 

We formalize groupoids using type classes.  Contrarily to what is done
in the setoid translation, the basic notion of a morphism is an
inhabitant of a relation in [Type] (i.e., a proof-relevant relation): *)

Definition HomT (T : Type) := T -> T -> Type.

(**
  %\noindent%
  Given [x] and [y] in [T], [HomT T x y] is the type of morphism from [x] to [y]. 
  To manipulate different [HomT]'s at dimension 1 and 2 more abstractly, we use ad-hoc 
  polymorphism and introduce type classes [HomT1] and [HomT2] with according notations. 
*)

Class HomT1 T := {eq1 : HomT T}.
Infix "~" := eq1 (at level 80).



(** Given a [HomT], we define type classes: [Identity] that gives the
  identity morphism, [Inverse] which corresponds to the existence of an
  inverse morphism for every morphism (noted [f ^-1]) and [Composition]
  which corresponds to morphism composition (noted [g ° f]). Those three
  properties are gathered by the type class [Equivalence].*)
(* begin hide *)

Class Identity {A} (Hom : HomT A) :=
  { identity : ∀ x, Hom x x }.

Class Inverse {A} (Hom : HomT A) :=
  { inverse : ∀ {x y:A}, Hom x y -> Hom y x }.

Class Composition {A} (Hom : HomT A) :=
  { composition : ∀ {x y z:A}, Hom x y -> Hom y z -> Hom x z }.

Notation  "g ° f" := (composition f g) (at level 50). 
Notation  "f ^-1" := (inverse f) (at level 3). 

(* end hide *)
(* begin hide *)
Class Equivalence {T} (Eq : HomT T):= {
  Equivalence_Identity :> Identity Eq ;
  Equivalence_Inverse :> Inverse Eq ;
  Equivalence_Composition :> Composition Eq 
                                     }.


Instance id_seq T : Identity (@seq T) := {| identity := @seq_refl _ |}.

Instance inv_seq T : Inverse (@seq T).
Next Obligation. destruct X. exact (seq_refl a). Defined.

Instance trans_seq T : Composition (@seq T) := {| composition := @concat _ |}.

Instance equivalence_seq T : Equivalence (@seq T).

(* end hide *)
(**
  A [CategoryP] is defined as a category
  where coherences are given up-to an equivalence relation denoted by
  [≡].  Ordinary categories are derived with the additional requirement
  that higher equalities are trivial, which can be expressed using
  identity types (see the definition of [Groupoid]).  

  We do not put this condition into the basic definition because
categories and functors form a pre-category but not a 1-category. Thus,
working with pre-categories and pre-groupoids allows to share more
structure and is closer to the ω-groupoid model which is itself enriched.
*)


Class Category T := { Hom1 :> HomT1 T;
     Id :> Identity eq1; Comp :> Composition eq1;
     id_R : ∀ x y (f : x ~ y), f ° identity x ≡ f ;
     id_L : ∀ x y (f : x ~ y), identity y ° f ≡ f ;
     assoc : ∀ x y z w (f: x ~ y) (g: y ~ z) (h: z ~ w),
              (h ° g) ° f ≡ h ° (g ° f);
     comp : ∀ x y z (f f': x ~ y) (g g': y ~ z), 
              f ≡ f' -> g ≡ g' -> g ° f ≡ g' ° f' }.

(**
  In homotopy type theory, coherences are expressed using identity types, with a further requirement that the internal notion of equality induced by the category (isomorphism between two objects) coincides with its identity type %\cite{2013arXiv1303.0584A}%.
  We do not share this point of view because it requires the univalence axiom, which is precisely what we want to give meaning to. Instead, we restrict the use of identity types to the treatment of contractibility for higher cells. 
  Thus, our notion of groupoids is slightly more general as they are not enriched over  sets, but over setoids.
  Note that the [comp] law is not present in traditional definition of categories 
  because it is automatically satisfied for the identity type.
*)
(* begin hide *)

Definition CatType := {T:Type & Category T}.

(* Hint Extern 1 (@Equivalence (@eq1 (@Hom1 ?T) ?x ?y) eq2) =>  *)
(*   apply (@Equivalence_2 T x y) : typeclass_instances. *)
(* Hint Extern 1 (@CategoryP (proj1 ?T) (@Hom1 ?T) _) => apply (@Category_1 (proj2 T)) : typeclass_instances. *)
(* Hint Extern 1 (@HomT2 _ (@eq1 (@Hom1 ?T))) => apply (@Hom2 T) : typeclass_instances. *)
Hint Extern 1 (Category [?T]) => apply (proj2 T) : typeclass_instances.

(* end hide *)
(** 
 A [GroupoidP] is a [CategoryP] where all 1-Homs are invertible
 and subject to additional compatibility laws for inverses.
*)

Class Groupoid T := { C :> Category T ;  Inv :> Inverse eq1 ;
     inv_R : ∀ x y (f: x ~ y), f ° f ^-1 ≡ identity y ;
     inv_L : ∀ x y (f: x ~ y), f ^-1 ° f ≡ identity x ;
     inv :   ∀ x y (f f': x ~ y), f ≡ f' -> f ^-1 ≡ f' ^-1}.

(* begin hide *)
(* Hint Extern 1 (@Equivalence (@eq1 (@Hom1 ?T) ?x ?y) eq2) =>  *)
(*   apply (@Equivalence_2 T x y) : typeclass_instances. *)
(* Hint Extern 1 (@HomT2 _ (@eq1 (@Hom1 ?T))) => apply (@Hom2 T) : typeclass_instances. *)
Hint Extern 1 (Groupoid [?T]) => apply (proj2 T) : typeclass_instances.

Definition assoc' {T} {Hom1: HomT1 T} {Category} {x y z w: T} :=
  assoc (Category := Category) x y z w.

Definition id_L' {T} {Hom1: HomT1 T} {Category} {x y: T} := 
  id_L (Category := Category) x y .

Definition id_R' {T} {Hom1: HomT1 T} {Category} {x y: T} := 
  id_R (Category := Category) x y .

Definition HorComp {T} 
           {Category_1 : Category T} {x y z}
           {f f' : x ~ y} {g g' : y ~ z} :
  f ≡ f' -> g ≡ g' -> g ° f ≡ g' ° f' :=
  @comp _ _ _ _ _ f f' g g'.

Infix "**" := HorComp (at level 50).

(* We note [UGroupoidType] for the types that form a [GroupoidP].  *)
(* The subscript $1^+$ comes from the homotopical notion of truncated types.  *)
(* A pre-groupoid is at a truncated level of at least $1$. *)

(* end hide*)
(**
   Groupoids are then pre-groupoids where equality at
   dimension 2 is irrelevant. This irrelevance is defined using a
   notion of contractibility expressed with (relevant) identity types.  *)


(** This is a way to require that all higher-cells are trivial. In our setting, we do not have the possibility to say that all 2-cells are related by a 3-cell, and so on. The price to pay will be explicit reasoning on identity types when proving for instance contractibility for the function space. In that case, we need the axiom of functional extensionality.
By analogy to homotopy type theory, we note [Groupoid] the property of being a groupoid. 
*)

(* Class Groupoid T := { G :> GroupoidP T ;  *)
(*   is_Trunc_2 : ∀ (x y : T) (e e' : x ~ y) (E E' : e ≡ e'), Contr (E ≡ E')}. *)

(** %\noindent% 
    In the same way, we define [Setoid] when equality is irrelevant at dimension 1.
*)

(* begin hide *)
(* and [Propoid] at dimension 0.  *)

(* end hide *)
(**    We note [GroupoidType] for the types that form a [Groupoid].
       The subscript $1$ comes from the fact that groupoids are 1-truncated types
       in homotopy type theory. In the same way,  
       we note [SetoidType] 
       for the types that form a [Setoid].
       We define [ [[T]] ] the lifting of setoids to groupoids.
*)
(* begin hide *)

Definition GroupoidType := {T: Type & Groupoid T}.

(* Definition UGroupoidType := {T: Type & GroupoidP T}. *)

Hint Extern 0 (Groupoid [?T]) => apply T.2 : typeclass_instances.
Hint Extern 0 (Category [?T]) => apply T.2 : typeclass_instances.
(* Hint Extern 0 (GroupoidP [?T]) => apply T.2 : typeclass_instances. *)

(* Instance eq_pi1 (T : SetoidType) : Setoid [T] := T.2. *)
(* Instance eq_pi1' (T : GroupoidType) : Groupoid [T] := T.2. *)
(* Instance eq_pi1'' (T : CatType) : Category [T] := T.2. *)
(* Instance eq_pi1''' (T : UGroupoidType) : GroupoidP [T] := T.2. *)

(* Instance eq_pi_prop (T : PropoidType) : Propoid [T] := T.2. *)

(* Instance eq_SWG (T : SetoidType) : Groupoid [T] := T.2.(S). *)

(* Instance eq_PWG (T : PropoidType) : Setoid [T] := P. *)

Definition GroupoidTypeToCatType (T : GroupoidType) : CatType :=
  (T.1 ; C).

Coercion GroupoidTypeToCatType : GroupoidType >-> CatType.

(* Definition GroupoidTypeToUGroupoidType (T : GroupoidType) : UGroupoidType :=  *)
  (* (T.1 ; G). *)

(* Coercion GroupoidTypeToUGroupoidType : GroupoidType >-> UGroupoidType.  *)

(* Definition SetoidTypeToUGroupoidType (T : SetoidType) : UGroupoidType :=  *)
  (* GroupoidTypeToUGroupoidType (SetoidTypeToGroupoidType T). *)

(* Coercion SetoidTypeToUGroupoidType : SetoidType >-> UGroupoidType.  *)

(* Notation "| x '|s'" := (SetoidTypeToGroupoidType x) (at level 50). *)
 
(* Notation "| x '|g'" := (GroupoidTypeToUGroupoidType x) (at level 50). *)

(* Notation "[[ x ']]'" := (SetoidTypeToUGroupoidType x) (at level 50). *)

Lemma left_simplify_gen {T}
      (cat:Category T)
      (x y z: T) (f f': x ~ y) (g : y ~ z) 
      (inv_g : z ~ y) (inv_L : inv_g ° g ≡ identity y) : 
  g ° f ≡ g ° f' -> f ≡ f'.
Proof.
  intros Heq. assert (X :(inv_g ° g) ° f ≡ (inv_g ° g) ° f').
  eapply composition. apply assoc.
  apply inverse; eapply composition. apply assoc. 
  apply inverse. apply comp. auto. apply identity. 
  eapply composition in X.  
  Focus 2.
  apply comp. apply identity. eapply inverse. apply inv_L.
  eapply inverse in X.
  eapply composition in X.
  Focus 2.
  apply comp. apply identity. eapply inverse. apply inv_L. 
  eapply composition in X.
  Focus 2.
  eapply inverse;  apply id_L. apply inverse in X. eapply composition in X.
  Focus 2.
  eapply inverse;  apply id_L. auto.   
Qed.

Lemma right_simplify_gen {T}
      (cat:Category T)
      (x y z: T) (f: x ~ y) (g g' : y ~ z) 
      (inv_f : y ~ x) (inv_R : f ° inv_f ≡ identity y) : 
  g ° f ≡ g' ° f -> g ≡ g'.
Proof.
  intros Heq. assert (X : g ° (f ° inv_f) ≡ g' ° (f ° inv_f)).
  eapply composition. eapply inverse. apply assoc.
  apply inverse; eapply composition. eapply inverse. apply assoc. 
  apply inverse. apply comp; auto. apply identity.
  eapply composition in X.
  Focus 2.
  apply comp; [idtac | apply identity]. eapply inverse. apply inv_R.
  eapply inverse in X.
  eapply composition in X.
  Focus 2.
  apply comp; [idtac | apply identity]. eapply inverse. apply inv_R. 
  eapply composition in X.
  Focus 2.
  eapply inverse;  apply id_R. apply inverse in X. eapply composition in X.
  Focus 2.
  eapply inverse;  apply id_R. auto.   
Defined.


Definition left_simplify (T:CatType) (x y z: [T])
           (f f': x ~ y) (g : y ~ z) (inv_g : z ~ y) 
           (inv_L : inv_g °g ≡ identity y) :
  g ° f ≡ g ° f' -> f ≡ f' 
  := @left_simplify_gen _ _ x y z f f' g inv_g inv_L.

Definition right_simplify (T:CatType) (x y z: [T]) 
           (f: x ~ y) (g g' : y ~ z) (inv_f : y ~ x) 
           (inv_R : f ° inv_f ≡ identity y) : 
  g ° f ≡ g' ° f -> g ≡ g' 
  := @right_simplify_gen _ _ x y z f g g' inv_f inv_R.

Lemma right_compose (T:CatType) (x y z:[T]) (f: x ~ y) (g g': y ~ z) 
      (inv_f : y ~ x) (inv_R : f ° inv_f ≡ identity y) 
      (inv_L : inv_f ° f ≡ identity x) :
  g ≡ g' -> g ° f ≡ g' ° f.
Proof.
  intro Heq. apply (right_simplify _ _ _ _ (inv_f) _ _ f inv_L).
  eapply composition. apply assoc.
  eapply inverse. eapply composition. apply assoc.
  eapply composition. apply comp; [idtac | apply identity].
  apply inv_R. eapply inverse. eapply composition. 
  apply comp; [idtac | apply identity]. apply inv_R. 
  eapply composition. apply id_R.
  eapply inverse. eapply composition. apply id_R.
  eapply inverse; auto.
Qed.

Lemma left_compose (T:CatType) (x y z:[T]) (f f': x ~ y) (g: y ~ z) 
      (inv_g : z ~ y) (inv_R : g ° inv_g ≡ identity z) 
      (inv_L : inv_g ° g ≡ identity y) : f ≡ f' -> g ° f ≡ g ° f'.
Proof.
  intro Heq. apply (left_simplify _ _ _ _ _ _ (inv_g) g inv_R).
  eapply composition. eapply inverse; apply assoc.
  eapply inverse. eapply composition. eapply inverse; apply assoc.
  eapply composition. apply comp. apply identity.
  apply inv_L. eapply inverse. eapply composition. apply comp.
  apply identity. apply inv_L. eapply composition. apply id_L.
  eapply inverse. eapply composition. apply id_L.
  eapply inverse; auto.
Qed.

Definition left_simplify' (T:GroupoidType) (x y z: [T]) (f f': x ~ y) 
           (g : y ~ z) : g ° f ≡ g ° f' -> f ≡ f' := 
  left_simplify T x y z f f' g (inverse g) (inv_L _ _ _).

Definition right_simplify' (T:GroupoidType) (x y z: [T]) (f : x ~ y)
           (g g' : y ~ z)
  := right_simplify T x y z f g g' (inverse f) (inv_R _ _ _).

Definition left_compose' (T:GroupoidType) (x y z:[T]) (f f': x ~ y) 
           (g: y ~ z) 
  := @left_compose T x y z f f' g (inverse g) (inv_R _ _ _ ) (inv_L _ _ _ ). 

Definition right_compose' (T:GroupoidType) (x y z:[T]) (f : x ~ y) 
           (g g': y ~ z)
  := @right_compose T x y z f g g' (inverse f) (inv_R _ _ _) (inv_L _ _ _).

Lemma comp_inv (T:GroupoidType) (x y z:[T]) (f : x ~ y) (g : y ~ z) : 
  inverse f ° inverse g ≡ inverse (g ° f).
Proof.
  apply (left_simplify' _ _ _ _ _ _ (g°f)).
  eapply inverse. eapply composition; try apply inv_R.
  eapply inverse. eapply composition. 
  Focus 2.
  apply inv_R.
  eapply composition. apply assoc.
  apply left_compose'. 
  eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity.
  apply inv_R.
  eapply composition. apply id_L.
  apply identity.
Qed.


Lemma inv_inv (T:GroupoidType) (x y:[T]) (e : x ~ y) : 
  inverse (inverse e) ≡ e.
Proof.
  apply (left_simplify' _ _ _ _ _ _ (inverse e)).
  eapply composition. apply inv_R. eapply inverse. apply inv_L. 
Defined.

Lemma inv_id (T:GroupoidType) (x:[T]) : 
  inverse (identity x) ≡ identity x.
Proof.
  eapply inverse. eapply composition; [idtac | apply id_R].
  apply inverse. apply inv_L.
Qed.

Lemma comp_id (T:GroupoidType) (x:[T]) : 
  identity x ° identity x ≡ identity x.
Proof.
  eapply composition; try apply id_L. apply identity.
Qed.

(* end hide *)
(** **  Functors and natural transformations
%\label{sec:funextnat}%
A morphism between two groupoids is a functor, i.e., a function
between objects of the groupoids that transports homs and
subject to compatibility laws. 
*)

Class Functor {T U : CatType} (f : [T] -> [U]) : Type :=
  { _map : ∀ {x y}, x ~ y -> f x ~ f y ;
    _map_id : ∀ x, _map (identity x) ≡ identity (f x);
  _map_comp : ∀ {x y z} (e:x ~ y) (e':y ~ z), _map (e' ° e) ≡ _map e' ° _map e ;
  _map2 : ∀ {x y:[T]} {e e' : x ~ y}, (e ≡ e') -> _map  e ≡ _map e' }.

Definition Fun_Type (T U : CatType) := {f : [T] -> [U] & Functor f}.

Definition Fun_TypeG (T U : GroupoidType) := Fun_Type T U. 

(* begin hide *)

Infix "--->" := Fun_Type (at level 55). 

Notation "'map' f" := (_map (Functor := f.2)) (at level 0, f at level 0).
Notation map_id f := (_map_id (Functor := f.2)).
Notation map_comp f := (_map_comp (Functor := f.2)).
Notation map2 f := (_map2 (Functor := f.2)).

Hint Extern 0 (Functor [?f]) => exact (proj2 f) : typeclass_instances.

(* end hide *)
(** %\noindent% We note [T ---> U] the type of functors from [T] to [U].
Note that we only impose compatibility with the composition as
compatibilities with identities and inverse Homs can be deduced from
it. We note [M @ N] the application of a function [M] in the first
component of a dependent pair. *)
(* begin hide *)
Notation " M @ N " := ([M] N) (at level 20). 

Lemma map_id' {T U : GroupoidType} (f : T ---> U) {x} : map f (identity x) ≡ identity (f @ x).
Proof.
  apply (right_simplify' _ _ _ _ (map f (identity x))).
  eapply composition. eapply inverse, (map_comp f).
  eapply composition. eapply (map2 f). apply id_L. eapply inverse. apply id_L.
Defined.

Lemma map_inv {T U : GroupoidType} (f : T ---> U) :
  ∀ x y (e : x ~ y) , map f (inverse e) ≡ inverse (map f e).
Proof.
  intros. eapply right_simplify'.
  eapply composition. eapply inverse, (map_comp f).
  eapply composition. eapply (map2 f). apply inv_L.
  eapply composition. apply (map_id f). eapply inverse. apply inv_L.
Defined.

Opaque map_id' map_inv.

Instance arrow_id (T:CatType) : Functor (id (A := [T])) :=
  { _map x y e := e ;
    _map_id x := identity _;
    _map_comp x y z e e' := identity _ }.

Instance arrow_idG (T:GroupoidType) : Functor (id (A := [GroupoidTypeToCatType T]))
                                              := arrow_id T.

Instance id_fun : Identity Fun_Type :=
  { identity x := (id (A:=[x]) ; arrow_id _) }.

Instance id_funG : Identity Fun_TypeG :=
  { identity x := (id (A:=[x]) ; arrow_idG _) }.

Instance arrow_comp A B C (f : A ---> B) (g : B ---> C) : 
  Functor (λ x : [A], g @ (f @ x)) :=
  { _map x y e := map g (map f e) }.
Next Obligation. 
  eapply composition.
  eapply (map2 g). apply (map_id f). eapply (map_id g).
Defined. 
Next Obligation. 
  eapply composition.
  eapply (map2 g). apply (map_comp f e e'). eapply (map_comp g). 
Defined.
Next Obligation. apply (map2 g). apply (map2 f). auto. Defined.
 
Program Instance comp_fun : Composition Fun_Type :=
  { composition x y z X X0 := (λ x, X0 @ (X @ x) ; arrow_comp _ _ _ _ _) }.

(* end hide *)
(** Equivalence between functors is given by natural transformations.
  We insist here that this naturality condition in the definition of
  functional equality is crucial in a higher setting.  It is usually
  omitted in formalizations of homotopy theory in Coq because there they
  only consider the 1-groupoid case where the naturality becomes
  trivial, see for instance%≡\cite{coq_unival_axiom}%.  *)

Class NaturalTransformation T U {f g : T ---> U} (α : ∀ t : [T], f @ t ~ g @ t) := 
  _α_map : ∀ {t t'} (e : t ~ t'), α t' ° map f e ≡ map g e ° α t.

Definition nat_trans T U : HomT (T ---> U) 
 := λ f g, {α : ∀ t : [T], f @ t ~ g @ t & NaturalTransformation α}.

(* begin hide *)
Hint Extern 0 (NaturalTransformation [?f]) => exact (proj2 f) : typeclass_instances.

Notation α_map f := ((proj2 f)).
 
Instance nat_transHom T U : HomT1 (T ---> U) := {eq1 := nat_trans (T:=T) (U:=U)}.
(* end hide *)
(** In our setting, equality between natural transformations is not expressed using identity types, but using the higher categorical notion of modification.
*)

Definition modification_eq T U (f g : T ---> U) (α β : f ~ g) :
  (∀ t : [T], α @ t ≡ β @ t) -> α ≡ β.
  intro e. refine (path_sigma _ _ _ _).
  - apply path_forall. exact e.
  - apply path_forall; intro. apply path_forall; intro. apply path_forall; intro.
    apply UIP. 
Defined.

(* begin hide *)

(* Instance modificationHom T U : HomT2 eq1 := {eq2 := modification (T:=T) (U:=U)}. *)

Program Instance _nat_id T U (f : T ---> U) : 
  NaturalTransformation (λ t : [T], identity (f @ t)).
Next Obligation. 
Proof.
  intros. eapply composition. apply id_L.
  eapply inverse. apply id_R. 
Defined.

Program Instance nat_id T U : Identity (nat_trans (T:=T) (U := U)).
Next Obligation. 
  rename x into f. 
  exact (λ t, identity (f @ t); _nat_id _ _ f). 
Defined.

Program Instance nat_idG (T U:GroupoidType) : Identity (nat_trans (T:=T) (U := U))
  := {identity := @nat_id_obligation_1 T U}.

Program Instance _nat_inv (T U:GroupoidType) (f g : T ---> U) (H : nat_trans f g) :
  NaturalTransformation (λ t : [GroupoidTypeToCatType T], inverse  (H @ t)).
Next Obligation. intros. simpl in *. 
  eapply (left_simplify U).
  apply inv_L.
  eapply composition. eapply inverse; apply assoc.
  eapply composition. apply comp. apply identity.
  apply inv_R. eapply inverse.
  eapply composition. eapply inverse; apply assoc. 
  eapply composition. apply comp. apply identity.
  apply (α_map H). eapply composition. apply assoc.
  eapply composition. apply comp. apply inv_R.
  apply identity.
  eapply composition. apply id_R.
  eapply composition. apply identity. eapply inverse. apply id_L.
Defined.

Program Instance nat_inv (T U:GroupoidType) : Inverse (nat_trans (T:=T) (U := U)).
Next Obligation. rename x into f, y into g, X into H. 
       exact (λ t , inverse (H @ t); _nat_inv T U f g H). Defined.
  
Program Instance _nat_comp T U (f g h : T ---> U) (H : nat_trans f g) 
        (H' : nat_trans g h) : 
  NaturalTransformation (λ t : [T], (H' @ t) ° (H @ t)).

Next Obligation. 
Proof.
  intros. eapply composition. apply assoc.
  eapply composition. apply comp. apply (α_map H). apply identity.
  eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity. apply (α_map H').
  eapply composition. apply assoc. apply identity. 
Defined.

Program Instance nat_comp T U : Composition (nat_trans (T:=T) (U := U)).

Next Obligation. 
Proof.
  rename x into f, y into g, z into h,X into H, X0 into H'. 
  exact (λ t , composition (H @ t) (H' @ t); _nat_comp T U f g h H H').
Defined.

Program Instance nat_compG (T U:GroupoidType) :
  Composition (nat_trans (T:=T) (U := U)) :=
  {composition := @nat_comp_obligation_1 T U}. 
                                                            
Program Instance nat_equiv (T U:GroupoidType) : Equivalence (nat_trans (T:=T) (U := U)).

(* Program Instance nat2_id T U (f g : T ---> U) :  *)
(*   Identity (modification (f:=f) (g:=g)). *)
(* Next Obligation. exact (λ t, identity _). Defined. *)

(* Program Instance nat2_inv T U (f g : T ---> U) :  *)
(*   Inverse (modification (f:=f) (g:=g)). *)
(* Next Obligation. rename X into E. exact (λ t, inverse (E t)). Defined. *)

(* Program Instance nat2_comp T U (f g : T ---> U) : *)
(*   Composition (modification (f:=f) (g:=g)). *)
(* Next Obligation. rename X into E, X0 into  F. exact (λ t, (F t) ° (E t)). Defined. *)

(* Program Instance nat2_equiv T U (f g : T ---> U) : *)
(*   Equivalence (modification (f:=f) (g:=g)). *)

Program Instance nat_trans_cat T U : Category (T ---> U).
Next Obligation. apply modification_eq. intro t. apply id_R. Defined.
Next Obligation. apply modification_eq. intro t. apply id_L. Defined.
Next Obligation. apply modification_eq. intro t. apply assoc. Defined.
Next Obligation. apply modification_eq. intro t. apply comp.
                 apply (apD10 X..1). apply (apD10 X0..1). Defined.

Program Instance nat_trans_grp (T U:GroupoidType) : Groupoid (T ---> U).
Next Obligation. apply modification_eq. intro t. apply inv_R. Defined.
Next Obligation. apply modification_eq. intro t. apply inv_L. Defined.
Next Obligation. apply modification_eq. intro t. apply inv, (apD10 X..1). Defined.

(* Program Instance modification_eq T U (f g : T ---> U) :  *)
(*   Equivalence (modification (f:=f) (g:=g)). *)

(* Instance nat_groupoid (T U : GroupoidType) : Groupoid (T ---> U). *)
(* Next Obligation. *)
(*   apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ E E'))). *)
(*   apply contr_forall. intros z. *)
(*   apply (@is_Trunc_2 _ _ _ _ _ _ (E z) (E' z)). *)
(* Defined. *)

(* end hide *)
(** %\noindent%
    We can now equip the functor space with a groupoid structure. Note
    here that we (abusively) use the same notation for the functor type and 
    its corresponding groupoid. *)

Definition __fun T U : CatType := (T ---> U ; nat_trans_cat T U).

Definition _fun (T U:GroupoidType) : GroupoidType := (T ---> U ; nat_trans_grp T U).

(* begin hide *)

Infix "-->" := _fun (at level 90). 

(* end hide *)
(**
 In the definition above, [nat_trans_grp] is a proof that [nat_trans] and [modification] form a groupoid on [T ---> U]. In particular, it makes use of functional extensionality, which says that the canonical proof of [f = g -> ∀ x, f x = g x] is an equivalence (in the sense of homotopy type theory).   
 *)

(* begin hide *)

Instance FunTypeHom : HomT1 CatType := {eq1 := Fun_Type}.

Instance FunTypeHomG : HomT1 GroupoidType := {eq1 := Fun_Type}.

(* Instance nat_transHom' : HomT2 Fun_Type := {eq2 := nat_trans}. *)

(* Program Instance category_fun : Category GroupoidType.  *)

Definition nat_id_R : ∀ x y (f : x ---> y),
                        f ° identity x ~ f.
  intros. exists (λ t , identity _).
  intros t t' e. 
  eapply composition. apply id_L. eapply inverse. apply id_R.
Defined.

Definition nat_id_L : ∀ x y (f : x ---> y),
                        identity y ° f ~ f.
  intros. exists (λ t , identity _). intros t t' e.
  eapply composition. apply id_L. eapply inverse. apply id_R.
Defined.

Definition nat_assoc : ∀ x y z w (f: x ---> y) (g: y ---> z) (h: z ---> w),
                         (h ° g) ° f ~ h ° (g ° f).
  intros. exists (λ t , identity _).  intros t t' e.
  eapply composition. apply id_L. eapply inverse. apply id_R.
Defined.

Definition nat_comp' : ∀ x y z (f f': x ---> y) (g g': y ---> z), 
                       f ~ f' -> g ~ g' -> g ° f ~ g' ° f'.
  intros. exists (λ t , map g' (X @ t) ° (X0 @ (f @ t))). intros t t' e.
  eapply composition. apply assoc.
  eapply composition. apply comp. apply (α_map X0). apply identity.
  eapply composition. eapply inverse. apply assoc. eapply inverse.
  eapply composition. eapply inverse. apply assoc.
  apply comp. apply identity. eapply composition.
  Focus 2. eapply composition. Focus 2. apply (map_comp g').
  eapply (map2 g'). eapply inverse. apply (α_map X).
  eapply inverse. simpl. apply (map_comp g').
Defined.

Program Instance _eq : ∀ (T U : GroupoidType), 
                         Equivalence (nat_trans (T:=T) (U:=U)).
 
(* Definition nat_id_R  := id_R (Category := category_fun). *)
(* Definition nat_id_L  := id_L (Category := category_fun). *)
(* Definition nat_assoc := assoc (Category := category_fun). *)
(* Definition nat_comp'  := comp (Category := category_fun). *)

(* Lemma nat_comp2 A B C (f f': A ~ B) (g g' : B ~ C)  *)
(*       (H H': f ~ f') (G G' : g ~ g') (e: H ≡ H') (e':G ≡ G') : *)
(*     nat_comp' H G ≡ nat_comp' H' G'. *)
(* Proof. *)
(*   intro a. simpl. apply comp. apply e'. apply (map2 g' (e a)). *)
(* Defined. *)

(* Lemma nat_comp_id A B C (f : A ---> B) (g : B ---> C) : *)
(*     nat_comp' (identity f) (identity g) ≡ identity _. *)
(* Proof. *)
(*   intro a. simpl in *. eapply composition. apply id_R. apply (map_id g). *)
(* Defined. *)

(* Tactics for simplification of goals containing [identity] applications. *)

Ltac simpl_id_end' := eapply composition ; [match goal with
                   | [ |- seq (?P ^-1 ° ?P) _] => 
                     apply inv_L
                   | [ |- seq (?P ° ?P ^-1) _] => 
                     apply inv_R
                   | [ |- seq (?P ° identity ?x) _] => 
                     apply id_R
                   | [ |- seq (identity ?x ° ?P) _] => 
                     apply id_L
                   | [ |- seq ((?P ^-1)^-1) _] => 
                     apply inv_inv
                   | [ |- seq ((identity ?T)^-1) _] => 
                     apply (inv_id T)
                 end | idtac].

Ltac simpl_id_end_extended' := first [ simpl_id_end' |
                                      match goal with
                   | [ |- seq ?e _ ] => apply (identity e)
                   | [ |- _ ] => idtac
                 end].

Ltac simpl_id' := first [simpl_id_end' ; simpl_id' |
                        match goal with
                   | [ |- seq ((identity _) ^-1) _] => apply inv_id
                   | [ |- seq (?P ^-1) _] => eapply composition;
                              [apply inv ; simpl_id' | idtac]; 
                              try apply identity
                   | [ |- seq (map ?F (identity _)) _] => eapply composition;
                              [eapply (map_id F); simpl_id' | idtac]; 
                              simpl_id'
                   | [ |- seq (map ?F ?P) _] => first [
                          eapply composition;
                              [eapply (map2 F); simpl_id' | idtac]; 
                              [apply identity | idtac] | 
                          (progress_evars (eapply composition;
                              [eapply (map2 F); simpl_id' | idtac]; instantiate)) (* ; simpl_id' *) |
                          idtac]
                   | [ |- seq (?Q ° ?P) _] => eapply composition;
                                             [apply comp; simpl_id' | idtac];
                                            simpl_id_end_extended'
                   | [ |- seq ?e _ ] => first [has_evar e; idtac | apply (identity e)]
                   | [ |- _ ] => idtac
                 end].

Ltac simpl_id_bi' := simpl_id'; eapply inverse; simpl_id'.

(* end hide *)
(**  ** Homotopic equivalences
 %\label{sec:homequiv}%   
    The standard notion of equivalence between groupoids is given by
    adjoint equivalences, that is a map with an [adjoint] and two proofs
    that they form a [section] (or counit of the adjunction) and a
    [retraction] (or unit of the adjunction). *)
(* begin hide *)
(* Definition Fun_Type_Setoid (T U : SetoidType) := T ---> U. *)

(* Infix "-S->" := Fun_TypeG (at level 55). *)

(* Definition _Fun_Setoid_ T U (f g : T -S-> U) (e e' : nat_trans f g) : e ≡ e'. *)
(*   refine (path_sigma _ _ _ _). *)
(*   apply path_forall. intros z.  *)
(*   apply is_Trunc_1. *)
(*   apply (path_sigma _ _ X).  *)
(*   apply NaturalTransformationSeq. *)
(* Defined. *)

(* Instance _Fun_Setoid (T U : SetoidType) : Setoid (T -S-> U). *)
(* Next Obligation.  *)
(*   apply (@contr_equiv _ _ _ (path_sigma_equiv e e')). *)
(*   apply (@contr_sigma _ (fun p => p # e.2 = e'.2)). *)
(*   apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ [e] [e']))). *)
(*   apply contr_forall. intros z. *)
(*   apply (@is_Trunc_1 _ _ _ _ (e @ z) (e' @ z)). *)
(*   intros.   destruct e, e'. simpl in *. destruct a. simpl.  *)
(*   apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ _ _))). *)
(*   apply contr_forall. intros t.  *)
(*   apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ _ _))). *)
(*   apply contr_forall. intros t'.  *)
(*   apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ _ _))). *)
(*   apply contr_forall. intros e.  *)
(*   apply (@is_Trunc_2 _ _ _ _ _ _ _ _). *)
(* Defined. *)

(* Definition Fun_Setoid (T U : SetoidType) := (T -S-> U; _Fun_Setoid T U) : SetoidType. *)

(* Infix "-|->" := Fun_Setoid (at level 55).  *)

(* end hide *)

Class Iso_struct (T U:GroupoidType) (f : T ---> U) := 
{ _adjoint :    [U --> T];
  _section :    f ° _adjoint ~ identity U ;
  _retraction : _adjoint ° f ~ identity T}.

(* begin hide *)

Definition Iso (A B : GroupoidType) := {f : A ---> B & Iso_struct f}.

(* Notations for [Iso] projections. *)

Notation adjoint' f := (_adjoint (Iso_struct := f.2)).
Notation section' f := (_section (Iso_struct := f.2)).
Notation retraction' f := (_retraction (Iso_struct := f.2)).

(* end hide *)
(** This type class defines usual equivalences. To get an adjoint
    equivalence, an additional triangle identity between sections and
    retractions is required. This allows to eliminate a section against
    a retraction in proofs. A corresponding triangle identity involving
    [adjoint f] can also be expressed, but it can be shown that each
    condition implies the other.  *)

(* Notation "'Equiv_struct' f" := (Iso_struct f) (at level 80). *)

Class Equiv_struct (T U : GroupoidType) (f : T ---> U) :=
{ iso : Iso_struct f;
  _triangle : ∀ t, _section @ (f @ t) ≡ map f (_retraction @ t)}.

Definition Equiv (A B : GroupoidType) := {f : A ---> B & Equiv_struct f}.


(* begin hide *)

Hint Extern 0 (Equiv_struct [?f]) => exact (proj2 f) : typeclass_instances.
Hint Extern 0 (Iso_struct [?f]) => exact (@iso (proj2 f)) : typeclass_instances.

(* Notations for [Equiv] projections. *)
Notation adjoint f := (_adjoint (Iso_struct := iso (Equiv_struct := f.2))).
Notation section f := (_section (Iso_struct := iso (Equiv_struct := f.2))).
Notation retraction f := (_retraction (Iso_struct := iso (Equiv_struct := f.2))).
Notation triangle f := (_triangle (Equiv_struct := f.2)).

Infix "<~>" := Equiv (at level 55). 

Hint Extern 0 (Equiv_struct [?f]) => exact (proj2 f) : typeclass_instances.

(* Notations for [Equiv] projections. *)

Program Definition map_trans A B (f : [A --> B]) : f ~ f :=
  ((fun t => map f (identity t)); _).

Next Obligation.
Proof.
  intros t t' e. simpl.
  eapply composition. eapply composition. apply comp. apply identity.
  apply (map_id f). apply id_L. apply inverse.
  eapply composition. apply comp. apply (map_id f). apply identity. apply id_R.
Defined.

Program Instance EquivToIso_ A B (f : A <~> B) : Iso_struct [f].
Next Obligation. exact (adjoint f). Defined.
Next Obligation. exact (section f). Defined.
Next Obligation. exact (retraction f). Defined.

Definition EquivToIso A B (f : A <~> B) := ([f]; EquivToIso_ _ _ f).

Lemma Equiv_map_injective {A B} (f: Iso A B) {x y : [A]} (e e': x ~ y) :
  map [f] e ≡ map [f] e' -> e ≡ e'.
Proof.
  intros H. apply (map2 (adjoint' f)) in H.
  eapply (left_compose' A) in H.
  eapply composition in  H. Focus 2. eapply inverse. apply (α_map (retraction' f)).
  apply inverse in H.
  eapply composition in  H. Focus 2. eapply inverse. apply (α_map (retraction' f)).
  apply right_simplify' in H. exact (inverse H).
Defined.

Program Instance _Iso_inv {A B} (f : Iso A B) : Iso_struct (adjoint' f).
Next Obligation. exact [f]. Defined.
Next Obligation. exact (retraction' f). Defined.
Next Obligation. exact (section' f). Defined.

Instance _Type_iso_inv : Inverse Iso := 
  { inverse T U f := (adjoint' f ; _Iso_inv f) }.

Lemma nat_on_id A (f : [A --> A]) (α : f ~ identity A) (a:[A]) : 
  α @ (f @ a) ≡ map f (α @ a).
Proof.
  eapply left_simplify'. apply inverse. apply (α_map α).
Defined.

Definition triangle' A B (f : A <~> B) : 
  forall u, map (adjoint f) (section f @ u) ≡ (retraction f @ _).
Proof.
  intros.
  assert (triangle := triangle f (adjoint f @ u)).
  assert (foo := α_map (section f) _ _ (section f @ u)). simpl in foo.
  apply (map2 (adjoint f)) in foo. 
  eapply composition in foo. Focus 2.
  eapply inverse. apply (map_comp (adjoint f)). 
  eapply inverse in foo. eapply composition in foo. Focus 2.
  eapply inverse. apply (map_comp (adjoint f)). 
  eapply composition in foo. Focus 2. apply comp. 
  eapply inverse. apply (map2 (adjoint f) triangle). apply identity.
  eapply composition in foo. Focus 2. apply comp. 
  apply (nat_on_id (retraction f)). apply identity.
  eapply composition in foo. Focus 2. 
  apply (α_map (retraction f) _ _ (map (adjoint f) (section f @ u))). 
  eapply right_simplify'. eapply inverse. apply foo.
Defined.

Definition HorCompN {x y z}
           {f f' : x ---> y} {g g' : y ---> z} :
  f ~ f' -> g ~ g' -> g ° f ~ g' ° f' :=
  @nat_comp' _ _ _ f f' g g'.

Infix "*N*" := HorCompN (at level 50).

Program Instance IsoToEquiv'' A B (f : Iso A B) : Iso_struct [f].
Next Obligation. exact (adjoint' f). Defined.
Next Obligation. 
  pose (F := (map_trans (adjoint' f)) *N* retraction' f *N* map_trans [f]).
  pose (idL := nat_id_L (adjoint' f)).
  pose (idLf := idL *N* map_trans [f]).
  pose (G := map_trans (adjoint' f) *N* map_trans [f] *N* section' f).
  pose (ass := nat_assoc (adjoint' f) [f] (adjoint' f) *N* map_trans [f]).
  pose (idR := nat_id_L ([f] °adjoint' f)).
  pose (idRf := inverse idR).
  pose (ass' := nat_assoc ([f] ° adjoint' f) (adjoint' f) [f]).
  exact (section' f ° idLf ° F ° inverse ass ° ass' ° inverse G ° idRf).
Defined.
Next Obligation. exact (retraction' f). Defined.

Definition IsoToEquiv' A B (f : Iso A B) := ([f] ; IsoToEquiv'' _ _ f).

Program Instance IsoToEquiv_ A B (f : Iso A B) : Equiv_struct [f].
Next Obligation. simpl. simpl_id'. simpl_id'.
                 unfold IsoToEquiv''_obligation_3.
                 eapply (right_simplify' B). eapply composition. apply assoc.
                 eapply composition. apply comp. apply inv_L. apply identity.
                 simpl_id'. eapply composition. apply comp.
                 apply (map2 [f] (nat_on_id (retraction' f) t)). apply identity.
                 simpl in *. apply (α_map (section' f)).
Defined.

(* end hide *)
(** 
   It is well known that any equivalence can be turned into an adjoint
   equivalence by slighty modifying the section. While available in
   our formalization, this result should be used with care as it
   opacifies the underlying notion of homotopy and can harden proofs.
*)

(* begin hide *)

Definition IsoToEquiv A B (f : Iso A B) : Equiv A B.
Proof. exact ([f]; IsoToEquiv_ _ _ f). Defined.

(** Definition of identity homotopy equivalence *)

Program Instance __Equiv_Id {T:GroupoidType} : Iso_struct (identity T).
Next Obligation. exact (identity T). Defined.
Next Obligation. 
Proof.
  exact (λ t , identity t; _nat_id T T (identity T)). 
Defined.
Next Obligation. 
Proof. 
  exact (λ t , identity t; _nat_id T T (identity T)). 
Defined.

Program Instance _Equiv_Id {T:GroupoidType} : Equiv_struct (identity T).
Next Obligation. apply identity. Defined.

Instance _Type_id : Identity Equiv := { identity T := (identity T ; _Equiv_Id) }.

(** Definition of inverse of homotopy equivalence **)

Program Instance __Equiv_inv {A B} (f : A <~> B) : Iso_struct (adjoint f).
Next Obligation. exact [f]. Defined.
Next Obligation. exact (retraction f). Defined.
Next Obligation. exact (section f). Defined.

Program Instance _Equiv_inv {A B} (f : A <~> B) : Equiv_struct (adjoint f).
Next Obligation. apply inverse. apply (triangle' f _). Defined.

Instance _Type_inv : Inverse Equiv := 
  { inverse T U f := (adjoint f ; _Equiv_inv f) }.

Instance Adjoint_Functor T U (f : T <~> U) : Functor [adjoint f] :=
  Π2 (adjoint f).
  
Program Instance __Equiv_comp {A B C} (f : A <~> B) (g : B <~> C) : 
  Iso_struct ([g] ° [f]).
Next Obligation. exact (adjoint f ° adjoint g). Defined.

Obligation Tactic := intros.

Next Obligation. 
Proof. eapply composition. apply nat_assoc. 
  eapply composition. apply nat_comp'. eapply composition. 
  eapply inverse, nat_assoc.
  eapply composition. apply nat_comp'. apply identity. apply (section f).
  apply nat_id_L. apply identity. apply (section g).
Defined.
Next Obligation. 
  eapply composition. apply nat_assoc.
  eapply composition. apply nat_comp'. eapply composition. 
  eapply inverse, nat_assoc.
  eapply composition. apply nat_comp'. apply identity. eapply (retraction g).
  apply nat_id_L. apply identity. eapply (retraction f). 
Defined.

Program Instance _Equiv_comp {A B C} (f : A <~> B) (g : B <~> C) : 
  Equiv_struct ([g] ° [f]).

Next Obligation. 
Proof.
  simpl. simpl_id_bi'.
  apply inverse. eapply composition.
  apply comp. apply identity. apply (triangle g).
  eapply composition. eapply inverse. apply (map_comp [g]). apply (map2 [g]).
  eapply composition. eapply inverse. apply (α_map (section f)).
  eapply composition. apply comp. apply identity. apply (triangle f). 
  eapply inverse. apply (map_comp [f]). 
Defined.

Instance _Type_comp : Composition Equiv := 
  { composition T U V f g := ([g] ° [f] ; _Equiv_comp f g) }.

(* end hide *)
(** Equality of homotopy equivalences is given by equivalence of
  adjunctions. Two adjunctions are equivalent if their left adjoint are
  equivalent and they agree on their sections (up-to the isomorphism).
  Note that equivalence of the right adjoints and agreement on their
  retractions can be deduced so they are not part of the definition.  *)
(* begin hide *)

Definition Equiv_adjoint {A B} {f f': Equiv A B} : 
  [f] ~ [f'] -> adjoint f ~ adjoint f'.
Proof.
  intro.
  eapply composition. eapply inverse. apply nat_id_L.
  eapply composition. apply nat_comp'. apply identity. 
  apply (inverse (retraction f')). eapply composition. apply nat_assoc. 
  eapply composition. apply nat_comp'. 
  eapply composition. apply nat_comp'. apply identity. apply (inverse X).
  apply (section f). apply identity. apply nat_id_R.
Defined.

Lemma Equiv_injective A B (f: A <~> B) x y : [f] @ x ~ [f] @ y -> x ~ y.
Proof.
  intros e. 
  eapply composition. pose (inverse (retraction f)). apply [n].
  eapply inverse. eapply composition; pose (inverse (retraction f)). apply [n].
  apply (map (adjoint f) (inverse e)).
Defined.


Definition Equiv_adjoint_simpl A B (f f': A <~> B) (H: [f] ~ [f']) a :
  [Equiv_adjoint H] a ≡ 
     map (adjoint f') ([section f] a ° inverse ([H] ([adjoint f] a)))
   ° [inverse (retraction f')] ([adjoint f] a).
Proof.
  unfold Equiv_adjoint. simpl. simpl_id'. simpl_id'.
Defined.

Opaque Equiv_adjoint.

Lemma triangle_inv' A B (f : A <~> B) : forall u,
  map (adjoint f) (section f @ u) ° inverse (retraction f @ _) ≡ identity _.
Proof.
  intro. eapply composition. apply comp. apply identity.
  apply (triangle' f). apply inv_R.
Defined.

Lemma triangle_inv A B (f : A <~> B) : ∀ t,
  (section f @ ([f] @ t)) ° map [f] ((inverse (retraction f)) @ t) ≡ identity _.
Proof.
  intro. eapply composition. apply comp. apply identity. apply (triangle f).
  eapply composition. apply comp. apply map_inv. apply identity. apply inv_R.
Defined.

Lemma Equiv_adjoint_id A B (f : A <~> B) :
 (Equiv_adjoint (identity [f])) ≡ (identity _).
Proof.
  apply modification_eq.
  intro b. eapply composition. apply Equiv_adjoint_simpl.
  eapply composition. apply comp. apply identity. eapply composition. eapply (map2 (adjoint f)).
  eapply composition. apply comp. apply inv_id. apply identity. apply id_R.
  apply identity. apply (triangle_inv' f).
Defined.

Lemma Equiv_adjoint2 A B (f g: A <~> B) (H H': [f] ~ [g] ) (e : H≡ H'):
 Equiv_adjoint H ≡ Equiv_adjoint H'.
Proof.
  apply modification_eq.
  intro b. eapply composition. apply Equiv_adjoint_simpl.
  eapply inverse.  eapply composition. apply Equiv_adjoint_simpl.
  apply comp; try apply identity. apply (map2 (adjoint g)).
  apply comp; try apply identity. apply inv. eapply inverse. apply (apD10 e..1).
Defined.  

Lemma Equiv_adjoint_inv A B (f g: A <~> B) (H : [f] ~ [g] ) :
 Equiv_adjoint H ° Equiv_adjoint (inverse H) ≡ identity _.
Proof.
  apply modification_eq.
  intro b. eapply composition. apply comp; apply Equiv_adjoint_simpl.
  eapply composition. apply assoc. eapply composition. apply comp.
  apply (α_map ((inverse (retraction g)) : nat_trans _ _)). 
  apply (map_comp (adjoint g)).
  eapply composition. apply assoc. eapply composition. apply comp.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity. eapply composition. 
  eapply inverse, (map_comp (adjoint g)). eapply composition.
  eapply (map2 (adjoint g)).
  assert (foo := Π2 (inverse H)). apply foo.
  apply (map_comp (adjoint g)). apply identity. apply identity.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity.
  eapply composition. eapply inverse, (map_comp (adjoint g)). eapply composition.
  eapply (map2 (adjoint g)). eapply composition. apply comp.
  apply (map_comp [f]). apply identity.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity.
  apply (α_map (section f)). simpl. 
  eapply composition. apply assoc. eapply composition.
  apply comp. apply (triangle_inv f). apply identity. apply id_R. 
  apply (map_comp (adjoint g)).
  eapply composition. apply assoc. eapply composition. apply comp.
  eapply composition. eapply inverse, (map_comp (adjoint g)). eapply composition.
  eapply (map2 (adjoint g)). apply inv_L. apply (map_id (adjoint g)). 
  apply identity. apply id_R. apply (triangle_inv' g).
Defined.

Lemma Equiv_adjoint_comp A B (f f' f'': A <~> B) (H : [f] ~ [f']) (H' : [f'] ~ [f'']):
 Equiv_adjoint (H' ° H) ≡ Equiv_adjoint H' ° Equiv_adjoint  H.
Proof.
  apply modification_eq.
  intro b. eapply composition. apply Equiv_adjoint_simpl.
  eapply composition. apply comp. apply identity.  eapply composition. 
  eapply (map2 (adjoint f'')).
  apply comp. eapply inverse, comp_inv. apply identity.
  eapply composition. apply (map_comp (adjoint f'')). apply comp.
  apply (map_comp (adjoint f'')). apply identity.
  eapply inverse. eapply composition. apply comp; apply Equiv_adjoint_simpl.
  eapply composition. apply assoc. eapply composition. apply comp.
  apply (α_map (inverse (retraction f'') : nat_trans _ _)). 
  apply (map_comp (adjoint f'')).
  eapply composition. apply assoc. eapply composition. apply comp.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity.
  eapply composition. eapply inverse, (map_comp (adjoint f'')). 
  eapply composition. eapply (map2 (adjoint f'')).
  assert (foo := Π2 (inverse H')). apply foo.
  apply (map_comp (adjoint f'')). apply identity. apply identity.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity.
  eapply composition. eapply inverse, (map_comp (adjoint f'')). 
  eapply composition. eapply (map2 (adjoint f'')). 
  eapply composition. apply comp.
  apply (map_comp [f']). apply identity.
  eapply composition. eapply inverse; apply assoc. eapply composition. 
  apply comp. apply identity.
  apply (α_map (section f')). simpl. 
  eapply composition. apply assoc. eapply composition.
  apply comp. apply (triangle_inv f'). apply identity.
  apply id_R. apply (map_comp (adjoint f'')).
  eapply composition. apply assoc. eapply composition. apply comp.
  eapply composition. eapply inverse, (map_comp (adjoint f'')). 
  eapply composition. eapply (map_comp (adjoint f'')). 
  apply identity. apply identity. apply identity. apply identity.
Defined.

Notation  "g °' f" := (nat_comp' f g) (at level 50). 

(* end hide *)

Class EquivEq {T U} {f g : Equiv T U} (α : [f] ~ [g]) : Type :=  
 _eq_section : section f ≡ section g ° (α °' (Equiv_adjoint α)). 

Definition Equiv_eq T U (f g : Equiv T U) := {α : nat_trans [f] [g] & EquivEq α}.

(** It is crucial here to be able to express the 2-dimensional equality
  between groupoids as a particular [Type] and not directly using the
  identity type. Indeed, whereas the functional extensionality principle
  makes the use of the identity type and modification equivalent to
  treat equality of natural transformations, the same is not possible
  for homotopy equivalences.  *)
(* begin hide *)

Hint Extern 0 (EquivEq [?α]) => apply α.2 : typeclass_instances.

Notation eq_section α := α.(proj2).

Definition eq_retraction {T U} {f g : T <~> U} (α:Equiv_eq f g) : 
  retraction f ≡
  retraction g ° (nat_comp' [α] (Equiv_adjoint [α])).
Proof.
  apply modification_eq.
  intro. apply (Equiv_map_injective (EquivToIso f)). simpl.
  eapply composition. eapply inverse. apply (triangle f).
  eapply composition. apply (apD10 (eq_section α)..1). simpl. apply inverse.
  eapply composition. apply (map_comp f.1).
  eapply left_simplify'. eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity.
  apply (α_map [α]). unfold id. 
  eapply composition. apply assoc. eapply composition. apply comp. apply identity.
  eapply inverse. apply (triangle g). apply inverse.
  eapply composition. apply comp. apply comp. eapply inverse. apply (α_map [α]).
  apply identity. apply identity. 
  eapply composition. eapply inverse. apply assoc. 
  eapply composition. apply comp. apply identity.
  eapply inverse. apply (α_map (section g)). eapply composition. apply assoc.
  apply comp; [idtac | apply identity].
  eapply composition. eapply inverse. apply assoc. apply inverse.
  eapply composition. apply comp. refine (_map_comp _ _). apply identity.
  eapply composition. eapply inverse. apply assoc.
  apply comp; [apply identity | idtac]. apply (α_map [α]).
Defined.

(* Definition AllEquivEq_Setoid : forall (T U : SetoidType) (f g : T <~> U)  *)
(*                                (α : nat_trans [f] [g]), *)
(*                      EquivEq α. *)
(*   intros. intro u. apply setoid_irr2. Defined. *)

(* Axiom AllEquivEq : forall (T U : GroupoidType) (f g : T <~> U)  *)
(*                                (α : nat_trans [f] [g]), *)
(*                      EquivEq α. *)
  
Lemma ExLawComp_nat A B C (f f' f'': A ~ B) (g g' g'' : B ~ C) 
      (H:f ~ f') (H': f' ~ f'') (G : g ~ g') (G': g' ~ g'') :
    nat_comp' (H' ° H) (G' ° G) ≡ nat_comp' H' G' ° nat_comp' H G.
Proof.
  apply modification_eq.
  intro a. simpl. eapply composition. 
  apply comp. apply identity. apply (map_comp g''). 
  eapply composition. apply assoc. eapply inverse.
  eapply composition. apply assoc. apply comp; try apply identity. 
  eapply composition. eapply inverse. apply assoc. 
  eapply composition. apply comp. apply identity.
  apply (Π2 G'). eapply composition. apply assoc. apply identity.
Defined.

Lemma nat_comp2 A B C (f f': A ~ B) (g g' : B ~ C) 
      (H H': f ~ f') (G G' : g ~ g') (e: H ≡ H') (e':G ≡ G') :
    nat_comp' H G ≡ nat_comp' H' G'.
Proof.
  apply modification_eq. intro a. simpl. apply comp.
  apply (apD10 e'..1). apply (map2 g' (apD10 e..1 a)).
Defined.

Lemma nat_comp_id A B C (f : A ---> B) (g : B ---> C) :
    nat_comp' (identity f) (identity g) ≡ identity _.
Proof.
  apply modification_eq.
  intro a. simpl in *. eapply composition. apply id_R. apply (map_id g).
Defined.

Program Instance Id_Equiv_eq T U : Identity (Equiv_eq (T:=T) (U:=U)).
Next Obligation. 
Proof.
  exists (identity [x]).
  apply modification_eq. intro u. eapply composition. eapply inverse. apply id_R.
  apply comp; try apply identity. eapply inverse. 
  eapply composition. 
  eapply (apD10 (nat_comp2 (Equiv_adjoint_id _) (identity _))..1 u). 
  apply (apD10 (nat_comp_id _ _)..1 u).
Defined.                 

Program Instance Inv_Equiv_eq T U : Inverse (Equiv_eq (T:=T) (U:=U)).
Next Obligation.
Proof.
  rename x into f, y into g. 
  exists (inverse [X]).
  rename X into α.
  apply modification_eq.
  intro u. eapply inverse; eapply composition. apply comp. apply identity.
  apply (apD10 (eq_section α)..1).
  eapply composition. apply assoc. 
  eapply composition. apply comp. eapply composition. eapply inverse.
  apply (apD10 (ExLawComp_nat _ _ _ _)..1 u).
  eapply composition. 
  refine (apD10 (nat_comp2 _ _)..1 _). apply identity. apply identity.
  apply Equiv_adjoint_inv. 
  apply (inv_R (Groupoid := nat_trans_grp T U)).
  apply (apD10 (nat_comp_id _ _)..1 u). apply identity. apply id_R.
Defined.

Program Instance Comp_Equiv_eq T U : Composition (Equiv_eq (T:=T) (U:=U)).

Next Obligation. 
Proof.
  rename x into f, y into g, z into h, X into H, X0 into H'. 
  exists (composition [H] [H']).
  rename H into α. rename H' into β. 
  apply modification_eq. intro u. eapply composition. apply (apD10 (eq_section α)..1). 
  eapply composition. apply comp. apply identity.
  apply (apD10 (eq_section β)..1). eapply composition. apply assoc.
  apply comp; try apply identity. 
  eapply composition. eapply inverse. 
  apply (apD10 (ExLawComp_nat _ _ _ _)..1 u).
  apply (fun a b => apD10 (nat_comp2 a b)..1 u); try apply identity .
  eapply inverse, Equiv_adjoint_comp.
Defined.

Instance Equiv_eqHom (T U :GroupoidType) : HomT1 (Equiv T U) := 
  {eq1 := Equiv_eq (T:=T) (U:=U) }.

Definition Equiv_eq_prop (T U :GroupoidType) (f g : Equiv T U) 
  (e e' : Equiv_eq f g): (∀ t : [T], [e] @ t ≡ [e'] @ t) -> e ≡ e'.
  intro X. refine (path_sigma _ _ _ _). apply modification_eq. exact X.
  apply UIP.
Defined.

(* (* Instance Equiv_eq2Hom (T U :GroupoidType) : HomT2 (Equiv_eq (T:=T) (U:=U)) :=  *) *)
(* (*   {eq2 := Equiv_eq2 (T:=T) (U:=U) }. *) *)

(* Instance Equiv2_id (T U :GroupoidType) (f g : T <~> U) :  *)
(*   Identity (@Equiv_eq2 _ _ f g)  := { identity x := identity [x]}. *)

(* Program Instance Equiv2_inv (T U :GroupoidType) (f g : T <~> U) :  *)
(*   Inverse (Equiv_eq2 (f:=f) (g:=g)) *)
(*   := *)
(*   { inverse X Y e := @inverse _ _ (inv_seq _) _ _ e}. *)

(* Program Instance Equiv2_comp (T U :GroupoidType) (f g : T <~> U) :  *)
(*   Composition (Equiv_eq2 (f:=f) (g:=g)) := *)
(*   { composition X Y Z e e' := concat e e' }. *)

(* Program Instance Equiv2_equiv (T U :GroupoidType) (f g : T <~> U) :  *)
(*   Equivalence (Equiv_eq2 (f:=f) (g:=g)). *)

Program Instance Equiv_eq_cat T U : Category (T <~> U).
Next Obligation. apply Equiv_eq_prop. intro t. destruct f. apply id_R. Defined.
Next Obligation. apply Equiv_eq_prop. intro t. destruct f; apply id_L. Defined.
Next Obligation. apply Equiv_eq_prop. intro t. destruct f, g, h. apply assoc. Defined.
Next Obligation. apply Equiv_eq_prop.
  intro t. destruct f, g, f', g'. 
  apply comp. apply (apD10 (X..1)..1). apply (apD10 X0..1..1). 
Defined.

Program Instance Equiv_eq_grp T U : Groupoid (T <~> U).
Next Obligation. apply Equiv_eq_prop. intro t. destruct f; apply inv_R. Defined.
Next Obligation. apply Equiv_eq_prop. intro t. destruct f; apply inv_L. Defined.
Next Obligation. apply Equiv_eq_prop. intro t. destruct f, f'. apply inv. exact (apD10 X..1..1 t). Defined.

Definition section_comp_l (X Y Z : GroupoidType) 
           (f : X <~> Y) (g : Y <~> Z) (z : [Z]) :=
  (section (g ° f) @ z).

Lemma section_comp (X Y Z : GroupoidType) 
      (f : X <~> Y) (g : Y <~> Z) (z : [Z]) :
  section_comp_l f g z ≡ (section g @ z) ° map [g] (section f @ (adjoint g @ z)).
Proof.  
  unfold section_comp_l. simpl. simpl_id_bi'.
Defined.

Definition retraction_comp_l (X Y Z : GroupoidType) 
           (f : X <~> Y) (g : Y <~> Z) (z : [X]) :=
  retraction (g ° f) @ z.

Lemma retraction_comp X Y Z (f : X <~> Y) (g : Y <~> Z) z :
  retraction_comp_l f g z ≡ 
  [retraction f] z ° map (adjoint f) ([retraction g] ([f] @ z)).
Proof. 
  unfold retraction_comp_l.
  simpl. simpl_id_bi'.
Defined.

Lemma Equiv_adjoint_idR X Y (f : X <~> Y)
      (H := nat_id_R [f]:[f ° identity X] ~ [f]) (y : [Y]) :
  Equiv_adjoint H @ y ≡ identity (adjoint f) @ y.
  eapply composition. apply Equiv_adjoint_simpl. simpl.
  unfold id, _Equiv_comp_obligation_1.
  simpl_id'. simpl_id'. simpl. apply (triangle_inv' f).
Defined.

Lemma Equiv_adjoint_idL X Y (f : X <~> Y) 
      (H := (nat_id_L [f]:[identity _°f] ~ [f])) (y : [Y]) :
   Equiv_adjoint H @ y ≡ identity (adjoint f) @ y.
Proof.
  eapply composition. apply Equiv_adjoint_simpl. simpl.
  unfold id, _Equiv_comp_obligation_1.
  simpl_id'. apply (triangle_inv' f).
Defined.

Instance EquivHom : HomT1 GroupoidType := {eq1 := Equiv}.

Definition Equiv_adjoint_assoc (X Y Z W : GroupoidType)
        (f : X <~> Y) (g : Y <~> Z) (h : Z <~> W) (w:[W]) 
        (H := (nat_assoc [f] [g] [h] : [(h ° g) °f] ~ [h ° (g ° f)])) : 
    (Equiv_adjoint H @ w) ≡ (identity (adjoint ((h ° g) °f)) @ w).
Proof.
  simpl. eapply composition. apply (Equiv_adjoint_simpl _ _ H w). simpl.
  simpl_id'.
  eapply composition. apply comp. eapply composition. eapply inverse.
  apply comp_inv. apply comp. eapply composition. eapply inverse.
  apply comp_inv. apply comp. apply identity.
  eapply composition. eapply inverse. apply map_inv.
  eapply (map2 (adjoint f)). apply identity.
  eapply composition. eapply inverse. simpl.
  apply map_inv.
  eapply (map2 (adjoint f)).
  eapply composition. eapply inverse. apply map_inv.
  eapply (map2 (adjoint g)). apply identity. apply identity.
  eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity.
  eapply composition. eapply inverse. apply (map_comp (adjoint f)).
  eapply (map2 (adjoint f)). eapply composition. eapply inverse. apply (map_comp (adjoint g)).
  eapply (map2 (adjoint g)). eapply composition. apply comp. apply identity. eapply composition.
  apply _map_comp.
  apply comp. apply identity. apply _map_comp.
  eapply composition. apply assoc. eapply composition. apply comp.
  eapply inverse.
  (* The anotation is necessary as typeclass resolution  *)
  (*    is run only after unification *)
  apply (α_map (@inverse _ _ (nat_inv Z Z) _ _ (retraction h))).
  apply identity.
  eapply composition. apply assoc. eapply composition. apply comp.
  eapply composition. eapply inverse. apply assoc.  apply comp.
  apply identity.   eapply inverse.
  apply (α_map (inverse (Inverse:=nat_inv Z Z) (retraction h))).
  apply identity.
  eapply composition. eapply inverse. apply assoc. eapply composition. apply comp.
  apply identity. eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp.
  apply identity. apply (triangle_inv' h). apply id_L. apply identity.
  simpl. unfold id.
  eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity.
  eapply composition. eapply inverse. apply (map_comp (adjoint f)).
  eapply (map2 (adjoint f)). eapply composition. apply comp. apply identity.
  eapply (map_comp (adjoint g)).
  eapply composition. apply assoc. eapply composition. apply comp.
  eapply inverse.
  apply (α_map (@inverse _ _ (nat_inv _ _) _ _ (retraction g))). apply identity.
  eapply composition. eapply inverse. apply assoc. eapply composition. apply comp.
  apply identity. apply (triangle_inv' g). apply id_L.
  apply (triangle_inv' f).
Defined.

Program Instance Equiv_Equiv_eq T U : Equivalence (Equiv_eq (T:=T) (U:=U)).

(* Class NaturalTransformation' T U {f g : T ---> U} (α : ∀ t : [T], f @ t ≡ g @ t) :=  *)
(*   α_map' : ∀ {t t'} (e : t ≡ t'), concat (map f e) (α t') ≡ concat (α t) (map g e) . *)

(* Definition nat_trans T U : HomT (T ---> U)  *)
(*  := λ f g, {α : ∀ t : [T], f @ t ~ g @ t & NaturalTransformation α}. *)

Definition _Functor_eq A B (f: [A] -> [B]) (H H': Functor f) :
  @_map _ _ _ H ≡ @_map _ _ _ H' -> H ≡ H'.
  intros e. destruct H, H'. simpl in e. destruct e. 
  assert (_map_id0 ≡ _map_id1). apply path_forall. intro. apply UIP.
  assert (_map_comp0 ≡ _map_comp1). apply path_forall. intro.
  apply path_forall. intro. apply path_forall. intro. apply path_forall. intro.
  apply path_forall. intro. apply UIP.
  assert (_map3 ≡ _map4). apply path_forall. intro.
  apply path_forall. intro. apply path_forall. intro. apply path_forall. intro.
  apply path_forall. intro. apply UIP.
  destruct X, X0, X1. apply identity.
Defined.

Definition __Functor_eq A B (f g: A ---> B) (H : [f] ≡ [g]) :
  (forall x y (e:x~y), transport (fun X => X ~ _) (apD10 H x) (transport (fun X => _ ~ X) (apD10 H y) (@_map _ _ _ f.2 x y e)) ≡ @_map _ _ _ g.2 x y e) -> f ≡ g.
  intro e. refine (path_sigma _ _ _ _ ). exact H. 
  apply _Functor_eq. apply path_forall. intro. apply path_forall. intro y.
  apply path_forall. intro X. specialize (e x y X). eapply concat; try exact e.
  destruct f,g. simpl in *. clear e. destruct H. apply identity.
Defined.

Definition transport_eq {A : Type} (P : A -> Type) {x y : A} (p p' : x ≡ y)
           (u u' : P x) : p ≡ p' -> u ≡ u' -> p # u ≡ p' # u'.
  destruct 1. destruct 1. apply identity.
Defined.

Definition Functor_eq A B (f g: A ---> B) (H : [f] == [g]) :
  (forall x y (e:x~y), transport (fun X => X ~ _) (H x) (transport (fun X => _ ~ X) (H y) (@_map _ _ _ f.2 x y e)) ≡ @_map _ _ _ g.2 x y e) -> f ≡ g.
  intro e. refine (__Functor_eq _ _ _ _). apply path_forall. exact H.
  intros x y X. pose (apD10 (@eisretr _ _ _ (isequiv_apD10 _ [f] [g]) H)).
  specialize (e x y X). eapply concat; try apply e.
  refine (transport_eq _ (p x) _). refine (transport_eq _ (p y) (identity _)).
Defined. 

Definition Equiv_eq_eq A B (f g: A <~> B) (H : [[f]] == [[g]]) :
  (forall x y (e:x~y), transport (fun X => X ~ _) (H x) (transport (fun X => _ ~ X) (H y) (@_map _ _ _ f.1.2 x y e)) ≡ @_map _ _ _ g.1.2 x y e) -> f ≡ g.
  intros. refine (path_sigma _ _ _ _). eapply Functor_eq; eauto.
Admitted.

Program Instance Equiv_cat : Category GroupoidType. 
Next Obligation. 
  refine (Equiv_eq_eq _ _ _ _). intro t. apply identity.
  intros. apply identity.
  (* refine (path_sigma _ _ _ _).  *)
  (* refine (path_sigma _ _ _ _). apply identity. *)
  (* apply Functor_eq. apply path_forall. intro. apply path_forall. intro. apply identity. *)
  (* eapply composition. apply section_comp. *)
  (* eapply composition. apply comp. apply (map_id [f]). apply identity. *)
  (* eapply inverse. eapply composition. apply comp. *)
  (* eapply composition. apply id_R. apply identity. apply identity. *)
  (* eapply composition. apply comp. eapply composition. eapply (map2 [f]). *)
  (* apply Equiv_adjoint_idR. simpl. apply (map_id [f]). apply identity.  *)
  (* apply identity. *)
Defined.

Next Obligation.
  refine (Equiv_eq_eq _ _ _ _). intro t. apply identity.
  intros. apply identity.
Defined.
Next Obligation. 
  refine (Equiv_eq_eq _ _ _ _). intro t. apply identity.
  intros. apply identity.
Defined.
Next Obligation.
  destruct X, X0. apply identity.
Defined.

(* Program Instance Equiv_grp : Groupoid GroupoidType. *)
(* Next Obligation. *)
(*   refine (Equiv_eq_eq _ _ _ _). intro t. pose ((section f)). simpl. *)
(*   intro; simpl; simpl_id_bi'. *)
(*   eapply composition. apply comp. apply identity. *)
(*   exact (Equiv_adjoint_simpl (f:=f ° inverse f) (f':=identity y) (section f) t). *)
(*   simpl. unfold id. *)
(*   simpl_id'. eapply composition. apply assoc. *)
(*   eapply composition; try apply id_R. *)
(*   apply comp; [idtac | apply identity]. *)
(*   apply inv_L. *)
(* Defined. *)
(* Next Obligation. exists (retraction f).  *)
(*                  apply AllEquivEq. *)
(* Defined. *)
(* Next Obligation. exists (Equiv_adjoint [X]). apply AllEquivEq. *)
(* Defined. *)
 
(* Program Instance Equiv_seq_equ (T U : GroupoidType) (f g : T <~> U) : *)
(*   Equivalence (Equiv_seq (f:=f) (g:=g)). *)

(*Program Instance Equiv_eqEquivalence T U : Equivalence (Equiv_eq (T:=T) (U:=U)).

Definition Equiv' := Equiv.
(* (λ T T' : SetoidType, [[T]] <~> [[T']]). *)

(* Program Instance EquivHom_Setoid : HomT1 SetoidType :=  {| eq1 := Equiv' |}. *)

(* Instance _Type_id' : Identity Equiv' := *)
(*  { identity T := (identity T ; _Equiv_Id) }. *)

(* Instance _Type_inv' : Inverse Equiv' := *)
(*   { inverse T U f := (adjoint f ; _Equiv_inv f) }. *)

(* Instance _Type_comp' : Composition Equiv' := *)
(*   { composition T U V f g := ([g] ° [f] ; _Equiv_comp f g) }. *)

(* Program Instance Equiv_cat_Setoid : Category SetoidType. *)
(* Next Obligation. exact (Equiv_cat_obligation_1 f). Defined. *)
(* Next Obligation. exact (Equiv_cat_obligation_2 f). Defined. *)
(* Next Obligation. exact (Equiv_cat_obligation_3 f g h). Defined. *)
(* Next Obligation. exact (Equiv_cat_obligation_4 X X0). Defined. *)

Definition EquivEqSeq (T U : GroupoidType) 
(f g : T <~> U) (α : [f] ≡ [g]) (H H' : EquivEq α) :
  H = H'.
  apply path_forall. intros u. 
  apply is_Trunc_2.
Defined.

Definition Equiv'' := (λ T T' : GroupoidType, T <~> T').

Program Instance EquivHom_Groupoid : HomT1 GroupoidType :=  {| eq1 := Equiv'' |}.

Program Instance Equiv_eqHom_Groupoid : HomT2 Equiv'' :=
{| seq := fun T T' : GroupoidType => Equiv_eq (T:=T) (U:=T') |}.

Instance _Type_id'' : Identity Equiv'' := 
 { identity T := (identity (|T|g); _Equiv_Id) }.

Instance _Type_inv'' : Inverse Equiv'' :=
  { inverse T U f := (adjoint f ; _Equiv_inv f) }.

Instance _Type_comp'' : Composition Equiv'' :=
  { composition T U V f g := ([g] ° [f] ; _Equiv_comp f g) }.

Program Instance Equiv_cat_Groupoid : Category GroupoidType.
Next Obligation. exact (Equiv_cat_obligation_1 f). Defined.
Next Obligation. exact (Equiv_cat_obligation_2 f). Defined.
Next Obligation. exact (Equiv_cat_obligation_3 f g h). Defined.
Next Obligation. exact (Equiv_cat_obligation_4 X X0). Defined.

Program Instance Equiv_Groupoid_G : GroupoidP GroupoidType. 
Next Obligation. exact (Equiv_grp_obligation_1 f). Defined.
Next Obligation. exact (Equiv_grp_obligation_2 f). Defined.
Next Obligation. exact (Equiv_grp_obligation_3 X). Defined.

Program Instance Equiv_Groupoid_S : GroupoidP SetoidType. 
Next Obligation. exact (Equiv_grp_obligation_1 f). Defined.
Next Obligation. exact (Equiv_grp_obligation_2 f). Defined.
Next Obligation. exact (Equiv_grp_obligation_3 X). Defined.


Program Instance Equiv_Groupoid : Groupoid SetoidType.
Next Obligation.  apply (@contr_equiv _ _ _ (path_sigma_equiv E E')).
  apply (@contr_sigma _ (fun p => p # E.2 = E'.2)).
  apply _Fun_Setoid_obligation_1. destruct E, E'. intro X. simpl in *. destruct X.
  apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ _ _))).
  apply contr_forall. intros a'.
  apply (@is_Trunc_2 _ _ _ _ _ _ _ _).
Defined. 
 *)

(* Definition _Type : GroupoidType := (GroupoidType ; Equiv_grp). *)
Definition Type1 : CatType := (GroupoidType ; Equiv_cat).

Definition _Type := Type1.
(*end hide *)

(** We can define the pre-groupoid [_Type] of groupoids and homotopy
 equivalences.  However, groupoids together with homotopy equivalences
 do not form a groupoid but rather a 2-groupoid. As we only have a
 formalization of groupoids, this can not be expressed in our
 setting. Nevertheless, we can state that setoids (inhabitants of
 [SetoidType]) form a groupoid.  *)

(* Definition Type0 : GroupoidType := (SetoidType ; Equiv_Groupoid). *)

(** %\noindent% In the definition above, [Equiv_Groupoid] is a proof
that [Equiv] and [Equiv_eq] form a groupoid. It makes again use of
functional extensionality to prove contractibility of higher cells.  As
[GroupoidType] appears both in the term and in the type, the use of
polymorphic universe is crucial here to avoid an inconsistency. *)
(* begin hide *)

(* Notation equiv_assoc := (@assoc Equiv_cat). *)
(* Notation equiv_comp  := (@comp  Equiv_cat). *)
(* Notation equiv_id_R  := (@id_R  Equiv_cat).  *)
(* Notation equiv_id_L  := (@id_L  Equiv_cat). *)
Notation equiv_assoc := (@assoc Equiv_cat).
Notation equiv_comp  := Equiv_cat.(comp).
Notation equiv_id_R  := Equiv_cat.(id_R).
Notation equiv_id_L  := Equiv_cat.(id_L).

(* Notation equiv_inv_R  := Equiv_grp.(inv_R). *)
(* Notation equiv_inv_L  := Equiv_grp.(inv_L). *)
(* Notation equiv_inv  := Equiv_grp.(inv). *)

Ltac compose := eapply composition.

Ltac simpl_id_end := 
  match goal with
    | [ |- seq (?P ° identity ?x) _] => compose;
       [first [apply id_R | apply equiv_id_R]|idtac]
    | [ |- seq (identity ?x ° ?P) _] => compose;
       [first [apply id_L | apply equiv_id_L]|idtac]
    | [ |- seq ((?P ^-1) ^-1) _] => compose;
       [first [apply inv_inv | apply (@inv_inv _Type)]|idtac]
    | [ |- seq ((identity ?T) ^-1) _] => compose;
       [first [apply (inv_id T)| apply (@inv_id _Type)]|idtac]
    | [ |- Equiv_eq (?P ° identity ?x) _] => compose; [apply equiv_id_R|idtac]
    | [ |- Equiv_eq (identity ?x ° ?P) _] => compose; [apply equiv_id_L|idtac]
    | [ |- Equiv_eq ((?P ^-1) ^-1) _] => compose; [apply (@inv_inv _Type)|idtac]
    | [ |- Equiv_eq ((identity _) ^-1) _] => compose; [apply (@inv_id _Type)|idtac]
  end.

Ltac simpl_id_end_extended := first [ simpl_id_end |
                                      match goal with
                   | [ |- Equiv_eq ?e _ ] => apply (identity e)
                   | [ |- seq ?e _ ] => apply (identity e)
                   | [ |- _ ] => idtac
                 end].

Ltac simpl_id := first [simpl_id_end ; simpl_id |
  lazymatch goal with
    | |- context [identity _] => fail
    | |- _ => apply identity
  end|
  match goal with
    | [ |- seq (?P ^-1) _] =>
      eapply composition;
        [first [apply equiv_inv | apply inv] ; simpl_id | idtac]; 
        try apply identity
    | [ |- seq (map ?F (identity _)) _] => 
      eapply composition;
        [eapply (map_id F); simpl_id | idtac]; 
        simpl_id
    | [ |- Equiv_eq (map ?F (identity _)) _] => 
      eapply composition;
        [eapply (map_id F); simpl_id | idtac]; 
        simpl_id
    | [ |- seq (map ?F ?P) _] => 
      first [eapply composition;
              [eapply (map2 F); simpl_id | idtac]; 
              [apply identity | idtac] | 
             (progress_evars (eapply composition;
                              [eapply (map2 F); simpl_id | idtac];instantiate));
               simpl_id |idtac]
    | [ |- Equiv_eq (map ?F ?P) _] => 
      first [eapply composition;
              [eapply (map2 F); simpl_id | idtac]; 
              [apply identity | idtac] | 
             (progress_evars (eapply composition;
                              [eapply (map2 F); simpl_id | idtac];instantiate));
               simpl_id |idtac]
    | [ |- Equiv_eq (?P ^-1) _] =>
      eapply composition;
        [apply equiv_inv; simpl_id | idtac]; 
        try apply identity
    | [ |- Equiv_eq (?Q ° ?P) _] =>
      eapply composition;
        [apply equiv_comp ; simpl_id | idtac];
        simpl_id_end_extended
    | [ |- Equiv_eq ?e _ ] => apply (identity e)
    | [ |- seq (?Q ° ?P) _] =>
      eapply composition;
        [first [apply comp |
                apply equiv_comp] ; simpl_id | idtac];
        simpl_id_end_extended
    | [ |- seq ?e _ ] => first [has_evar e; idtac | apply (identity e)]
    | [ |- _ ] => idtac
  end].

Ltac simpl_id_bi := simpl_id; eapply inverse; simpl_id.

(* Definition Fun_Type_Groupoid (T U : [Type1]) := T ---> U. *)

(* Program Instance comp_funG : Composition Fun_Type_Groupoid := *)
(*   { composition x y z X X0 := (λ x, X0 @ (X @ x) ; arrow_comp _ _ _ _ _) }. *)

(* Instance id_funG : Identity Fun_Type_Groupoid := *)
(*   { identity x := (id (A:=[x]) ; arrow_id _) }. *)

(* Infix "--->" := Fun_Type_Groupoid (at level 55). *)
(* Infix "-G->" := Fun_Type_Groupoid (at level 55).  *)

(* Instance _Fun_GroupoidP (T U : [Type1]) : GroupoidP (T -G-> U). *)
(* Next Obligation. intro t. apply inv_R. Defined. *)
(* Next Obligation. intro t. apply inv_L. Defined. *)
(* Next Obligation. intro t. apply inv. exact (X t). Defined. *)

(* Instance _Fun_Groupoid (T U : [Type1]) : Groupoid (T -G-> U). *)
(* Next Obligation.  *)
(*   apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ E E'))). *)
(*   apply contr_forall. intros z. *)
(*   apply (@is_Trunc_2 _ _ _ _ (e @ z) (e' @ z)). *)
(* Defined. *)

(* Definition Fun_Groupoid (T U : [Type1]) := (T -G-> U; _Fun_Groupoid T U) : GroupoidType. *)

(* Infix "-||->" := Fun_Groupoid (at level 90).  *)


(* Program Instance comp_fun_Setoid : Composition Fun_Type_Setoid := *)
(*   { composition x y z X X0 := (λ x, X0 @ (X @ x) ; _) }. *)

(* Program Instance id_fun_Setoid : Identity Fun_Type_Setoid := *)
(*   { identity x := (id (A:=[x]) ; arrow_id _) }. *)


(* end hide *)
(** ** Rewriting in homotopy type theory
  %\label{sec:rew}%

  When considering a dependent family [F] of type [[A --> _Type]], the [_map] function
  provides a homotopy equivalence between [F @ x] and [F @ y] for any [x]
  and [y] such that [x ~ y]. The underlying map of homotopy equivalence
  can hence be used to cast any term of type [[F @ x]] to [[F @ y]].
*)

Infix "-->" := __fun (at level 90). 

Definition transport A (F : [A --> _Type]) {x y:[A]} (e:x ~ y) 
  : (GroupoidTypeToCatType (F @ x)) ---> (GroupoidTypeToCatType (F @ y)) := [map F e].

(** Using compatibility on [_map], we can reason on different transport paths.  
  Intuitively, any two transport maps with the same domain
  and codomain should be the same up to homotopy. As we only consider
  groupoids, there is only one relevant level of compatibilities,
  higher compatibilities are trivial. [transport_eq] is an example of a
  derivable equality between two transport maps, when the proofs
  relating [x] and [y] are equal.  *)

Definition transport_eq2 A (F:[A --> _Type]) {x y:[A]} {e e':x ~ y} (H:e ≡ e')
  : transport F e ≡ transport F e' := (map2 F H)..1.

(** %\noindent% In the text, 
  we also use [transport_id], [transport_comp] and [transport_map] for compatibilities with identities, composition and for the functoriality of [transport]. *)

(* begin hide *)

Definition transport_map A {x y} (F: [A --> _Type]) 
  {p q : [F @ x]} (e : x ~ y) (H : p ~ q) : 
  (transport F e) @ p ~ (transport F e) @ q  :=
  map [map F e] H.

Definition transport_comp A {x y z : [A]} (F: [A --> _Type])
  (e : x ~ y) (e' : y ~ z) : 
  transport F (e' ° e) ≡ transport F e' ° transport F e :=  
  (map_comp F e e')..1.

Definition transport_id A (F : [A --> _Type]) {x : [A]}
  : transport F (identity x) ≡ identity _ := 
  (@_map_id _ _ _ F.2 x)..1.

Definition transport_inv (A:GroupoidType) (x : [A]) (F: [A --> _Type]) 
  (y : [A]) (e : x ~ y) : transport F (inverse e) ° transport F e ≡ identity _. 
Proof. 
  eapply composition. eapply inverse. exact (transport_comp F e (e^-1)). auto.
  eapply composition. refine (transport_eq2 _ _). apply identity. exact (inv_L _ _ e).
  apply transport_id. 
Defined.

(*
Ltac trunc_eq := match goal with
                     | [ |- ?e ≡ ?e'] =>
                       let H := fresh in
                       let H':=fresh in 
                       set(H':=e) in *; clearbody H';
                       assert (H:=@center _ (Trunc_2 (T:=Type0) _ _ _ _ H' e'));
                                         try ((destruct H; apply identity) 
                                                || (simpl in *; destruct H; apply identity))

                   end.
*)      

Ltac trunc_eq := apply UIP.

Lemma map2_id : forall T (f : [T --> Type1]) {x y:[T]} (e: x ~ y), 
                  map2 f (identity e) ≡ identity (map f e).
Proof. intros. trunc_eq. Defined.

Lemma map2_comp : forall T (f : [T --> Type1]) {x y:[T]} (e e' e'':x ~ y) 
                       (E:e ≡ e') (E':e'≡ e''),
                    map2 f (E' ° E) ≡ map2 f E' ° map2 f E.
Proof. intros. trunc_eq. Defined.

Lemma map2_id_L : ∀ T (f : [T --> Type1]) {x y : [T]} (e:x ~ y),
  map2 f (id_L' e) ≡
  id_L' (map f e) ° (identity (map f e) ** @_map_id _ _ _ f.2 _) ° map_comp f _ _. 
Proof. intros. trunc_eq. Defined.

Lemma map2_id_R : ∀ T (f : [T --> Type1]) {x y : [T]} (e:x ~ y),
  map2 f (id_R' e) ≡ 
  id_R' (map f e) ° (@_map_id _ _ _ f.2 _ ** identity (map f e)) ° map_comp f _ _.
Proof. intros. trunc_eq. Defined.

Definition assoc'' {T} {Hom1 : HomT1 T} {Category} 
           {x y z w : T} {e e' e''} := 
  assoc (Category := Category) x y z w e e' e''.

Lemma map2_assoc : ∀ T (f : [T --> Type1]) {x y z w : [T]} 
                     (e:x ~ y) (e':y ~ z) (e'':z ~ w),
  assoc'' ° (identity _ ** map_comp f e' e'')  ° map_comp f e (e'' ° e')  ≡
  (map_comp f _ _ ** identity _) ° map_comp f (e' ° e) e'' ° map2 f assoc''.
Proof. intros. trunc_eq. Defined.

Lemma map2_comp' : ∀ T (f : [T --> Type1]) {x y z : [T]} 
                     (e e':x ~ y) (g g':y ~ z) 
                     (E : e ≡ e') (E' : g ≡ g'),
  map_comp f _ _ ° map2 f (comp _ _ _ E E') ≡ 
  comp _ _ _ (map2 f E) (map2 f E') ° map_comp f _ _.
Proof. intros. trunc_eq. Defined.

Lemma map_inv2 {T} (f : [T --> Type1]) :
  ∀ x y (e e' : x ~ y) (E : e ≡ e') , 
    map2 f (inverse E) ≡ inverse (map2 f E).
Proof. intros. trunc_eq. Defined.

Lemma map3 : ∀ T (f : [T --> Type1]) {x y : [T]} (e e' : x ~ y) (E E' : e ≡ e'),
               map2 f E ≡ map2 f E'.
Proof. intros. trunc_eq. Defined.

(* end hide *)
(** ** Dependent Product 
  %\label{sec:depprod}%
  As for functions, dependent functions will be interpreted as functors. 
  But this time, the compatibilities with higher-order morphisms cannot
  be expressed as simple equalities, as some transport has to be done to 
  make those equalities typable. We call such a functor a 
  %\emph{dependent functor}%. Dependent functors are defined between a groupoid [T] and a functor [U] from [T] to [_Type] (the pre-groupoid of groupoids). [U] must be seen as a type depending on [T], or as a family of types indexed by [T]. 
*)

Definition Eq_lift {T:CatType} (x y: [T]) :
  x ≡ y -> x ~ y := fun e => e # identity _. 

Notation "↑ e" := (Eq_lift e) (at level 50).

Notation "f @@ x" := (apD10 f..1 x) (at level 50).

Class DependentFunctor T (U : [T --> _Type]) (f : ∀ t, [U @ t]) : Type := {
  _Dmap      : ∀ {x y} (e: x ~ y), transport U e @ (f x) ~ f y;
  _Dmap_id   : ∀ x, _Dmap (identity x) ≡ ↑ (transport_id U @@ f x);
  _Dmap_comp : ∀ x y z (e : x ~ y) (e' : y ~ z),
   _Dmap (e' ° e) ≡ _Dmap e' ° transport_map U _ (_Dmap e) ° 
                     ↑ ((transport_comp U e e') @@ _);
  _Dmap2  : ∀ x y (e e': x ~ y) (H: e ≡ e'),
    _Dmap e ≡ _Dmap e' ° ↑ (transport_eq2 U H @@ f x)}.  

Definition Prod_Type T (U:[T --> _Type]) := {f : ∀ t, [U @ t] & DependentFunctor U f}.

(* begin hide *)

Hint Extern 0 (DependentFunctor _ [?f]) => exact (proj2 f) : typeclass_instances.

Notation "'Dmap' f" := (_Dmap (DependentFunctor := f.2)) (at level 0, f at level 0).
Notation "'Dmap_id' f" := (_Dmap_id (DependentFunctor := f.2) _) (at level 0, f at level 0).
Notation "'Dmap_comp' f" := (_Dmap_comp (DependentFunctor := f.2) _ _ _) (at level 0, f at level 0).
Notation "'Dmap2' f" := (_Dmap2 (DependentFunctor := f.2) _ _ _ _) (at level 0, f at level 0).

(* end hide *)
(** 
  Equality between dependent functors is given by dependent natural transformations
  and equality at level 2 is given by dependent modifications.
*)

Class DNaturalTransformation T (U:[T --> _Type]) {f g: Prod_Type U} (α : ∀ t, f @ t ~ g @ t)
 := _α_Dmap : ∀ {t t'} e, α t' ° Dmap f e ≡ Dmap g e ° transport_map U e (α t).

Definition Dnat_trans T (U:[T --> _Type]) (f g: Prod_Type U)  
  := {α : ∀ t : [T], f @ t ~ g @ t & DNaturalTransformation α}.

(* begin hide *)

Hint Extern 0 (DNaturalTransformation [?f]) => exact (proj2 f) : typeclass_instances.
Notation α_Dmap f := (@_α_Dmap (proj2 f) _ _).

Program Instance Dnat_id T U : Identity (Dnat_trans (T:=T) (U := U)).
Next Obligation. 
  rename x into f. exists (λ t , identity (f @ t)). 
  intros. unfold transport_map. intros t t' e. 
  eapply composition. apply id_L.
  eapply inverse. eapply composition. eapply comp.
  apply (map_id [map U e]).
  apply identity. apply id_R.
Defined.
 
Program Instance Dnat_inv T U : Inverse (Dnat_trans (T:=T) (U := U)).
Next Obligation. 
  rename x into f, y into g, X into  H. 
  exists (λ t , inverse (H @ t)).
  intros. unfold transport_map. destruct H as [H Hmap]. simpl in *.
  intros t t' e.
  eapply inverse. unfold transport_map in Hmap. eapply right_simplify'.
  eapply composition. apply assoc.
  eapply composition. apply comp.
  eapply composition. apply comp. apply identity. apply (map_inv [map U e]).
  apply inv_L. apply identity.
  eapply composition. apply id_R.
  eapply inverse. eapply composition.
  eapply composition. apply assoc.
  eapply composition. apply comp. eapply inverse; apply Hmap. apply identity.
  eapply composition. eapply inverse.  apply assoc.
  apply comp. apply identity. apply inv_L.
  apply id_L.
Defined.

Program Instance Dnat_comp T (U:[T --> _Type]) : 
  Composition (Dnat_trans (U := U)).
Next Obligation. 
  rename x into f, y into g, z into h, X into H, X0 into H'. 
  exists (λ t , composition (H @ t) (H' @ t)).
  intros. unfold transport_map. intros t t' e. eapply inverse.
  eapply composition. apply comp.
  apply (map_comp [map U e]).
  apply identity.
  eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity.
  eapply inverse. apply (Π2 H').
  eapply composition. apply assoc.
  eapply composition. apply comp. eapply inverse, (Π2 H). apply identity.
  eapply composition. eapply inverse.  apply assoc. apply identity.
Defined.

Program Instance Dnat_transHom T (U:[T --> _Type]) : HomT1 (Prod_Type U) := 
  {eq1 := Dnat_trans (T:=T) (U:=U)}.

(* end hide *)

Definition Dmodification_eq T U (f g : Prod_Type U) (α β:f ~ g):
 (∀ t : [T], α @ t ≡ β @ t) -> α ≡ β.
  intro e. refine (path_sigma _ _ _ _).
  apply path_forall. exact e.
  repeat (apply path_forall; intro). apply UIP.
Defined.
  
Instance Dnat_trans_cat T (U:[T --> _Type]) :
  Category (Prod_Type U).
Next Obligation. apply Dmodification_eq. intro t. apply id_R. Defined.
Next Obligation. apply Dmodification_eq. intro t. apply id_L. Defined.
Next Obligation. apply Dmodification_eq. intro t. apply assoc. Defined.
Next Obligation. apply Dmodification_eq. intro t. apply comp.
                 apply (X @@ _). apply (X0 @@ _). Defined.

Program Instance Dnat_trans_grp T (U:[T --> _Type]) : Groupoid (Prod_Type U).
Next Obligation. apply Dmodification_eq. intro t. apply inv_R.  Defined.
Next Obligation. apply Dmodification_eq. intro t. apply inv_L.  Defined.
Next Obligation. apply Dmodification_eq. intro t. apply inv. exact (X @@ _). Defined.

(* end hide *)
(** %\noindent% We can now equip dependent functors with a groupoid structure
    as we have done for functors.
    We note [_Prod U] the dependent product over a family of groupoids [U].
*)

(* begin hide *)

(* Instance Type1_Type_ T (f: [T --> Type1]) : @Functor T _Type (λ X : [T], f @ X ) :=  *)
(*   {| _map x y := f.(proj2).(_map) ;  *)
(*      _map_comp x y z := f.(proj2).(_map_comp); *)
(*      _map2 x y e e' := f.(proj2).(_map2) |}. *)

(* Definition Type1_Type T : [T --> Type1] -> [T --> _Type] :=  *)
(*   fun f => (fun X => f @ X ; Type1_Type_ f). *)

(* Program Instance prod_Groupoid T (U:[T --> Type1]) :  *)
(*   Groupoid (Prod_Type U). *)
(* Next Obligation. *)
(*   apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ E E'))). *)
(*   apply contr_forall. intros z. *)
(*   apply (@is_Trunc_2 _ _ _ _ _ _ (E z) (E' z)). *)
(* Defined. *)

Definition _Prod T (U:[T --> _Type]) := (Prod_Type U ; Dnat_trans_grp T U).

(* Definition Prod1 T (U:[|T|g --> Type1]) := (Prod_Type (Type1_Type U) ; prod_Groupoid T U). *)

(* Notation "[[ x ']]'" := (SetoidTypeToGroupoidType x) (at level 50). *)
(*
Instance Type1_Type_ T (f: [T --> Type1]) : @Functor T _Type (λ X : [T], [[ f @ X]]) := 
  {| _map x y := f.(proj2).(_map) ; 
     _map_comp x y z := f.(proj2).(_map_comp);
     _map2 x y e e' := f.(proj2).(_map2) |}.

Definition Type1_Type T : [T --> Type1] -> [T --> _Type] := 
  fun f => (fun X => [[f @ X]] ; Type1_Type_ f).

Notation "'[[[' x ']]]'" := (Type1_Type x) (at level 50).

Definition DNaturalTransformationSeq T (U:[T --> Type1]) 
 {f g: Prod_Type (Type1_Type U)} (α : ∀ t : [T], f @ t ~ g @ t)
  (H H' : DNaturalTransformation (T:=T) (U:=Type1_Type U) α):
  H = H'.
  apply path_forall. intros t. apply path_forall. intros t'.
  apply path_forall. intros E.
  apply is_Trunc_2.
Defined.

Program Instance prod_Groupoid1 T (U:[T --> Type1]) : 
  Groupoid (Prod_Type (Type1_Type U)).
Next Obligation.
  apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ E E'))).
  apply contr_forall. intros z.
  apply (@is_Trunc_2 _ _ _ _ _ _ (E z) (E' z)).
Defined.

Program Instance Prod_setoid T (U:[T --> Type1]) : 
  Setoid (Prod_Type (Type1_Type U)).
Next Obligation.
  apply (@contr_equiv _ _ _ (path_sigma_equiv e e')).
  apply (@contr_sigma _ (fun p => p # e.2 = e'.2)).
  apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ [e] [e']))).
  apply contr_forall. intros z.
  apply (@is_Trunc_1 _ _ _ _ (e @ z) (e' @ z)).
  intros.   destruct e, e'. simpl in *. destruct a. simpl. 
  apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ _ _))).
  apply contr_forall. intros t. 
  apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ _ _))).
  apply contr_forall. intros t'. 
  apply (@contr_equiv _ _ _ (isequiv_inverse _ _ _ (isequiv_apD10 _ _ _))).
  apply contr_forall. intros e. 
  apply (@is_Trunc_2 _ _ _ _ _ _ _ _).
Defined.
*)

(* end hide *)
(** A family of setoids can be seen as a family of groupoids using a
lifting that we abusively note [ [[[U]]] ]. We can prove that the
dependent product over a family of setoids is also a setoid. We note
[Prod0] the restriction of [_Prod] to families of setoids.  *)

(* begin hide *)

Definition Prod0 := _Prod.
(* T (U:[T --> Type1]) : [Type1] := (Prod_Type ([[[U]]]); Prod_setoid T U).  *)
(* end hide *)
(** ** Dependent sums 

%\label{sec:sigma}% In the interpretation of Σ types, we pay for the
fact that we are missing the 2-dimensional nature of [_Type]. Indeed, as
we will need rewriting in the definition of equality on Σ types,
delivering the corresponding groupoid structure requires to reason on
compatibility between rewritings, which amount to the missing
2-dimensional laws. However, as [Type1] is a groupoid, all 2-dimensional
equalities become trivial on a family of setoids, so we can define the
groupoid of Σ types over a groupoid [T] and a morphism of type [ [T -||-> Type1] ].*)

(*  This *)
(* corresponds to the fact that our source theory has restricted sums: the *)
(* first component cannot be a type itself.  *)

Definition sum_type T (U : [T --> Type1]) := {t : [T] & [U @ t]}.

(** %\noindent%
  The 1-equality between dependent pairs is given by 1-equality on the
  first and second projections, with a transport on the second
  projection on the left.
*)

Definition sum_eq T (U : [T --> Type1]) : HomT (sum_type U) := 
  λ m n, {P : [m] ~ [n] & transport U P @ (Π2 m) ~ Π2 n}.

(* begin hide *)

Program Instance sum_id T U : Identity (sum_eq (T:=T) (U:=U)) :=
  { identity x := (identity (Π1 x) ; ↑ (transport_id U @@ Π2 x)) }.

Program Instance sum_inv (T:GroupoidType) U: Inverse (sum_eq (T:=T) (U:=U)).
Next Obligation. 
Proof. 
  rename x into m, y into n, X into H. 
  exists (inverse [H]).
  apply (Equiv_injective (map U [H])).
  eapply composition; try exact (inverse (Π2 H)). unfold transport. 
  assert (map_inv_R : forall {T : GroupoidType} U (U : T ---> U) x y (e : x ~ y),
                        map U e ° map U (inverse e) ≡ identity (U @ y)). 
  - intros. eapply composition. eapply inverse. apply (map_comp U1).
    eapply composition. eapply (map2 U1). apply inv_R. apply (map_id U1). 
  - exact (↑ ((map_inv_R T Type1 U _ _ [H])..1 @@ (Π2 n))).
Defined.

Program Instance sum_comp T U : Composition (sum_eq (T:=T) (U:=U)).
Next Obligation. 
  rename x into m, y into n, z into p, X into H1, X0 into H2. 
  exists ([H2] ° [H1]). 
  eapply composition. 
  exact (↑(transport_comp U [H1] [H2] @@ m.2)). 
  eapply composition; [idtac | exact (Π2 H2)].
  unfold composition. simpl. unfold transport.  
  apply (map [map U [H2] ] (Π2 H1)).
Defined.

Program Instance sum_eqHom T (U : [T --> Type1]) : HomT1 (sum_type U) := 
  {eq1 := sum_eq (T:=T) (U:=U)}.

(* end hide *)
(** %\noindent%
  In the same way, 2-equality between 1-equalities is given by projections
  and rewriting.
*)

(* Definition sum_seq T (U : [T --> Type1]) (M N : sum_type U) : HomT (M ~ N)  *)
(*   := λ e e' , {P : [e] ≡ [e'] & Π2 e ≡ Π2 e' ° ↑ (transport_eq2 U P @@ (Π2 M))}. *)

(* begin hide *)

Definition ap_ {A B:Type} (f g:A -> B) {x:A} (p q:f ≡ g) (e:p≡q) : apD10 p x ≡ apD10 q x.
  destruct e. constructor.
Defined.

(* Program Instance sum_seq_id T U (M N : sum_type (T:=T) U) : *)
(*   Identity (sum_seq (M:=M) (N:=N)). *)
(* Next Obligation.  *)
(*   exists (identity _).  *)
(*   eapply inverse. eapply composition. *)
(*   apply comp. pose (map2_id U [x]).  *)
(*   apply ap. apply ap_. apply ap. simpl in *. unfold transport_eq2. apply ap. exact s. *)
(*   apply identity. apply id_R. *)
(* Defined. *)

Definition Eq_lift_compose {T} (x y z: [T]) (e: x ≡ y) (e': y ≡ z):
  (↑ e' ° ↑ e) ≡ ↑ (e' ° e). 
  destruct e. apply id_R.
Defined. 

Definition apD10_concat {A} {B:A->Type} {f g h : forall x, B x} (e:f ≡ g) (e':g ≡ h) x
: apD10 e x @@@ apD10 e' x ≡ apD10 (e @@@ e') x. 
  destruct e. apply identity.
Defined.

Definition path_proj1_concat {A : Type} (P : A -> Type) (u v w: sigma P)
  (p : u ≡ v) (q : v ≡ w) : p..1 @@@ q..1 ≡ (p @@@ q)..1.
  destruct p. constructor.
Defined.

Definition concat_inv_L {T} (x y: T) (e: x ≡ y) :
  e^-1 @@@ e ≡ identity y. 
  destruct e. constructor.
Defined. 

Definition sum_seq_prop T (U : [T --> Type1]) (x y : sum_type U)
           (e e': x ~ y) :
           {P : [e] ≡ [e'] & Π2 e ≡ Π2 e' ° ↑ (transport_eq2 U P @@ (Π2 x))}
           -> e ≡ e'. 
  intros [X1 X2]. refine (path_sigma _ _ _ _).
  exact X1. eapply composition. apply ap. exact X2. clear.
  destruct e, e'. simpl in *. destruct X1. simpl. eapply composition.
  apply comp. unfold transport_eq2. apply ap. apply ap_. apply ap.
  apply ap. apply map2_id. apply identity. simpl. apply id_R.
Defined.

Definition sum_seq_prop_inv T (U : [T --> Type1]) (x y : sum_type U)
           (e e': x ~ y) :
  e ≡ e' ->
  sigma (fun P : [e] ≡ [e'] => Π2 e ≡ Π2 e' ° ↑ (transport_eq2 U P @@ (Π2 x))).
  destruct 1. exists (identity _). apply inverse.
  unfold transport_eq2. eapply composition. apply comp. 
  apply ap. apply ap_. apply ap. apply ap. apply map2_id.
  apply identity. apply id_R.
Defined. 
  
Definition transport_map_lift A B (f: A ---> B) 
  {p q : [A]} (H : p ≡ q) :
  map f (↑ H) ≡ ↑ (eq_with_uip.transport (fun X => f @ _ ≡ f @ X) H (identity _)).
  destruct H. simpl. apply (map_id f). 
Defined.

Definition map_eq A B (f g : A ---> B)
           (H : f ≡ g) (x y:[A]) (e: x ~ y) :
  (↑ (H @@ y)) ° map f e ≡ map g e ° ↑ (H @@ x).
  destruct H. simpl. eapply composition. apply id_L. apply inverse. apply id_R.
Defined. 

Program Instance sum_category2 T U : Category (sum_type (T:=T) U).
Next Obligation.
  apply sum_seq_prop. 
  exists (id_R _ _ [f]). simpl.
  eapply composition. apply assoc. apply comp; try apply identity.
  eapply composition. apply comp. apply identity.
  apply (transport_map_lift [map U [f]]). eapply composition. refine (Eq_lift_compose _ _). 
  apply ap. apply UIP. 
Defined.

Next Obligation.
  apply sum_seq_prop.
  exists (id_L _ _ [f]). simpl.
  eapply composition. apply comp. apply identity.
  refine (map_eq (map_id U y.1)..1 _ _ f.2).
  eapply composition. apply assoc. apply comp; try apply identity.
  eapply composition. refine (Eq_lift_compose _ _). 
  apply ap. apply UIP. 
Defined.

Next Obligation.
  apply sum_seq_prop.
  exists (assoc _ _ _ _ [f] [g] [h]). simpl. 
  unfold transport_comp, transport, transport_eq2.
  eapply composition. apply assoc. eapply composition. apply assoc.
  eapply composition. apply assoc. eapply inverse.
  eapply composition. apply assoc. eapply composition. apply assoc.
  apply comp; try apply identity. eapply composition. apply comp. apply identity.
  eapply composition.
  apply (map_comp [map U [h]]). apply comp.
  apply identity.
  apply (map_comp [map U [h]]). eapply composition. apply assoc.
  eapply composition. apply assoc.
  apply comp; try apply identity.
  apply inverse. eapply composition. eapply inverse. apply assoc. 
  eapply composition. apply comp. apply identity.
  refine (map_eq (map_comp U g.1 h.1)..1 _ _ f.2). 
  eapply composition. apply assoc. apply comp; try apply identity.
  eapply composition. refine (Eq_lift_compose _ _). apply inverse.
  eapply composition. apply comp. refine (Eq_lift_compose _ _).
  apply (transport_map_lift [map U [h]]). eapply composition. refine (Eq_lift_compose _ _).
  apply ap. apply UIP. 
Defined. 

Next Obligation.
  apply sum_seq_prop. simpl. 
  exists (comp _ _ _ X..1 X0..1).
  eapply composition. apply assoc. eapply composition.
  apply comp. apply identity. apply (sum_seq_prop_inv X0).2.
  eapply composition. apply assoc.
  eapply inverse. eapply composition. apply assoc. eapply composition. apply assoc.
  apply comp; try apply identity. unfold transport_eq2. 
  eapply inverse. eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp.
  apply identity. refine (map_eq (map2 U (sum_seq_prop_inv X0).1)..1 _ _ f.2).
  eapply composition. apply assoc. eapply composition.
  apply comp. apply identity.
  eapply composition.
  apply (map2 [map U [g']] ((sum_seq_prop_inv X).2)).
  apply (map_comp [map U [g']]).
  eapply composition. apply assoc. apply comp; [idtac | apply identity].
  eapply composition. apply comp. refine (Eq_lift_compose _ _).
  apply (transport_map_lift [map U [g']]). eapply composition. refine (Eq_lift_compose _ _).
  apply inverse.  eapply composition. refine (Eq_lift_compose _ _).
  apply ap, UIP. 
Defined.

Lemma id_R'' (T : CatType) (x y : [T]) (f g : x ~ y) : 
  f ≡ g -> f ° identity x ≡ g.
Proof. intros. eapply composition. apply id_R'. apply X. Defined.

Program Instance sum_groupoid (T:GroupoidType)
        (U : [T --> Type1]) :
  Groupoid (sum_type U).
Next Obligation. apply sum_seq_prop. exists (inv_R _ _ _). simpl. 
  unfold Equiv_injective. simpl.
  eapply composition. apply comp. apply identity.
  apply comp. eapply composition.  eapply (map2 [map U [f]]).
  eapply composition. apply comp. apply identity.
  eapply composition. eapply inverse. apply comp_inv.
  apply comp. eapply composition. eapply inverse. apply map_inv.
  eapply composition.
  eapply (map2 (adjoint (map U [f]))). apply inv_inv.
  eapply composition. eapply (map_comp (adjoint (map U [f]))).
  apply identity. apply identity. eapply composition. apply assoc.
  eapply composition. apply comp. apply assoc. apply identity. 
  eapply composition. eapply inverse. apply assoc.
  eapply composition. apply comp. apply identity.
  apply comp. apply identity. apply inv_inv. apply identity.
  eapply composition. eapply (map_comp [map U [f]]).
  apply comp. apply identity. eapply composition. apply (map_comp [map U [f]]).
  apply comp. apply identity. eapply inverse. apply (triangle (map U [f])).
  apply identity. eapply composition. apply comp. apply identity.
  eapply composition. eapply inverse. apply assoc. apply comp.
  apply identity. eapply composition. apply comp.
  apply (α_map (section (map U [f]))). apply identity.
  eapply composition. eapply inverse. apply assoc. eapply composition.
  apply comp. apply identity. apply inv_R. apply id_L.
  eapply composition. apply comp. apply identity. apply comp.
  apply (map_comp [map U [f]]). apply identity. 
  eapply composition. (* eapply (map2 [map U [f]]). *)
  (* eapply composition. apply comp. apply identity. *)
  (* apply (transport_map_lift (adjoint (map U [f]))). *)
  (* apply map_eq. *)
  (* simpl. apply (map_id (U @ [y].  *)
  (* ([map U [f]] @ eq_section x)). *)
  (* simpl in n. red in n.  apply inv. *)
  (* eapply inverse. apply (map_comp _ _). *)
  (* inv_inv. apply comp_inv.   *)
  (* apply comp. eapply (map_comp (adjoint (map U [f]))). *)
  (* apply identity. apply identity. apply identity. *)
  (* apply identity. *)

  (*                simpl. *) 
  Admitted.  
Next Obligation. apply sum_seq_prop. exists (inv_L _ _ _). Admitted.
Next Obligation. apply sum_seq_prop. exists (inv _ _ X..1). simpl. Admitted.


(* Definition _Sum T (U:[T-->Type1]) : [_Type] := (sum_type U ; sum_groupoidP _ U).  *)

Definition _Sum1 (T:GroupoidType) (U:[T-->Type1]) : [Type1] := (sum_type U ; sum_groupoid _ U). 

Typeclasses Opaque sum_eq nat_trans  
            Dnat_trans  Equiv_eq .

(* end hide *)

(** %\noindent% This way, we can define the groupoid [_Sum0 U] of dependent sums for any family of setoids. When [T] is a setoid, [_Sum0 U] is also a setoid.
*)